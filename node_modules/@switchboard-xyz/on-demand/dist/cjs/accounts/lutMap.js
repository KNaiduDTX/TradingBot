"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LutMap = void 0;
const constants_js_1 = require("../constants.js");
const spl = __importStar(require("../utils/index.js"));
const queue_js_1 = require("./queue.js");
const state_js_1 = require("./state.js");
const anchor_1 = require("@coral-xyz/anchor");
const buffer_1 = require("buffer");
/**
 *  A map of LUTs to their public keys.
 *
 *  Users can initialize to compact all oracle and feed keys they use into a single
 *  account, and then use the LUT to load all tx keys efficiently.
 */
class LutMap {
    /**
     *  The public key of the LUT map account.
     */
    static keyFromSeed(program, queue, authority) {
        return __awaiter(this, void 0, void 0, function* () {
            const [lut] = anchor_1.web3.PublicKey.findProgramAddressSync([
                buffer_1.Buffer.from("LutMapAccountData"),
                queue.toBuffer(),
                authority.toBuffer(),
            ], program.programId);
            return lut;
        });
    }
    /**
     * Creating a LUT map account will allow a user or protocol to easy manage
     * and associate a common account grouping for their feeds to reduce the
     * total number of transaction bytes taken by Switchboard.
     * This will maximize the flexibility users have in their instructions.
     *
     * @param program - The program that owns the LUT map account.
     * @param queue - The queue account that the LUT map is associated with.
     * @param slot - The slot that the LUT map is associated with.
     * @returns A promise that resolves to the LUT map and the transaction signature.
     */
    static create(program, queue, slot) {
        return __awaiter(this, void 0, void 0, function* () {
            const payer = program.provider.wallet.payer;
            const lutKey = yield LutMap.keyFromSeed(program, queue, payer.publicKey);
            const sig = yield program.rpc.lutMapInit({ slot }, {
                accounts: {
                    lutMap: lutKey,
                    queue: queue,
                    payer: payer.publicKey,
                    authority: payer.publicKey,
                    systemProgram: anchor_1.web3.SystemProgram.programId,
                },
                signers: [payer],
            });
            return [new LutMap(program, lutKey), sig];
        });
    }
    constructor(program, pubkey) {
        this.program = program;
        this.pubkey = pubkey;
    }
    queueLutExtendIx(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const payer = this.program.provider.wallet.payer;
            const queueAccount = new queue_js_1.Queue(this.program, params.queue);
            const queueData = yield queueAccount.loadData();
            const lutKey = yield LutMap.keyFromSeed(this.program, params.queue, payer.publicKey);
            const lutSigner = (yield anchor_1.web3.PublicKey.findProgramAddress([buffer_1.Buffer.from("LutSigner"), params.queue.toBuffer()], this.program.programId))[0];
            const ix = yield this.program.instruction.queueLutExtend({ newKey: params.newKey }, {
                accounts: {
                    queue: params.queue,
                    authority: queueData.authority,
                    lutSigner,
                    lut: lutKey,
                    addressLookupTableProgram: anchor_1.web3.AddressLookupTableProgram.programId,
                    payer: payer.publicKey,
                    systemProgram: anchor_1.web3.SystemProgram.programId,
                },
            });
            return ix;
        });
    }
    /**
     *  Loads the data for this {@linkcode LutMap} account from on chain.
     *
     *  @returns A promise that resolves to the data.
     *  @throws if the account does not exist.
     */
    loadData() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.program.account["lutMapAccountData"].fetch(this.pubkey);
        });
    }
    loadLut() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.loadData();
            const lutKey = data.lut;
            const lutAccountInfo = yield this.program.provider.connection.getAccountInfo(lutKey);
            const lutData = anchor_1.web3.AddressLookupTableAccount.deserialize(lutAccountInfo.data);
            return [lutKey, lutData];
        });
    }
    syncLut(feeds) {
        return __awaiter(this, void 0, void 0, function* () {
            const wrapperData = yield this.loadData();
            const [key, data] = yield this.loadLut();
            const queueKey = wrapperData.queue;
            const queue = new queue_js_1.Queue(this.program, queueKey);
            const queueData = yield queue.loadData();
            const oracles = queueData.oracleKeys.slice(0, queueData.oracleKeysLen);
            const neededLutAccounts = [];
            neededLutAccounts.push(queueKey);
            neededLutAccounts.push(constants_js_1.SOL_NATIVE_MINT);
            neededLutAccounts.push(constants_js_1.SPL_TOKEN_PROGRAM_ID);
            neededLutAccounts.push(constants_js_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);
            neededLutAccounts.push(state_js_1.State.keyFromSeed(this.program));
            for (const oracle of oracles) {
                for (const feed of feeds) {
                    const [statsKey] = anchor_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from("OracleFeedStats"), feed.toBuffer(), oracle.toBuffer()], this.program.programId);
                    const feedRewardEscrow = yield spl.getAssociatedTokenAddress(constants_js_1.SOL_NATIVE_MINT, feed);
                    neededLutAccounts.push(statsKey);
                    neededLutAccounts.push(feed);
                    neededLutAccounts.push(oracle);
                    neededLutAccounts.push(feedRewardEscrow);
                }
            }
            // TODO: do anneal here
        });
    }
}
exports.LutMap = LutMap;
//# sourceMappingURL=lutMap.js.map