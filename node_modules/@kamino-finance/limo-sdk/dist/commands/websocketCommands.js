"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listenToOrderChanges = listenToOrderChanges;
exports.listenToOrderFillChangesForQuoteAndBase = listenToOrderFillChangesForQuoteAndBase;
exports.listenToOrderChangesForQuoteAndBase = listenToOrderChangesForQuoteAndBase;
exports.listenToOrderChangesForMaker = listenToOrderChangesForMaker;
const web3_js_1 = require("@solana/web3.js");
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const Limo_1 = require("../Limo");
async function listenToOrderChanges() {
    const admin = process.env.ADMIN;
    const rpc = process.env.RPC_ENV;
    const globalConfig = process.env.LIMO_GLOBAL_CONFIG;
    const env = (0, utils_1.initializeClient)(rpc, admin, (0, utils_2.getLimoProgramId)(rpc), false);
    const client = new Limo_1.LimoClient(env.provider.connection, new web3_js_1.PublicKey(globalConfig));
    const ordersUpdated = new utils_2.PubkeyHashMap();
    const callbackOnChange = async (orderStateAndAddress, slot) => {
        console.log("Order updated", orderStateAndAddress, slot);
        ordersUpdated.set(orderStateAndAddress.address, orderStateAndAddress.state);
    };
    const subscriptionId = client.listenToOrdersChangeWithFilters([], callbackOnChange);
    while (ordersUpdated.size < 10) {
        await (0, utils_2.sleep)(2000);
        console.log("Orders updated size", ordersUpdated.size);
    }
    client.stopListeningToOrdersChange(subscriptionId);
}
async function listenToOrderFillChangesForQuoteAndBase(quote, base) {
    const admin = process.env.ADMIN;
    const rpc = process.env.RPC_ENV;
    const globalConfig = process.env.LIMO_GLOBAL_CONFIG;
    const env = (0, utils_1.initializeClient)(rpc, admin, (0, utils_2.getLimoProgramId)(rpc), false);
    const client = new Limo_1.LimoClient(env.provider.connection, new web3_js_1.PublicKey(globalConfig));
    // const latestFilledOrders = new PubkeyHashMap<PublicKey, Order>();
    const mintDecimals = await client.getMintDecimals([quote, base]);
    const { filledOrdersBuy, filledOrdersSell } = await client.getLatestFilledOrders(base, quote, mintDecimals);
    const latestTenFilledBuyOrders = new utils_2.FilledOrderQueue(10, filledOrdersBuy);
    const latestTenFilledSellOrders = new utils_2.FilledOrderQueue(10, filledOrdersSell);
    let ordersUpdated = 0;
    const callbackOnChangeBuyOrder = async (orderStateAndAddress, slot) => {
        console.log("Buy Order updated", orderStateAndAddress, slot);
        const order = client.toOrdersDisplay([orderStateAndAddress], mintDecimals)[0];
        ordersUpdated += 1;
        latestTenFilledBuyOrders.push({
            address: order.address,
            orderDisplay: order,
            quoteTokenMint: quote,
            baseTokenMint: base,
            time: order.state.lastUpdatedTimestamp.toNumber(),
            price: order.executionPriceInputToOutput,
            size: order.filledOutputAmountDecimal,
            txid: "N/A",
            type: "buy",
        });
    };
    const callbackOnChangeSellOrder = async (orderStateAndAddress, slot) => {
        console.log("Sell Order updated", orderStateAndAddress, slot);
        const order = client.toOrdersDisplay([orderStateAndAddress], mintDecimals)[0];
        ordersUpdated += 1;
        latestTenFilledSellOrders.push({
            address: orderStateAndAddress.address,
            orderDisplay: order,
            quoteTokenMint: quote,
            baseTokenMint: base,
            time: orderStateAndAddress.state.lastUpdatedTimestamp.toNumber(),
            price: order.executionPriceOutputToInput,
            size: order.filledOutputAmountDecimal,
            txid: "N/A",
            type: "sell",
        });
    };
    const { subscriptionIdBuyOrders, subscriptionIdSellOrders } = client.listenToOrderFillChangeForBaseAndQuote(base, quote, callbackOnChangeSellOrder, callbackOnChangeBuyOrder);
    while (ordersUpdated < 10) {
        await (0, utils_2.sleep)(10000);
        console.log("Number of orders updated", ordersUpdated);
    }
    client.stopListeningToOrdersChange(subscriptionIdBuyOrders);
    client.stopListeningToOrdersChange(subscriptionIdSellOrders);
}
async function listenToOrderChangesForQuoteAndBase(quote, base) {
    const admin = process.env.ADMIN;
    const rpc = process.env.RPC_ENV;
    const globalConfig = process.env.LIMO_GLOBAL_CONFIG;
    const env = (0, utils_1.initializeClient)(rpc, admin, (0, utils_2.getLimoProgramId)(rpc), false);
    const client = new Limo_1.LimoClient(env.provider.connection, new web3_js_1.PublicKey(globalConfig));
    const mintDecimals = await client.getMintDecimals([quote, base]);
    const { bidOrders: ordersBuy, askOrders: ordersSell } = await client.getOrdersDisplayForBaseAndQuote(base, quote, mintDecimals);
    const buyOrders = new utils_2.PubkeyHashMap();
    const sellOrders = new utils_2.PubkeyHashMap();
    ordersBuy.forEach((order) => {
        buyOrders.set(order.address, order);
    });
    ordersSell.forEach((order) => {
        sellOrders.set(order.address, order);
    });
    let ordersUpdated = 0;
    const callbackOnChangeBuyOrder = async (orderStateAndAddress, slot) => {
        console.log("Buy Order updated", orderStateAndAddress, slot);
        const order = client.toOrdersDisplay([orderStateAndAddress], mintDecimals)[0];
        ordersUpdated += 1;
        ordersBuy.push(order);
    };
    const callbackOnChangeSellOrder = async (orderStateAndAddress, slot) => {
        console.log("Sell Order updated", orderStateAndAddress, slot);
        const order = client.toOrdersDisplay([orderStateAndAddress], mintDecimals)[0];
        ordersUpdated += 1;
        ordersSell.push(order);
    };
    const { subscriptionIdBuyOrders, subscriptionIdSellOrders } = client.listenToOrderChangeForBaseAndQuote(base, quote, callbackOnChangeSellOrder, callbackOnChangeBuyOrder);
    while (ordersUpdated < 10) {
        await (0, utils_2.sleep)(10000);
        console.log("Number of orders updated", ordersUpdated);
    }
    client.stopListeningToOrdersChange(subscriptionIdBuyOrders);
    client.stopListeningToOrdersChange(subscriptionIdSellOrders);
}
async function listenToOrderChangesForMaker(maker) {
    const admin = process.env.ADMIN;
    const rpc = process.env.RPC_ENV;
    const globalConfig = process.env.LIMO_GLOBAL_CONFIG;
    const env = (0, utils_1.initializeClient)(rpc, admin, (0, utils_2.getLimoProgramId)(rpc), false);
    const client = new Limo_1.LimoClient(env.provider.connection, new web3_js_1.PublicKey(globalConfig));
    const mintDecimals = await client.getAllMintDecimals();
    let ordersUpdated = 0;
    const existingOrders = await client.getAllOrdersDisplayForMaker(maker, mintDecimals);
    const makerOrders = new utils_2.PubkeyHashMap();
    existingOrders.forEach((order) => {
        makerOrders.set(order.address, order);
    });
    const callbackOnChange = async (orderStateAndAddress, slot) => {
        console.log("Order updated", orderStateAndAddress, slot);
        ordersUpdated += 1;
        const orderDisplay = client.toOrdersDisplay([orderStateAndAddress], mintDecimals)[0];
        makerOrders.set(orderStateAndAddress.address, orderDisplay);
    };
    const subscriptionId = client.listenToMakerOrders(maker, callbackOnChange);
    while (ordersUpdated < 10) {
        await (0, utils_2.sleep)(2000);
        console.log("Number of Orders updated", ordersUpdated);
    }
    client.stopListeningToOrdersChange(subscriptionId);
}
//# sourceMappingURL=websocketCommands.js.map