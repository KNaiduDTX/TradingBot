import { Idl, Program } from "@coral-xyz/anchor";
import BN from "bn.js";
import { Connection, GetProgramAccountsFilter, PublicKey, Signer, TransactionInstruction, TransactionSignature } from "@solana/web3.js";
import { OrderStateAndAddress, OrderDisplay, PubkeyHashMap, FilledOrder, FlashTakeOrderIxs, OrderListenerCallbackOnChange } from "./utils";
import { Keypair } from "@solana/web3.js";
import { GlobalConfig } from "./rpc_client/accounts/GlobalConfig";
import Decimal from "decimal.js";
import { Order } from "./rpc_client/accounts/Order";
export declare const limoId: PublicKey;
export declare const WRAPPED_SOL_MINT: PublicKey;
export declare const ORDER_RENT_EXEMPTION_LAMPORTS = 3841920;
export declare const MAX_CLOSE_ORDER_AND_CLAIM_TIP_ORDERS_IN_TX = 14;
export declare class LimoClient {
    private readonly _connection;
    private readonly _provider;
    private readonly _limoProgram;
    private readonly programId;
    private globalConfigState;
    private _globalConfig;
    constructor(connection: Connection, globalConfig: PublicKey | undefined, globalConfigState?: GlobalConfig);
    getConnection(): Connection;
    getProgramID(): PublicKey;
    getProgram(): Program<Idl>;
    /**
     * Sets the global config address
     * @param globalConfig - the global config address
     */
    setGlobalConfig(globalConfig: PublicKey): void;
    /**
     * Refresh and get the global config state
     * @returns the global config state
     * @throws error if global config not set
     */
    refreshGlobalConfigState(): Promise<GlobalConfig>;
    /**
     * Get the global config state
     * @returns the global config state
     * @throws error if global config not set
     */
    getGlobalConfigState(): Promise<GlobalConfig>;
    /**
     * Get the global config state synchronously
     * @returns the global config state
     * @throws error if global config not set
     * @throws error if global config state not fetched yet
     */
    getGlobalConfigStateSync(): GlobalConfig;
    /**
     * Get the given order state
     * @param orderAddress - the order address
     * @returns the order state
     */
    getOrderState(orderAddress: PublicKey): Promise<Order>;
    /**
     * Gets all orders with given filters
     * @param filters - list of filters to apply to the get program accounts
     * @param globalConfigOverride - global config override to filter by
     * @param filterByGlobalConfig - whether to filter by global config or not
     * @returns list of order states and addresses
     */
    getAllOrdersStateAndAddressWithFilters(filters: GetProgramAccountsFilter[], globalConfigOverride?: PublicKey, filterByGlobalConfig?: boolean): Promise<OrderStateAndAddress[]>;
    /**
     * Gets all orders for global config
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     */
    getAllOrdersStateAndAddressForGlobalConfig(globalConfigOverride?: PublicKey): Promise<OrderStateAndAddress[]>;
    /**
     * Gets all orders for global config and returns them as OrderDisplay
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     * @throws error if mint decimals not found for mint
     */
    getAllOrdersDisplayForGlobalConfig(mintDecimals: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<OrderDisplay[]>;
    /**
     * Gets all orders for a specific maker
     * @param maker - maker address
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     * @throws error if mint decimals not found for mint
     */
    getAllOrdersStateAndAddressForMaker(maker: PublicKey, globalConfigOverride?: PublicKey): Promise<OrderStateAndAddress[]>;
    /**
     * Gets all orders for a specific maker and returns them as OrderDisplay
     * @param maker - maker address
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     * @throws error if mint decimals not found for mint
     */
    getAllOrdersDisplayForMaker(maker: PublicKey, mintDecimals?: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<OrderDisplay[]>;
    /**
     * Gets all orders for a specific input mint
     * @param inputMint - input mint address
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     */
    getAllOrdersStateAndAddressForInputMint(inputMint: PublicKey, globalConfigOverride?: PublicKey): Promise<OrderStateAndAddress[]>;
    /**
     * Gets all orders for a specific input mint and returns them as OrderDisplay
     * @param inputMint - input mint address
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     */
    getAllOrdersDisplayForInputMint(inputMint: PublicKey, mintDecimals: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<OrderDisplay[]>;
    /**
     * Gets all orders for a specific output mint
     * @param outputMint - output mint address
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     */
    getAllOrdersStateAndAddressForOutputMint(outputMint: PublicKey, globalConfigOverride?: PublicKey): Promise<OrderStateAndAddress[]>;
    /**
     * Gets all orders for a specific output mint and returns them as OrderDisplay
     * @param outputMint - output mint address
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     */
    getAllOrdersDisplayForOutputMint(outputMint: PublicKey, mintDecimals: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<OrderDisplay[]>;
    /**
     * Gets all orders for a specific input and output mint
     * @param inputMint - input mint address
     * @param outputMint - output mint address
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     */
    getAllOrdersDisplayForInputAndOutputMints(inputMint: PublicKey, outputMint: PublicKey, mintDecimals?: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<OrderDisplay[]>;
    /**
     * Gets all orders for a specific maker, input and output mint
     * @param maker - maker address
     * @param inputMint - input mint address
     * @param outputMint - output mint address
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     * @throws error if mint decimals not found for mint
     */
    getAllOrdersDisplayForMakerInputAndOutputMints(maker: PublicKey, inputMint: PublicKey, outputMint: PublicKey, mintDecimals?: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<OrderDisplay[]>;
    getOrderDisplay(orderAddress: PublicKey): Promise<OrderDisplay>;
    /**
     * Converts order states and addresses to order displays
     * @param orders - list of order states and addresses
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @returns list of order displays
     * @throws error if mint decimals not found for mint
     */
    toOrdersDisplay(orders: OrderStateAndAddress[], mintDecimals: PubkeyHashMap<PublicKey, number>): OrderDisplay[];
    /**
     * Returns the ask and bid OrderDisplay arrays for a given base and quote token mint
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns { askOrders: OrderDisplay[], bidOrders: OrderDisplay[] } - the ask and bid orders
     * @throws error if mint decimals not found for mint
     * @throws error if global config not set
     */
    getOrdersDisplayForBaseAndQuote(baseTokenMint: PublicKey, quoteTokenMint: PublicKey, mintDecimals: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<{
        askOrders: OrderDisplay[];
        bidOrders: OrderDisplay[];
    }>;
    /**
     * Returns the ask and bid OrderDisplay arrays for a given base and quote token mint and maker
     * @param maker - the maker address
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns { askOrders: OrderDisplay[], bidOrders: OrderDisplay[] } - the ask and bid orders
     * @throws error if mint decimals not found for mint
     * @throws error if global config not set
     */
    getOrdersDisplayForBaseAndQuoteAndMaker(maker: PublicKey, baseTokenMint: PublicKey, quoteTokenMint: PublicKey, mintDecimals: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<{
        askOrders: OrderDisplay[];
        bidOrders: OrderDisplay[];
    }>;
    /**
     * Returns the sell and buy FilledOrder arrays for a given base and quote token
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns { filledOrdersSell: FilledOrder[], filledOrdersBuy: FilledOrder[] } - the sell and buy filled orders
     * @throws error if mint decimals not found for mint
     * @throws error if global config not set
     */
    getLatestFilledOrders(baseTokenMint: PublicKey, quoteTokenMint: PublicKey, mintDecimals: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<{
        filledOrdersBuy: FilledOrder[];
        filledOrdersSell: FilledOrder[];
    }>;
    /**
     * Starts listening to order changes for a specific maker
     * @param maker - the maker address
     * @param callbackOnChange - callback to be called when an order changes
     * @returns subscriptionId - a number of the subscription id, to be used to stop the listener
     */
    listenToMakerOrders(maker: PublicKey, callbackOnChange: OrderListenerCallbackOnChange): number;
    /**
     * Starts listening to order changes with 2 separate listeners, one for sell orders and one for buy orders
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param callbackOnChangeSellOrders - callback to be called when a sell order changes
     * @param callbackOnChangeBuyOrders - callback to be called when a buy order changes
     * @returns { subscriptionIdSellOrders, subscriptionIdBuyOrders } - the subscription id for the two listeners (both should be closed when subscription no longer needed)
     */
    listenToOrderChangeForBaseAndQuote(baseTokenMint: PublicKey, quoteTokenMint: PublicKey, callbackOnChangeSellOrders: OrderListenerCallbackOnChange, callbackOnChangeBuyOrders: OrderListenerCallbackOnChange): {
        subscriptionIdSellOrders: number;
        subscriptionIdBuyOrders: number;
    };
    /**
     * Starts listening to order changes with 2 separate listeners, one for sell orders and one for buy orders - filter for only filled orders
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param callbackOnChangeSellOrders - callback to be called when a sell order changes
     * @param callbackOnChangeBuyOrders - callback to be called when a buy order changes
     * @returns { subscriptionIdSellOrders, subscriptionIdBuyOrders } - the subscription id for the two listeners (both should be closed when subscription no longer needed)
     */
    listenToOrderFillChangeForBaseAndQuote(baseTokenMint: PublicKey, quoteTokenMint: PublicKey, callbackOnChangeSellOrders: OrderListenerCallbackOnChange, callbackOnChangeBuyOrders: OrderListenerCallbackOnChange): {
        subscriptionIdSellOrders: number;
        subscriptionIdBuyOrders: number;
    };
    /**
     * Starts listening to order changes based on the filters provided, for the global config
     * @param filters - list of filters to apply to the get program accounts
     * @param callbackOnChange - callback to be called when an order changes
     * @returns subscriptionId - a number of the subscription id, to be used to stop the listener
     */
    listenToOrdersChangeWithFilters(filters: GetProgramAccountsFilter[], callbackOnChange: OrderListenerCallbackOnChange): number;
    /**
     * Stops listening to order changes based on the subscription id
     * @param subscriptionId - the subscription id to stop listening to
     */
    stopListeningToOrdersChange(subscriptionId: number): void;
    /**
     * Get the create global config instruction
     * @param admin - the admin address
     * @param globalConfig - the global config keypair
     * @returns the create global config instruction
     */
    createGlobalConfigIxs(admin: PublicKey, globalConfig: Keypair): Promise<TransactionInstruction[]>;
    /**
     * Create the global config
     * @param admin - the admin keypair
     * @param globalConfig - the global config keypair
     * @returns the transaction signature
     */
    createGlobalConfig(admin: Keypair, globalConfig: Keypair): Promise<TransactionSignature>;
    /**
     * Get the create initialize vault instruction
     * @param user - the user address
     * @param mint - the mint address
     * @param mintTokenProgramId - the mint token program id
     * @param globalConfigOverride - the global config override
     * @returns the create initialize vault instruction
     */
    initializeVaultIx(user: PublicKey, mint: PublicKey, mintTokenProgramId?: PublicKey): Promise<TransactionInstruction>;
    /**
     * Initialize the vault
     * @param user - the user keypair
     * @param mint - the mint address
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintTokenProgramId - the mint token program id
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature
     */
    initializeVault(user: Keypair, mint: PublicKey, mode?: string, mintTokenProgramId?: PublicKey): Promise<TransactionSignature>;
    /**
     * Get the create initialize order instruction
     * @param user - the user address
     * @param inputMint - the input mint address
     * @param outputMint - the output mint address
     * @param inputAmountLamports - the input amount in lamports
     * @param outputAmountLamports - the output amount in lamports
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the create initialize order instruction and keypair to sign the transaction with
     * @throws error if mint decimals not found for mint
     */
    createOrderGenericIx(user: PublicKey, inputMint: PublicKey, outputMint: PublicKey, inputAmountLamports: BN, outputAmountLamports: BN, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, globalConfigOverride?: PublicKey, wrapUnwrapSol?: boolean, withInitVault?: boolean): Promise<[TransactionInstruction[], Keypair]>;
    /**
     * Create an order
     * @param user - the user keypair
     * @param inputMint - the input mint address
     * @param outputMint - the output mint address
     * @param inputAmountLamports - the input amount in lamports
     * @param outputAmountLamports - the output amount in lamports
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature and the order keypair
     */
    createOrderGeneric(user: Keypair, inputMint: PublicKey, outputMint: PublicKey, inputAmountLamports: BN, outputAmountLamports: BN, mode: string | undefined, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, globalConfigOverride?: PublicKey): Promise<[TransactionSignature, Keypair]>;
    /**
     * Place a bid order instruction
     * @param user - the user address
     * @param quoteTokenMint - the quote token mint address
     * @param baseTokenMint - the base token mint address
     * @param baseUiAmount - the base amount in UI
     * @param price - the price
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the create order instruction and keypair to sign the transaction with
     */
    placeBidIxs(user: PublicKey, quoteTokenMint: PublicKey, baseTokenMint: PublicKey, baseUiAmount: Decimal, price: Decimal, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, mintDecimals?: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<[TransactionInstruction[], Keypair]>;
    /**
     * Place a bid order
     * @param user - the user keypair
     * @param quoteTokenMint - the quote token mint address
     * @param baseTokenMint - the base token mint address
     * @param baseUiAmount - the base amount in UI
     * @param price - the price
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature and the order keypair
     */
    placeBid(user: Keypair, quoteTokenMint: PublicKey, baseTokenMint: PublicKey, baseUiAmount: Decimal, price: Decimal, mode: string | undefined, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, mintDecimals?: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<[TransactionSignature, Keypair]>;
    /**
     * Place an ask order instruction
     * @param user - the user address
     * @param quoteTokenMint - the quote token mint address
     * @param baseTokenMint - the base token mint address
     * @param quoteUiAmount - the quote amount in UI
     * @param price - the price
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the create order instruction and keypair to sign the transaction with
     */
    placeAskIxs(user: PublicKey, quoteTokenMint: PublicKey, baseTokenMint: PublicKey, quoteUiAmount: Decimal, price: Decimal, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, mintDecimals?: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<[TransactionInstruction[], Keypair]>;
    /**
     * Place an ask order
     * @param user - the user keypair
     * @param quoteTokenMint - the quote token mint address
     * @param baseTokenMint - the base token mint address
     * @param quoteUiAmount - the quote amount in UI
     * @param price - the price
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature and the order keypair
     */
    placeAsk(user: Keypair, quoteTokenMint: PublicKey, baseTokenMint: PublicKey, quoteUiAmount: Decimal, price: Decimal, mode: string | undefined, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, mintDecimals?: PubkeyHashMap<PublicKey, number>, globalConfigOverride?: PublicKey): Promise<[TransactionSignature, Keypair]>;
    /**
     * Get the create take order instruction
     * @param taker - the taker address
     * @param order - the order state and address
     * @param inputAmountDecimals - the input amount in decimals
     * @param minOutputAmountDecimals - the minimum output amount in decimals
     * @param expressRelayProgramId - the express relay program id
     * @param inputMintDecimals - the input mint decimals
     * @param outputMintDecimals - the output mint decimals
     * @returns the create take order instruction
     */
    takeOrderIx(taker: PublicKey, order: OrderStateAndAddress, inputAmountLamports: BN, minOutputAmountLamports: BN, expressRelayProgramId: PublicKey, permissionlessTipLamports?: BN, permissionless?: boolean, wrapUnwrapSol?: boolean): TransactionInstruction[];
    /**
     * Take an order
     * @param crank - the crank keypair
     * @param order - the order state and address
     * @param inputAmountDecimals - the input amount in decimals
     * @param outputAmountDecimals - the output amount in decimals
     * @param expressRelayProgramId - the express relay program id
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @returns the transaction signature
     */
    permissionlessTakeOrder(crank: Keypair, order: OrderStateAndAddress, inputAmountLamports: BN, outputAmountLamports: BN, expressRelayProgramId: PublicKey, mode: string, permissionlessTipLamports: BN, mintDecimals?: PubkeyHashMap<PublicKey, number>): Promise<TransactionSignature>;
    /**
     * Get the create flash take order instruction
     * @param taker - the taker address
     * @param order - the order state and address
     * @param inputAmountDecimal - the input amount in decimals
     * @param minOutputAmountDecimal - the minimum output amount in decimals
     * @param expressRelayProgramId - the express relay program id
     * @param inputMintDecimals - the input mint decimals
     * @param outputMintDecimals - the output mint decimals
     * @param permissionlessTipLamports - the tip in lamports for permissionless flash_take_order
     * @param permissionless - whether the flash take order should be a permissionless call
     * @returns the create flash take order instruction - in between the start and
     * end flash take order instructions, the swap and permissioning logic should exist
     */
    flashTakeOrderIxs(taker: PublicKey, order: OrderStateAndAddress, inputAmountLamports: BN, minOutputAmountLamports: BN, expressRelayProgramId: PublicKey, permissionlessTipLamports?: BN, permissionless?: boolean, wrapUnwrapSol?: boolean): FlashTakeOrderIxs;
    /**
     * Flash take an order
     * @param crank - the crank keypair
     * @param order - the order state and address
     * @param inputAmountDecimals - the input amount in decimals
     * @param outputAmountDecimals - the output amount in decimals
     * @param expressRelayProgramId - the express relay program id
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @returns the transaction signature
     */
    permissionlessFlashTakeOrder(crank: Keypair, order: OrderStateAndAddress, inputAmountLamports: BN, outputAmountLamports: BN, expressRelayProgramId: PublicKey, mode: string, swapIxs: TransactionInstruction[], permissionlessTipLamports: BN, extraSigners: Keypair[], mintDecimals?: PubkeyHashMap<PublicKey, number>): Promise<TransactionSignature>;
    /**
     * Get the create close order instruction
     * @param user - the user address
     * @param inputMont - the inputMint for the swap
     * @param outputMint - the outputMint for the swap
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @returns the log ixs - to be used once at the beginning and once at the end
     */
    logUserSwapBalancesIxs(user: PublicKey, inputMint: PublicKey, outputMint: PublicKey, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, swapProgarmId?: PublicKey, pdaReferrer?: PublicKey): {
        beforeSwapIx: TransactionInstruction;
        afterSwapIx: TransactionInstruction;
    };
    /**
     * Get the create close order instruction
     * @param user - the user address
     * @param inputMont - the inputMint for the swap
     * @param outputMint - the outputMint for the swap
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @returns the log ixs - to be used once at the beginning and once at the end
     */
    logUserSwapBalances(user: Keypair, inputMint: PublicKey, outputMint: PublicKey, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, setupIxs?: TransactionInstruction[], mockSwapIxs?: TransactionInstruction[], mockSwapSigners?: Keypair[]): Promise<TransactionSignature>;
    /**
     * Get the total tips for all filled orders from the given orders array
     * @param orders - the list of orders to filter by filled and calculate the total tips
     * @returns the decimal amount of native sol tips
     */
    getTotalTipsForFilledOrdersDecimal(orders: OrderDisplay[]): Decimal;
    /**
     * Get the all instructions to close and claim tips for all filled orders from the given orders array
     * @param maker - the maker address to close and claim tips for
     * @param orders - the list of orders to filter by filled and calculate the total tips
     * @returns an array of arrays of instructions to close and claim tips for all filled orders -
     * this should be used as multiple transactions
     */
    getCloseAndClaimTipsForFilledOrdersTxsIxs(maker: PublicKey, orders: OrderDisplay[], batchSize?: number): TransactionInstruction[][];
    /**
     * Get the create close order and claim tip instruction
     * @param maker - the maker address
     * @param order - the order state and address
     * @returns the create close order and claim tip instruction
     */
    closeOrderAndClaimTipIx(maker: PublicKey, order: OrderStateAndAddress, wrapUnwrapSol?: boolean): TransactionInstruction[];
    /**
     * Close an order and claim tip
     * @param maker - the maker keypair
     * @param order - the order state and address
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @returns the transaction signature
     */
    closeOrderAndClaimTip(maker: Keypair, order: OrderStateAndAddress, mode: string, mintDecimals?: PubkeyHashMap<PublicKey, number>): Promise<TransactionSignature>;
    /**
     * Get the update order instructions - close current order and initialize new order
     * @param order - the order state to close
     * @param user - the user address
     * @param inputMint - the input mint address
     * @param outputMint - the output mint address
     * @param inputAmountLamports - the input amount in lamports
     * @param outputAmountLamports - the output amount in lamports
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the create initialize order instruction and keypair to sign the transaction with
     * @throws error if mint decimals not found for mint
     */
    updateOrderGenericIx(order: OrderStateAndAddress, user: PublicKey, inputMint: PublicKey, outputMint: PublicKey, inputAmountLamports: BN, outputAmountLamports: BN, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, globalConfigOverride?: PublicKey, wrapUnwrapSol?: boolean): Promise<[TransactionInstruction[], Keypair]>;
    /**
     * Get the update order instructions - close current order and initialize new order
     * @param order - the order state to close
     * @param user - the user keypair
     * @param inputMint - the input mint address
     * @param outputMint - the output mint address
     * @param inputAmountLamports - the input amount in lamports
     * @param outputAmountLamports - the output amount in lamports
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param globalConfigOverride - the global config override
     * @returns the create initialize order instruction and keypair to sign the transaction with
     * @throws error if mint decimals not found for mint
     */
    updateOrderGeneric(order: OrderStateAndAddress, user: Keypair, inputMint: PublicKey, outputMint: PublicKey, inputAmountLamports: BN, outputAmountLamports: BN, inputMintProgramId: PublicKey, outputMintProgramId: PublicKey, mode?: string, globalConfigOverride?: PublicKey, wrapUnwrapSol?: boolean): Promise<[string, Keypair]>;
    /**
     * Get the update global config instruction
     * @param admin - the admin address
     * @param mode - the mode to update
     * @param value - the value
     * @param globalConfigOverride - the global config override
     * @returns the update global config instruction
     */
    updateGlobalConfigIx(mode: string, value: number | PublicKey, globalConfigOverride?: PublicKey): TransactionInstruction[];
    /**
     * Update the global config
     * @param admin - the admin keypair
     * @param updateMode - the update mode
     * @param value - the value
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature
     */
    updateGlobalConfig(admin: Keypair, updateMode: string, value: number | PublicKey, mode: string, globalConfigOverride?: PublicKey): Promise<TransactionSignature>;
    /**
     * Get the update global config admin instruction - should be signed by the current globalConfig.adminAuthorityCached
     * @param globalConfigOverride - the global config override
     * @returns the update global config admin instruction
     */
    updateGlobalConfigAdminIx(globalConfigOverride?: PublicKey): Promise<TransactionInstruction>;
    /**
     * Update the global config admin
     * @param admin - the admin keypair, should match the current globalConfig.adminAuthorityCached
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature
     */
    updateGlobalConfigAdmin(admin: Keypair, mode: string, globalConfigOverride?: PublicKey): Promise<TransactionSignature>;
    /**
     * Get the withdraw host tip instruction
     * @param admin - the admin address
     * @param globalConfigOverride - the global config override
     * @returns the withdraw host tip instruction
     */
    withdrawHostTipIx(admin: PublicKey, globalConfigOverride?: PublicKey): TransactionInstruction[];
    /**
     * Withdraw the host tip
     * @param admin - the admin keypair
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature
     */
    withdrawHostTip(admin: Keypair, mode: string, globalConfigOverride?: PublicKey): Promise<TransactionInstruction[]>;
    /**
     * Get the number of decimals for the order input mint
     * @param order - the order state and address
     * @returns the number of decimals
     */
    getOrderInputMintDecimals(order: OrderStateAndAddress): Promise<number>;
    /**
     * Get the number of decimals for the order output mint
     * @param order - the order state and address
     * @returns the number of decimals
     */
    getOrderOutputMintDecimals(order: OrderStateAndAddress): Promise<number>;
    /**
     * Get the number of decimals for given mints array
     * @param mints - an array of mints
     * @returns a PubkeyHashMap of the mints and number of decimals
     */
    getMintDecimals(mints: PublicKey[]): Promise<PubkeyHashMap<PublicKey, number>>;
    /**
     * Get the number of decimals for all mints in all of the order states
     * @returns a PubkeyHashMap of the mints and number of decimals
     */
    getAllMintDecimals(): Promise<PubkeyHashMap<PublicKey, number>>;
    getMintsProgramOwners(mints: PublicKey[]): Promise<PublicKey[]>;
    /**
     * Execute a transaction
     * @param ix - the transaction instructions
     * @param signer - the signer keypair
     * @param extraSigners - the extra signers
     * @returns the transaction signature
     */
    executeTransaction(ix: TransactionInstruction[], signer: Keypair, extraSigners?: Signer[]): Promise<TransactionSignature>;
    /**
     * Process a transaction based on the execution mode
     * @param admin - the admin keypair
     * @param ixs - the transaction instructions
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param debugMessage - the debug message
     * @param extraSigners - the extra signers
     * @param computeUnits - the number of compute units
     * @param priorityFeeLamports - the priority fee in lamports
     * @returns the transaction signature
     */
    processTxn(admin: Keypair, ixs: TransactionInstruction[], mode: string, debugMessage?: string, extraSigners?: Signer[], computeUnits?: number, priorityFeeLamports?: number): Promise<TransactionSignature>;
    /**
     * Get the wsol create fill and close ixs for a given owner and payer
     * @param owner - the owner address
     * @param payer - the payer address
     * @param amountToDepositLamports - the amount to deposit in lamports
     * @returns the create, fill, and close instructions, toghether with the ata
     */
    getInitIfNeededWSOLCreateAndCloseIxs(owner: PublicKey, payer: PublicKey, amountToDepositLamports?: BN): {
        createIxs: TransactionInstruction[];
        fillIxs: TransactionInstruction[];
        closeIx: TransactionInstruction[];
        ata: PublicKey;
    };
    /**
     * Get the deposit WSOL instructions
     * @param owner - the owner address
     * @param ata - the ata address
     * @param amountLamports - the amount in lamports
     * @returns the transaction instructions
     */
    getDepositWsolIxns(owner: PublicKey, ata: PublicKey, amountLamports: BN): TransactionInstruction[];
}
//# sourceMappingURL=Limo.d.ts.map