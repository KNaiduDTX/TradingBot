"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimoClient = exports.MAX_CLOSE_ORDER_AND_CLAIM_TIP_ORDERS_IN_TX = exports.ORDER_RENT_EXEMPTION_LAMPORTS = exports.WRAPPED_SOL_MINT = exports.limoId = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const limo_json_1 = __importDefault(require("./rpc_client/limo.json"));
const bn_js_1 = __importDefault(require("bn.js"));
const web3_js_1 = require("@solana/web3.js");
const utils_1 = require("./utils");
const limoOperations = __importStar(require("./utils/operations"));
const web3_js_2 = require("@solana/web3.js");
const GlobalConfig_1 = require("./rpc_client/accounts/GlobalConfig");
const decimal_js_1 = __importDefault(require("decimal.js"));
const Order_1 = require("./rpc_client/accounts/Order");
const types_1 = require("./rpc_client/types");
const spl_token_1 = require("@solana/spl-token");
const spl_token_2 = require("@solana/spl-token");
const bs58_1 = __importDefault(require("bs58"));
const instructions_1 = require("./rpc_client/instructions");
const instructions_2 = require("./rpc_client/instructions");
exports.limoId = new web3_js_1.PublicKey("LiMoM9rMhrdYrfzUCxQppvxCSG1FcrUK9G8uLq4A1GF");
exports.WRAPPED_SOL_MINT = new web3_js_1.PublicKey("So11111111111111111111111111111111111111112");
exports.ORDER_RENT_EXEMPTION_LAMPORTS = 3841920;
exports.MAX_CLOSE_ORDER_AND_CLAIM_TIP_ORDERS_IN_TX = 14;
class LimoClient {
    _connection;
    _provider;
    _limoProgram;
    programId;
    globalConfigState;
    _globalConfig;
    constructor(connection, globalConfig, globalConfigState) {
        this._connection = connection;
        this._globalConfig = globalConfig ?? web3_js_1.PublicKey.default;
        this._provider = new anchor_1.AnchorProvider(connection, (0, utils_1.getReadOnlyWallet)(), {
            commitment: connection.commitment,
        });
        this.programId = exports.limoId;
        this._limoProgram = new anchor_1.Program(limo_json_1.default, this.programId, this._provider);
        this.globalConfigState = globalConfigState;
    }
    getConnection() {
        return this._connection;
    }
    getProgramID() {
        return this.programId;
    }
    getProgram() {
        return this._limoProgram;
    }
    /**
     * Sets the global config address
     * @param globalConfig - the global config address
     */
    setGlobalConfig(globalConfig) {
        this._globalConfig = globalConfig;
    }
    /**
     * Refresh and get the global config state
     * @returns the global config state
     * @throws error if global config not set
     */
    async refreshGlobalConfigState() {
        if (!this._globalConfig) {
            throw new Error("Global Config not set");
        }
        const globalConfigState = await GlobalConfig_1.GlobalConfig.fetch(this._connection, this._globalConfig);
        if (!globalConfigState) {
            throw new Error("Global Config not found");
        }
        this.globalConfigState = globalConfigState;
        return this.globalConfigState;
    }
    /**
     * Get the global config state
     * @returns the global config state
     * @throws error if global config not set
     */
    async getGlobalConfigState() {
        if (!this._globalConfig) {
            throw new Error("Global Config not set");
        }
        if (!this.globalConfigState) {
            const globalConfigState = await GlobalConfig_1.GlobalConfig.fetch(this._connection, this._globalConfig);
            if (!globalConfigState) {
                throw new Error("Global Config not found");
            }
            this.globalConfigState = globalConfigState;
        }
        return this.globalConfigState;
    }
    /**
     * Get the global config state synchronously
     * @returns the global config state
     * @throws error if global config not set
     * @throws error if global config state not fetched yet
     */
    getGlobalConfigStateSync() {
        if (!this._globalConfig) {
            throw new Error("Global Config not set");
        }
        if (!this.globalConfigState) {
            throw new Error("Global Config state not fetched yet, use getGlobalConfigState");
        }
        return this.globalConfigState;
    }
    /**
     * Get the given order state
     * @param orderAddress - the order address
     * @returns the order state
     */
    async getOrderState(orderAddress) {
        const order = await Order_1.Order.fetch(this._connection, orderAddress, this.programId);
        if (!order) {
            throw new Error("Order not found");
        }
        return order;
    }
    /**
     * Gets all orders with given filters
     * @param filters - list of filters to apply to the get program accounts
     * @param globalConfigOverride - global config override to filter by
     * @param filterByGlobalConfig - whether to filter by global config or not
     * @returns list of order states and addresses
     */
    async getAllOrdersStateAndAddressWithFilters(filters, globalConfigOverride, filterByGlobalConfig = true) {
        if (filterByGlobalConfig) {
            filters.push({
                memcmp: {
                    bytes: globalConfigOverride
                        ? globalConfigOverride.toBase58()
                        : this._globalConfig.toBase58(),
                    offset: 8,
                },
            });
        }
        filters.push({
            dataSize: Order_1.Order.layout.span + 8,
        });
        const orderProgramAccounts = await this._connection.getProgramAccounts(this.programId, {
            filters,
        });
        return orderProgramAccounts.map((orderProgramAccount) => {
            if (orderProgramAccount.account === null) {
                throw new Error("Invalid account");
            }
            if (!orderProgramAccount.account.owner.equals(this.programId)) {
                throw new Error("account doesn't belong to this program");
            }
            const order = Order_1.Order.decode(orderProgramAccount.account.data);
            if (!order) {
                throw Error("Could not parse obligation.");
            }
            return {
                state: order,
                address: orderProgramAccount.pubkey,
            };
        });
    }
    /**
     * Gets all orders for global config
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     */
    async getAllOrdersStateAndAddressForGlobalConfig(globalConfigOverride) {
        return this.getAllOrdersStateAndAddressWithFilters([], globalConfigOverride);
    }
    /**
     * Gets all orders for global config and returns them as OrderDisplay
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     * @throws error if mint decimals not found for mint
     */
    async getAllOrdersDisplayForGlobalConfig(mintDecimals, globalConfigOverride) {
        const ordersAndStates = await this.getAllOrdersStateAndAddressWithFilters([], globalConfigOverride);
        return this.toOrdersDisplay(ordersAndStates, mintDecimals);
    }
    /**
     * Gets all orders for a specific maker
     * @param maker - maker address
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     * @throws error if mint decimals not found for mint
     */
    async getAllOrdersStateAndAddressForMaker(maker, globalConfigOverride) {
        const filters = [
            {
                memcmp: {
                    bytes: maker.toBase58(),
                    offset: 40,
                },
            },
        ];
        return this.getAllOrdersStateAndAddressWithFilters(filters, globalConfigOverride);
    }
    /**
     * Gets all orders for a specific maker and returns them as OrderDisplay
     * @param maker - maker address
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     * @throws error if mint decimals not found for mint
     */
    async getAllOrdersDisplayForMaker(maker, mintDecimals, globalConfigOverride) {
        const ordersAndStates = await this.getAllOrdersStateAndAddressForMaker(maker, globalConfigOverride);
        const mints = [];
        for (const order of ordersAndStates) {
            mints.push(order.state.inputMint);
            mints.push(order.state.outputMint);
        }
        let ordersMintDecimals = mintDecimals ?? (await this.getMintDecimals(mints));
        return this.toOrdersDisplay(ordersAndStates, ordersMintDecimals);
    }
    /**
     * Gets all orders for a specific input mint
     * @param inputMint - input mint address
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     */
    async getAllOrdersStateAndAddressForInputMint(inputMint, globalConfigOverride) {
        const filters = [
            {
                memcmp: {
                    bytes: inputMint.toBase58(),
                    offset: 72,
                },
            },
        ];
        return this.getAllOrdersStateAndAddressWithFilters(filters, globalConfigOverride);
    }
    /**
     * Gets all orders for a specific input mint and returns them as OrderDisplay
     * @param inputMint - input mint address
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     */
    async getAllOrdersDisplayForInputMint(inputMint, mintDecimals, globalConfigOverride) {
        const ordersAndStates = await this.getAllOrdersStateAndAddressForInputMint(inputMint, globalConfigOverride);
        return this.toOrdersDisplay(ordersAndStates, mintDecimals);
    }
    /**
     * Gets all orders for a specific output mint
     * @param outputMint - output mint address
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     */
    async getAllOrdersStateAndAddressForOutputMint(outputMint, globalConfigOverride) {
        const filters = [
            {
                memcmp: {
                    bytes: outputMint.toBase58(),
                    offset: 136,
                },
            },
        ];
        return this.getAllOrdersStateAndAddressWithFilters(filters, globalConfigOverride);
    }
    /**
     * Gets all orders for a specific output mint and returns them as OrderDisplay
     * @param outputMint - output mint address
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     */
    async getAllOrdersDisplayForOutputMint(outputMint, mintDecimals, globalConfigOverride) {
        const ordersAndStates = await this.getAllOrdersStateAndAddressForOutputMint(outputMint, globalConfigOverride);
        return this.toOrdersDisplay(ordersAndStates, mintDecimals);
    }
    /**
     * Gets all orders for a specific input and output mint
     * @param inputMint - input mint address
     * @param outputMint - output mint address
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order states and addresses
     * @throws error if global config not set
     */
    async getAllOrdersDisplayForInputAndOutputMints(inputMint, outputMint, mintDecimals, globalConfigOverride) {
        const filters = [
            {
                memcmp: {
                    bytes: inputMint.toBase58(),
                    offset: 72,
                },
            },
            {
                memcmp: {
                    bytes: outputMint.toBase58(),
                    offset: 136,
                },
            },
        ];
        const ordersStateAndAddresses = await this.getAllOrdersStateAndAddressWithFilters(filters, globalConfigOverride);
        let mintDecimalsMap = new utils_1.PubkeyHashMap();
        if (!mintDecimals) {
            const inputMintDecimals = await (0, utils_1.getMintDecimals)(this._connection, inputMint);
            const outputMintDecimals = await (0, utils_1.getMintDecimals)(this._connection, outputMint);
            mintDecimalsMap.set(inputMint, inputMintDecimals);
            mintDecimalsMap.set(outputMint, outputMintDecimals);
        }
        else {
            mintDecimalsMap = mintDecimals;
        }
        return this.toOrdersDisplay(ordersStateAndAddresses, mintDecimalsMap);
    }
    /**
     * Gets all orders for a specific maker, input and output mint
     * @param maker - maker address
     * @param inputMint - input mint address
     * @param outputMint - output mint address
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns list of order displays
     * @throws error if global config not set
     * @throws error if mint decimals not found for mint
     */
    async getAllOrdersDisplayForMakerInputAndOutputMints(maker, inputMint, outputMint, mintDecimals, globalConfigOverride) {
        // Global config filter is always happening in getAllOrdersStateAndAddressWithFilters
        // but max of 4 filters are allowed so we merge maker and inputMint as they are
        // consecutive pubkeys in the order account maker at byte 40 and input mint at byte 72
        const mergedMakerInputMint = Buffer.concat([
            new Uint8Array(maker.toBuffer()),
            new Uint8Array(inputMint.toBuffer()),
        ]);
        const filters = [
            {
                memcmp: {
                    bytes: bs58_1.default.encode(mergedMakerInputMint),
                    offset: 40,
                },
            },
            {
                memcmp: {
                    bytes: outputMint.toBase58(),
                    offset: 136,
                },
            },
        ];
        const ordersStateAndAddresses = await this.getAllOrdersStateAndAddressWithFilters(filters, globalConfigOverride);
        let mintDecimalsMap = new utils_1.PubkeyHashMap();
        if (mintDecimals) {
            const inputMintDecimals = await (0, utils_1.getMintDecimals)(this._connection, inputMint);
            const outputMintDecimals = await (0, utils_1.getMintDecimals)(this._connection, outputMint);
            mintDecimalsMap.set(inputMint, inputMintDecimals);
            mintDecimalsMap.set(outputMint, outputMintDecimals);
        }
        return this.toOrdersDisplay(ordersStateAndAddresses, mintDecimalsMap);
    }
    async getOrderDisplay(orderAddress) {
        const order = await Order_1.Order.fetch(this._connection, orderAddress, this.programId);
        if (!order) {
            throw new Error("Order not found");
        }
        const inputMintDecimals = await (0, utils_1.getMintDecimals)(this._connection, order.inputMint);
        const outputMintDecimals = await (0, utils_1.getMintDecimals)(this._connection, order.outputMint);
        const mintDecimalsMap = new utils_1.PubkeyHashMap();
        mintDecimalsMap.set(order.inputMint, inputMintDecimals);
        mintDecimalsMap.set(order.outputMint, outputMintDecimals);
        return this.toOrdersDisplay([{ address: orderAddress, state: order }], mintDecimalsMap)[0];
    }
    /**
     * Converts order states and addresses to order displays
     * @param orders - list of order states and addresses
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @returns list of order displays
     * @throws error if mint decimals not found for mint
     */
    toOrdersDisplay(orders, mintDecimals) {
        const ordersDisplay = [];
        for (const order of orders) {
            const inputMintDecimals = mintDecimals.get(order.state.inputMint);
            if (!inputMintDecimals) {
                throw new Error("Mint decimals not found for mint + " +
                    order.state.inputMint.toBase58());
            }
            const outputMintDecimals = mintDecimals.get(order.state.outputMint);
            if (!outputMintDecimals) {
                throw new Error("Mint decimals not found for mint + " +
                    order.state.outputMint.toBase58());
            }
            const initialInputAmountDecimal = new decimal_js_1.default(order.state.initialInputAmount.toString()).div(new decimal_js_1.default(10).pow(inputMintDecimals));
            const expectedOutputAmountDecimal = new decimal_js_1.default(order.state.expectedOutputAmount.toString()).div(new decimal_js_1.default(10).pow(outputMintDecimals));
            const remainingInputAmountDecimal = new decimal_js_1.default(order.state.remainingInputAmount.toString()).div(new decimal_js_1.default(10).pow(inputMintDecimals));
            const filledOutputAmountDecimal = new decimal_js_1.default(order.state.filledOutputAmount.toString()).div(new decimal_js_1.default(10).pow(outputMintDecimals));
            const orderFillPct = initialInputAmountDecimal
                .sub(remainingInputAmountDecimal)
                .div(initialInputAmountDecimal);
            const orderTipLamports = new decimal_js_1.default(order.state.tipAmount.toString());
            const orderTipDecimal = (0, utils_1.lamportsToAmountDecimal)(orderTipLamports, 9); // tip is native sol which
            ordersDisplay.push({
                address: order.address,
                state: order.state,
                maker: order.state.maker,
                initialInputAmountDecimal,
                expectedOutputAmountDecimal,
                remainingInputAmountDecimal,
                filledOutputAmountDecimal,
                numberOfFills: order.state.numberOfFills.toNumber(),
                orderFillPct: orderFillPct,
                orderPriceInputToOutput: initialInputAmountDecimal.div(expectedOutputAmountDecimal),
                orderPriceOutputToInput: expectedOutputAmountDecimal.div(initialInputAmountDecimal),
                executionPriceInputToOutput: initialInputAmountDecimal
                    .sub(remainingInputAmountDecimal)
                    .div(filledOutputAmountDecimal),
                executionPriceOutputToInput: filledOutputAmountDecimal.div(initialInputAmountDecimal.sub(remainingInputAmountDecimal)),
                orderTipLamports,
                orderTipDecimal,
            });
        }
        return ordersDisplay;
    }
    /**
     * Returns the ask and bid OrderDisplay arrays for a given base and quote token mint
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns { askOrders: OrderDisplay[], bidOrders: OrderDisplay[] } - the ask and bid orders
     * @throws error if mint decimals not found for mint
     * @throws error if global config not set
     */
    async getOrdersDisplayForBaseAndQuote(baseTokenMint, quoteTokenMint, mintDecimals, globalConfigOverride) {
        const bidOrders = await this.getAllOrdersDisplayForInputAndOutputMints(baseTokenMint, quoteTokenMint, mintDecimals, globalConfigOverride);
        const askOrders = await this.getAllOrdersDisplayForInputAndOutputMints(quoteTokenMint, baseTokenMint, mintDecimals, globalConfigOverride);
        return {
            bidOrders,
            askOrders,
        };
    }
    /**
     * Returns the ask and bid OrderDisplay arrays for a given base and quote token mint and maker
     * @param maker - the maker address
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns { askOrders: OrderDisplay[], bidOrders: OrderDisplay[] } - the ask and bid orders
     * @throws error if mint decimals not found for mint
     * @throws error if global config not set
     */
    async getOrdersDisplayForBaseAndQuoteAndMaker(maker, baseTokenMint, quoteTokenMint, mintDecimals, globalConfigOverride) {
        const bidOrders = await this.getAllOrdersDisplayForMakerInputAndOutputMints(maker, baseTokenMint, quoteTokenMint, mintDecimals, globalConfigOverride);
        const askOrders = await this.getAllOrdersDisplayForMakerInputAndOutputMints(maker, quoteTokenMint, baseTokenMint, mintDecimals, globalConfigOverride);
        return {
            bidOrders,
            askOrders,
        };
    }
    /**
     * Returns the sell and buy FilledOrder arrays for a given base and quote token
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param globalConfigOverride - global config override to filter by
     * @returns { filledOrdersSell: FilledOrder[], filledOrdersBuy: FilledOrder[] } - the sell and buy filled orders
     * @throws error if mint decimals not found for mint
     * @throws error if global config not set
     */
    async getLatestFilledOrders(baseTokenMint, quoteTokenMint, mintDecimals, globalConfigOverride) {
        const { askOrders, bidOrders } = await this.getOrdersDisplayForBaseAndQuote(baseTokenMint, quoteTokenMint, mintDecimals, globalConfigOverride);
        const filledOrdersSell = [];
        const filledOrdersBuy = [];
        for (const order of askOrders) {
            if (order.state.remainingInputAmount.toNumber() <
                order.state.initialInputAmount.toNumber()) {
                filledOrdersSell.push({
                    address: order.address,
                    orderDisplay: order,
                    quoteTokenMint: quoteTokenMint,
                    baseTokenMint: baseTokenMint,
                    time: order.state.lastUpdatedTimestamp.toNumber(),
                    price: order.executionPriceOutputToInput,
                    size: order.filledOutputAmountDecimal,
                    txid: "N/A",
                    type: "sell",
                });
            }
        }
        for (const order of bidOrders) {
            if (order.state.remainingInputAmount.toNumber() <
                order.state.initialInputAmount.toNumber()) {
                filledOrdersBuy.push({
                    address: order.address,
                    orderDisplay: order,
                    quoteTokenMint: quoteTokenMint,
                    baseTokenMint: baseTokenMint,
                    time: order.state.lastUpdatedTimestamp.toNumber(),
                    price: order.executionPriceInputToOutput,
                    size: order.filledOutputAmountDecimal,
                    txid: "N/A",
                    type: "buy",
                });
            }
        }
        // sort by filledTimestamp
        filledOrdersBuy.sort((a, b) => -(a.time - b.time));
        filledOrdersSell.sort((a, b) => -(a.time - b.time));
        return { filledOrdersBuy, filledOrdersSell };
    }
    /**
     * Starts listening to order changes for a specific maker
     * @param maker - the maker address
     * @param callbackOnChange - callback to be called when an order changes
     * @returns subscriptionId - a number of the subscription id, to be used to stop the listener
     */
    listenToMakerOrders(maker, callbackOnChange) {
        const filters = [
            {
                memcmp: {
                    bytes: maker.toBase58(),
                    offset: 40,
                },
            },
        ];
        const subscriptionId = this.listenToOrdersChangeWithFilters(filters, callbackOnChange);
        return subscriptionId;
    }
    /**
     * Starts listening to order changes with 2 separate listeners, one for sell orders and one for buy orders
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param callbackOnChangeSellOrders - callback to be called when a sell order changes
     * @param callbackOnChangeBuyOrders - callback to be called when a buy order changes
     * @returns { subscriptionIdSellOrders, subscriptionIdBuyOrders } - the subscription id for the two listeners (both should be closed when subscription no longer needed)
     */
    listenToOrderChangeForBaseAndQuote(baseTokenMint, quoteTokenMint, callbackOnChangeSellOrders, callbackOnChangeBuyOrders) {
        const buyFilters = [
            {
                memcmp: {
                    bytes: baseTokenMint.toBase58(),
                    offset: 72,
                },
            },
            {
                memcmp: {
                    bytes: quoteTokenMint.toBase58(),
                    offset: 136,
                },
            },
        ];
        const sellFilters = [
            {
                memcmp: {
                    bytes: quoteTokenMint.toBase58(),
                    offset: 72,
                },
            },
            {
                memcmp: {
                    bytes: baseTokenMint.toBase58(),
                    offset: 136,
                },
            },
        ];
        const subscriptionIdSellOrders = this.listenToOrdersChangeWithFilters(sellFilters, callbackOnChangeSellOrders);
        const subscriptionIdBuyOrders = this.listenToOrdersChangeWithFilters(buyFilters, callbackOnChangeBuyOrders);
        return { subscriptionIdSellOrders, subscriptionIdBuyOrders };
    }
    /**
     * Starts listening to order changes with 2 separate listeners, one for sell orders and one for buy orders - filter for only filled orders
     * @param baseTokenMint - the base token mint
     * @param quoteTokenMint - the quote token mint
     * @param callbackOnChangeSellOrders - callback to be called when a sell order changes
     * @param callbackOnChangeBuyOrders - callback to be called when a buy order changes
     * @returns { subscriptionIdSellOrders, subscriptionIdBuyOrders } - the subscription id for the two listeners (both should be closed when subscription no longer needed)
     */
    listenToOrderFillChangeForBaseAndQuote(baseTokenMint, quoteTokenMint, callbackOnChangeSellOrders, callbackOnChangeBuyOrders) {
        const buyFilters = [
            {
                memcmp: {
                    bytes: baseTokenMint.toBase58(),
                    offset: 72,
                },
            },
            {
                memcmp: {
                    bytes: quoteTokenMint.toBase58(),
                    offset: 136,
                },
            },
        ];
        const sellFilters = [
            {
                memcmp: {
                    bytes: quoteTokenMint.toBase58(),
                    offset: 72,
                },
            },
            {
                memcmp: {
                    bytes: baseTokenMint.toBase58(),
                    offset: 136,
                },
            },
        ];
        const callbackOnChangeSellOrdersFilledOrdersOnly = (orderStateAndAddress, slot) => {
            if (orderStateAndAddress.state.remainingInputAmount.toNumber() <
                orderStateAndAddress.state.initialInputAmount.toNumber()) {
                callbackOnChangeSellOrders(orderStateAndAddress, slot);
            }
        };
        const callbackOnChangeBuyOrdersFilledOrdersOnly = (orderStateAndAddress, slot) => {
            if (orderStateAndAddress.state.remainingInputAmount.toNumber() <
                orderStateAndAddress.state.initialInputAmount.toNumber()) {
                callbackOnChangeBuyOrders(orderStateAndAddress, slot);
            }
        };
        const subscriptionIdSellOrders = this.listenToOrdersChangeWithFilters(sellFilters, callbackOnChangeSellOrdersFilledOrdersOnly);
        const subscriptionIdBuyOrders = this.listenToOrdersChangeWithFilters(buyFilters, callbackOnChangeBuyOrdersFilledOrdersOnly);
        return { subscriptionIdSellOrders, subscriptionIdBuyOrders };
    }
    /**
     * Starts listening to order changes based on the filters provided, for the global config
     * @param filters - list of filters to apply to the get program accounts
     * @param callbackOnChange - callback to be called when an order changes
     * @returns subscriptionId - a number of the subscription id, to be used to stop the listener
     */
    listenToOrdersChangeWithFilters(filters, callbackOnChange) {
        filters.push({
            memcmp: {
                bytes: this._globalConfig.toBase58(),
                offset: 8,
            },
        });
        filters.push({
            dataSize: Order_1.Order.layout.span + 8,
        });
        const callbackOnChangeWtihDecoding = async (keyedAccountInfo, context) => {
            if (keyedAccountInfo.accountInfo === null) {
                throw new Error("Invalid account");
            }
            if (!keyedAccountInfo.accountInfo.owner.equals(this.programId)) {
                throw new Error("account doesn't belong to this program");
            }
            const order = Order_1.Order.decode(keyedAccountInfo.accountInfo.data);
            if (!order) {
                throw Error("Could not parse obligation.");
            }
            callbackOnChange({
                state: order,
                address: keyedAccountInfo.accountId,
            }, context.slot);
        };
        const subscriptionId = this._connection.onProgramAccountChange(this.programId, callbackOnChangeWtihDecoding, { commitment: "confirmed", encoding: "base64", filters });
        return subscriptionId;
    }
    /**
     * Stops listening to order changes based on the subscription id
     * @param subscriptionId - the subscription id to stop listening to
     */
    stopListeningToOrdersChange(subscriptionId) {
        this._connection.removeProgramAccountChangeListener(subscriptionId);
    }
    /**
     * Get the create global config instruction
     * @param admin - the admin address
     * @param globalConfig - the global config keypair
     * @returns the create global config instruction
     */
    async createGlobalConfigIxs(admin, globalConfig) {
        let ixs = [];
        const globalConfigSize = GlobalConfig_1.GlobalConfig.layout.getSpan() + 8;
        ixs.push((0, utils_1.createKeypairRentExemptIxSync)(admin, globalConfig, globalConfigSize, await this._connection.getMinimumBalanceForRentExemption(globalConfigSize), this.programId));
        const pdaAuthority = (0, utils_1.getPdaAuthority)(this.programId, globalConfig.publicKey);
        ixs.push(limoOperations.initializeGlobalConfig(admin, globalConfig.publicKey, pdaAuthority, this.programId));
        return ixs;
    }
    /**
     * Create the global config
     * @param admin - the admin keypair
     * @param globalConfig - the global config keypair
     * @returns the transaction signature
     */
    async createGlobalConfig(admin, globalConfig) {
        const ix = await this.createGlobalConfigIxs(admin.publicKey, globalConfig);
        const sig = await this.executeTransaction(ix, admin, [globalConfig]);
        if (process.env.DEBUG === "true") {
            console.log("Initialize Global Config txn: " + sig.toString());
        }
        return sig;
    }
    /**
     * Get the create initialize vault instruction
     * @param user - the user address
     * @param mint - the mint address
     * @param mintTokenProgramId - the mint token program id
     * @param globalConfigOverride - the global config override
     * @returns the create initialize vault instruction
     */
    async initializeVaultIx(user, mint, mintTokenProgramId) {
        const mintProgramId = mintTokenProgramId
            ? mintTokenProgramId
            : (await this.getMintsProgramOwners([mint]))[0];
        const globalConfigState = await this.getGlobalConfigState();
        return limoOperations.initializeVault(user, this._globalConfig, mint, this.programId, mintProgramId);
    }
    /**
     * Initialize the vault
     * @param user - the user keypair
     * @param mint - the mint address
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintTokenProgramId - the mint token program id
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature
     */
    async initializeVault(user, mint, mode = "execute", mintTokenProgramId) {
        const ix = await this.initializeVaultIx(user.publicKey, mint, mintTokenProgramId);
        const vault = (0, utils_1.getTokenVaultPDA)(this.programId, this._globalConfig, mint);
        const log = "Initialize Vault: " + vault.toString();
        return this.processTxn(user, [ix], mode, log, []);
    }
    /**
     * Get the create initialize order instruction
     * @param user - the user address
     * @param inputMint - the input mint address
     * @param outputMint - the output mint address
     * @param inputAmountLamports - the input amount in lamports
     * @param outputAmountLamports - the output amount in lamports
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the create initialize order instruction and keypair to sign the transaction with
     * @throws error if mint decimals not found for mint
     */
    async createOrderGenericIx(user, inputMint, outputMint, inputAmountLamports, outputAmountLamports, inputMintProgramId, outputMintProgramId, globalConfigOverride, wrapUnwrapSol = true, withInitVault) {
        let initVault;
        if (withInitVault === undefined) {
            try {
                const vaultPda = (0, utils_1.getTokenVaultPDA)(this.programId, this._globalConfig, inputMint);
                initVault = !(await (0, utils_1.checkIfAccountExists)(this._connection, vaultPda));
            }
            catch (error) {
                initVault = false;
            }
        }
        else {
            initVault = withInitVault;
        }
        const order = web3_js_2.Keypair.generate();
        const orderParams = {
            side: "bid",
            quoteTokenMint: outputMint,
            baseTokenMint: inputMint,
            quoteTokenAmount: outputAmountLamports,
            baseTokenAmount: inputAmountLamports,
        };
        const ixs = [];
        if (initVault) {
            ixs.push(limoOperations.initializeVault(user, this._globalConfig, inputMint, this.programId, inputMintProgramId));
        }
        ixs.push((0, utils_1.createKeypairRentExemptIxSync)(user, order, Order_1.Order.layout.getSpan() + 8, exports.ORDER_RENT_EXEMPTION_LAMPORTS, this.programId));
        const baseTokenMintProgramId = inputMintProgramId;
        const quoteTokenMintProgramId = outputMintProgramId;
        let closeWsolAtaIxs = [];
        if (inputMint.equals(exports.WRAPPED_SOL_MINT) && wrapUnwrapSol) {
            const { createIxs, fillIxs, closeIx } = this.getInitIfNeededWSOLCreateAndCloseIxs(user, user, inputAmountLamports);
            ixs.push(...createIxs, ...fillIxs);
            closeWsolAtaIxs = closeIx;
        }
        ixs.push(limoOperations.createOrder(user, globalConfigOverride ? globalConfigOverride : this._globalConfig, order.publicKey, orderParams, this.programId, baseTokenMintProgramId, quoteTokenMintProgramId));
        ixs.push(...closeWsolAtaIxs);
        return [ixs, order];
    }
    /**
     * Create an order
     * @param user - the user keypair
     * @param inputMint - the input mint address
     * @param outputMint - the output mint address
     * @param inputAmountLamports - the input amount in lamports
     * @param outputAmountLamports - the output amount in lamports
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature and the order keypair
     */
    async createOrderGeneric(user, inputMint, outputMint, inputAmountLamports, outputAmountLamports, mode = "execute", inputMintProgramId, outputMintProgramId, globalConfigOverride) {
        const [ixs, order] = await this.createOrderGenericIx(user.publicKey, inputMint, outputMint, inputAmountLamports, outputAmountLamports, inputMintProgramId, outputMintProgramId, globalConfigOverride);
        const log = "Create Order: " + order.publicKey.toString();
        const sig = await this.processTxn(user, ixs, mode, log, [order]);
        return [sig, order];
    }
    /**
     * Place a bid order instruction
     * @param user - the user address
     * @param quoteTokenMint - the quote token mint address
     * @param baseTokenMint - the base token mint address
     * @param baseUiAmount - the base amount in UI
     * @param price - the price
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the create order instruction and keypair to sign the transaction with
     */
    async placeBidIxs(user, quoteTokenMint, baseTokenMint, baseUiAmount, price, inputMintProgramId, outputMintProgramId, mintDecimals, globalConfigOverride) {
        let baseDecimals;
        let quoteDecimals;
        if (mintDecimals) {
            baseDecimals = mintDecimals.get(baseTokenMint);
            quoteDecimals = mintDecimals.get(quoteTokenMint);
        }
        baseDecimals = baseDecimals
            ? baseDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, baseTokenMint);
        quoteDecimals = quoteDecimals
            ? quoteDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, quoteTokenMint);
        return this.createOrderGenericIx(user, baseTokenMint, quoteTokenMint, (0, utils_1.amountToLamportsBN)(baseUiAmount, baseDecimals), (0, utils_1.amountToLamportsBN)(baseUiAmount.div(price), quoteDecimals), inputMintProgramId, outputMintProgramId, globalConfigOverride);
    }
    /**
     * Place a bid order
     * @param user - the user keypair
     * @param quoteTokenMint - the quote token mint address
     * @param baseTokenMint - the base token mint address
     * @param baseUiAmount - the base amount in UI
     * @param price - the price
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature and the order keypair
     */
    async placeBid(user, quoteTokenMint, baseTokenMint, baseUiAmount, price, mode = "execute", inputMintProgramId, outputMintProgramId, mintDecimals, globalConfigOverride) {
        const [ixs, order] = await this.placeBidIxs(user.publicKey, quoteTokenMint, baseTokenMint, baseUiAmount, price, inputMintProgramId, outputMintProgramId, mintDecimals, globalConfigOverride);
        const log = "Place Order: Buy " +
            quoteTokenMint.toString().slice(0, 5) +
            " at price:" +
            price +
            " for " +
            baseUiAmount +
            " " +
            baseTokenMint.toString().slice(0, 5) +
            " Order: " +
            order.publicKey.toString();
        const sig = await this.processTxn(user, ixs, mode, log, [order]);
        return [sig, order];
    }
    /**
     * Place an ask order instruction
     * @param user - the user address
     * @param quoteTokenMint - the quote token mint address
     * @param baseTokenMint - the base token mint address
     * @param quoteUiAmount - the quote amount in UI
     * @param price - the price
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the create order instruction and keypair to sign the transaction with
     */
    async placeAskIxs(user, quoteTokenMint, baseTokenMint, quoteUiAmount, price, inputMintProgramId, outputMintProgramId, mintDecimals, globalConfigOverride) {
        let baseDecimals;
        let quoteDecimals;
        if (mintDecimals) {
            baseDecimals = mintDecimals.get(baseTokenMint);
            quoteDecimals = mintDecimals.get(quoteTokenMint);
        }
        baseDecimals = baseDecimals
            ? baseDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, baseTokenMint);
        quoteDecimals = quoteDecimals
            ? quoteDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, quoteTokenMint);
        return this.createOrderGenericIx(user, quoteTokenMint, baseTokenMint, (0, utils_1.amountToLamportsBN)(quoteUiAmount, quoteDecimals), (0, utils_1.amountToLamportsBN)(quoteUiAmount.mul(price), baseDecimals), inputMintProgramId, outputMintProgramId, globalConfigOverride);
    }
    /**
     * Place an ask order
     * @param user - the user keypair
     * @param quoteTokenMint - the quote token mint address
     * @param baseTokenMint - the base token mint address
     * @param quoteUiAmount - the quote amount in UI
     * @param price - the price
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature and the order keypair
     */
    async placeAsk(user, quoteTokenMint, baseTokenMint, quoteUiAmount, price, mode = "execute", inputMintProgramId, outputMintProgramId, mintDecimals, globalConfigOverride) {
        const [ixs, order] = await this.placeAskIxs(user.publicKey, quoteTokenMint, baseTokenMint, quoteUiAmount, price, inputMintProgramId, outputMintProgramId, mintDecimals, globalConfigOverride);
        const log = "Place Order: Sell " +
            quoteTokenMint.toString().slice(0, 5) +
            " at price:" +
            price +
            " for " +
            quoteUiAmount +
            " " +
            baseTokenMint.toString().slice(0, 5) +
            " Order: " +
            order.publicKey.toString();
        const sig = await this.processTxn(user, ixs, mode, log, [order]);
        return [sig, order];
    }
    /**
     * Get the create take order instruction
     * @param taker - the taker address
     * @param order - the order state and address
     * @param inputAmountDecimals - the input amount in decimals
     * @param minOutputAmountDecimals - the minimum output amount in decimals
     * @param expressRelayProgramId - the express relay program id
     * @param inputMintDecimals - the input mint decimals
     * @param outputMintDecimals - the output mint decimals
     * @returns the create take order instruction
     */
    takeOrderIx(taker, order, inputAmountLamports, minOutputAmountLamports, expressRelayProgramId, permissionlessTipLamports, permissionless, wrapUnwrapSol = true) {
        let ixs = [];
        let closeWsolAtaIxs = [];
        let takerInputAta;
        if (order.state.inputMint.equals(exports.WRAPPED_SOL_MINT)) {
            const { createIxs, fillIxs: _fill, closeIx, ata, } = this.getInitIfNeededWSOLCreateAndCloseIxs(taker, taker, new bn_js_1.default(0));
            takerInputAta = ata;
            if (wrapUnwrapSol) {
                ixs.push(...createIxs);
                closeWsolAtaIxs.push(...closeIx);
            }
        }
        else {
            const { ata, createAtaIx: createTakerInputAta } = (0, utils_1.createAtaIdempotent)(taker, taker, order.state.inputMint, order.state.inputMintProgramId);
            takerInputAta = ata;
            ixs.push(createTakerInputAta);
        }
        let takerOutputAta;
        if (order.state.outputMint.equals(exports.WRAPPED_SOL_MINT)) {
            const outputExpectedOutForInputAmount = (0, utils_1.divCeil)(order.state.expectedOutputAmount.mul(inputAmountLamports), order.state.initialInputAmount);
            const { createIxs, fillIxs, closeIx, ata } = this.getInitIfNeededWSOLCreateAndCloseIxs(taker, taker, outputExpectedOutForInputAmount);
            takerOutputAta = ata;
            if (wrapUnwrapSol) {
                ixs.push(...createIxs, ...fillIxs);
                closeWsolAtaIxs.push(...closeIx);
            }
        }
        else {
            const { ata, createAtaIx: createTakerOutputAta } = (0, utils_1.createAtaIdempotent)(taker, taker, order.state.outputMint, order.state.outputMintProgramId);
            takerOutputAta = ata;
            ixs.push(createTakerOutputAta);
        }
        let makerOutputAta;
        let intermediaryOutputTokenAccount;
        if (order.state.outputMint.equals(exports.WRAPPED_SOL_MINT)) {
            makerOutputAta = this.getProgramID();
            intermediaryOutputTokenAccount = (0, utils_1.getIntermediaryTokenAccountPDA)(this.programId, order.address);
        }
        else {
            // create maker ata
            const { ata, createAtaIx } = (0, utils_1.createAtaIdempotent)(order.state.maker, taker, order.state.outputMint, order.state.outputMintProgramId);
            makerOutputAta = ata;
            ixs.push(createAtaIx);
            intermediaryOutputTokenAccount = this.programId;
        }
        ixs.push(limoOperations.takeOrder({
            taker,
            maker: order.state.maker,
            globalConfig: order.state.globalConfig,
            inputMint: order.state.inputMint,
            outputMint: order.state.outputMint,
            order: order.address,
            inputAmountLamports,
            minOutputAmountLamports,
            programId: this.programId,
            expressRelayProgramId,
            takerInputAta,
            takerOutputAta,
            intermediaryOutputTokenAccount,
            makerOutputAta,
            inputTokenProgram: order.state.inputMintProgramId,
            outputTokenProgram: order.state.outputMintProgramId,
            permissionlessTipLamports: permissionlessTipLamports !== undefined
                ? permissionlessTipLamports
                : new bn_js_1.default(0),
            permissionless: permissionless !== undefined ? permissionless : false,
        }));
        ixs.push(...closeWsolAtaIxs);
        return ixs;
    }
    /**
     * Take an order
     * @param crank - the crank keypair
     * @param order - the order state and address
     * @param inputAmountDecimals - the input amount in decimals
     * @param outputAmountDecimals - the output amount in decimals
     * @param expressRelayProgramId - the express relay program id
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @returns the transaction signature
     */
    async permissionlessTakeOrder(crank, order, inputAmountLamports, outputAmountLamports, expressRelayProgramId, mode, permissionlessTipLamports, mintDecimals) {
        let inputMintDecimals;
        let outputMintDecimals;
        if (mintDecimals) {
            inputMintDecimals = mintDecimals.get(order.state.inputMint);
            outputMintDecimals = mintDecimals.get(order.state.outputMint);
        }
        inputMintDecimals = inputMintDecimals
            ? inputMintDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, order.state.inputMint);
        outputMintDecimals = outputMintDecimals
            ? outputMintDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, order.state.outputMint);
        const ixs = this.takeOrderIx(crank.publicKey, order, inputAmountLamports, outputAmountLamports, expressRelayProgramId, permissionlessTipLamports, true);
        const outputExpectedOutForInputAmount = (0, utils_1.divCeil)(order.state.expectedOutputAmount.mul(inputAmountLamports), order.state.initialInputAmount);
        const log = "Taker Order: " +
            order.address.toString() +
            " selling " +
            (0, utils_1.lamportsToAmountBN)(inputAmountLamports, inputMintDecimals).toString() +
            " token ";
        order.state.inputMint.toString().slice(0, 5) +
            " for " +
            (0, utils_1.lamportsToAmountBN)(outputExpectedOutForInputAmount, outputMintDecimals).toString() +
            " token " +
            order.state.outputMint.toString().slice(0, 5);
        const sig = await this.processTxn(crank, ixs, mode, log, []);
        return sig;
    }
    /**
     * Get the create flash take order instruction
     * @param taker - the taker address
     * @param order - the order state and address
     * @param inputAmountDecimal - the input amount in decimals
     * @param minOutputAmountDecimal - the minimum output amount in decimals
     * @param expressRelayProgramId - the express relay program id
     * @param inputMintDecimals - the input mint decimals
     * @param outputMintDecimals - the output mint decimals
     * @param permissionlessTipLamports - the tip in lamports for permissionless flash_take_order
     * @param permissionless - whether the flash take order should be a permissionless call
     * @returns the create flash take order instruction - in between the start and
     * end flash take order instructions, the swap and permissioning logic should exist
     */
    flashTakeOrderIxs(taker, order, inputAmountLamports, minOutputAmountLamports, expressRelayProgramId, permissionlessTipLamports, permissionless, wrapUnwrapSol = true) {
        let createAtaIxs = [];
        let closeWsolAtaIxs = [];
        let takerInputAta;
        if (order.state.inputMint.equals(exports.WRAPPED_SOL_MINT)) {
            const { createIxs, fillIxs: _fill, closeIx, ata, } = this.getInitIfNeededWSOLCreateAndCloseIxs(taker, taker, new bn_js_1.default(0));
            takerInputAta = ata;
            if (wrapUnwrapSol) {
                createAtaIxs.push(...createIxs);
                closeWsolAtaIxs.push(...closeIx);
            }
        }
        else {
            const { ata, createAtaIx: createTakerInputAta } = (0, utils_1.createAtaIdempotent)(taker, taker, order.state.inputMint, order.state.inputMintProgramId);
            takerInputAta = ata;
            createAtaIxs.push(createTakerInputAta);
        }
        let takerOutputAta;
        if (order.state.outputMint.equals(exports.WRAPPED_SOL_MINT)) {
            const outputExpectedOutForInputAmount = (0, utils_1.divCeil)(order.state.expectedOutputAmount.mul(inputAmountLamports), order.state.initialInputAmount);
            const { createIxs, fillIxs: _fillIxs, closeIx, ata, } = this.getInitIfNeededWSOLCreateAndCloseIxs(taker, taker, outputExpectedOutForInputAmount);
            takerOutputAta = ata;
            if (wrapUnwrapSol) {
                createAtaIxs.push(...createIxs);
                closeWsolAtaIxs.push(...closeIx);
            }
        }
        else {
            const { ata, createAtaIx: createTakerOutputAta } = (0, utils_1.createAtaIdempotent)(taker, taker, order.state.outputMint, order.state.outputMintProgramId);
            takerOutputAta = ata;
            createAtaIxs.push(createTakerOutputAta);
        }
        let makerOutputAta;
        let intermediaryOutputTokenAccount;
        if (order.state.outputMint.equals(exports.WRAPPED_SOL_MINT)) {
            makerOutputAta = this.getProgramID();
            intermediaryOutputTokenAccount = (0, utils_1.getIntermediaryTokenAccountPDA)(this.programId, order.address);
        }
        else {
            // create maker ata
            const { ata, createAtaIx } = (0, utils_1.createAtaIdempotent)(order.state.maker, taker, order.state.outputMint, order.state.outputMintProgramId);
            makerOutputAta = ata;
            createAtaIxs.push(createAtaIx);
            intermediaryOutputTokenAccount = this.programId;
        }
        const { startIx: startFlashIx, endIx: endFlashIx } = limoOperations.flashTakeOrder({
            taker,
            maker: order.state.maker,
            globalConfig: order.state.globalConfig,
            inputMint: order.state.inputMint,
            outputMint: order.state.outputMint,
            order: order.address,
            inputAmountLamports,
            minOutputAmountLamports,
            programId: this.programId,
            expressRelayProgramId,
            takerInputAta,
            takerOutputAta,
            intermediaryOutputTokenAccount,
            makerOutputAta,
            inputTokenProgram: order.state.inputMintProgramId,
            outputTokenProgram: order.state.outputMintProgramId,
            permissionlessTipLamports: permissionlessTipLamports !== undefined
                ? permissionlessTipLamports
                : new bn_js_1.default(0),
            permissionless: permissionless !== undefined ? permissionless : false,
        });
        return {
            createAtaIxs,
            startFlashIx,
            endFlashIx,
            closeWsolAtaIxs: closeWsolAtaIxs,
        };
    }
    /**
     * Flash take an order
     * @param crank - the crank keypair
     * @param order - the order state and address
     * @param inputAmountDecimals - the input amount in decimals
     * @param outputAmountDecimals - the output amount in decimals
     * @param expressRelayProgramId - the express relay program id
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @returns the transaction signature
     */
    async permissionlessFlashTakeOrder(crank, order, inputAmountLamports, outputAmountLamports, expressRelayProgramId, mode, swapIxs, permissionlessTipLamports, extraSigners, mintDecimals) {
        let inputMintDecimals;
        let outputMintDecimals;
        if (mintDecimals) {
            inputMintDecimals = mintDecimals.get(order.state.inputMint);
            outputMintDecimals = mintDecimals.get(order.state.outputMint);
        }
        inputMintDecimals = inputMintDecimals
            ? inputMintDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, order.state.inputMint);
        outputMintDecimals = outputMintDecimals
            ? outputMintDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, order.state.outputMint);
        const { createAtaIxs, startFlashIx, endFlashIx, closeWsolAtaIxs } = this.flashTakeOrderIxs(crank.publicKey, order, inputAmountLamports, outputAmountLamports, expressRelayProgramId, permissionlessTipLamports, true);
        const outputExpectedOutForInputAmount = (0, utils_1.divCeil)(order.state.expectedOutputAmount.mul(inputAmountLamports), order.state.initialInputAmount);
        const log = "Taker Order: " +
            order.address.toString() +
            " selling " +
            (0, utils_1.lamportsToAmountBN)(inputAmountLamports, inputMintDecimals).toString() +
            " token ";
        order.state.inputMint.toString().slice(0, 5) +
            " for " +
            (0, utils_1.lamportsToAmountBN)(outputExpectedOutForInputAmount, outputMintDecimals).toString() +
            " token " +
            order.state.outputMint.toString().slice(0, 5);
        const sig = await this.processTxn(crank, [
            ...createAtaIxs,
            startFlashIx,
            ...swapIxs,
            endFlashIx,
            ...closeWsolAtaIxs,
        ], mode, log, extraSigners, 300_000);
        return sig;
    }
    /**
     * Get the create close order instruction
     * @param user - the user address
     * @param inputMont - the inputMint for the swap
     * @param outputMint - the outputMint for the swap
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @returns the log ixs - to be used once at the beginning and once at the end
     */
    logUserSwapBalancesIxs(user, inputMint, outputMint, inputMintProgramId, outputMintProgramId, swapProgarmId = this.programId, pdaReferrer = this.programId) {
        const inputMintAta = (0, spl_token_1.getAssociatedTokenAddressSync)(inputMint, user, true, inputMintProgramId);
        const outputMintAta = (0, spl_token_1.getAssociatedTokenAddressSync)(outputMint, user, true, outputMintProgramId);
        const logIxStart = (0, instructions_1.logUserSwapBalancesStart)({
            swapProgramId: swapProgarmId,
        }, {
            baseAccounts: {
                maker: user,
                inputMint,
                outputMint,
                inputTa: inputMintAta,
                outputTa: outputMintAta,
                pdaReferrer,
            },
            userSwapBalanceState: (0, utils_1.getUserSwapBalanceStatePDA)(user, this.programId),
            eventAuthority: (0, utils_1.getEventAuthorityPDA)(this.programId),
            program: this.programId,
            systemProgram: web3_js_1.SystemProgram.programId,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        });
        const logIxEnd = (0, instructions_2.logUserSwapBalancesEnd)({
            swapProgramId: swapProgarmId,
        }, {
            baseAccounts: {
                maker: user,
                inputMint,
                outputMint,
                inputTa: inputMintAta,
                outputTa: outputMintAta,
                pdaReferrer,
            },
            userSwapBalanceState: (0, utils_1.getUserSwapBalanceStatePDA)(user, this.programId),
            eventAuthority: (0, utils_1.getEventAuthorityPDA)(this.programId),
            program: this.programId,
            systemProgram: web3_js_1.SystemProgram.programId,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        });
        return {
            beforeSwapIx: logIxStart,
            afterSwapIx: logIxEnd,
        };
    }
    /**
     * Get the create close order instruction
     * @param user - the user address
     * @param inputMont - the inputMint for the swap
     * @param outputMint - the outputMint for the swap
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @returns the log ixs - to be used once at the beginning and once at the end
     */
    async logUserSwapBalances(user, inputMint, outputMint, inputMintProgramId, outputMintProgramId, setupIxs = [], mockSwapIxs = [], mockSwapSigners = []) {
        const { beforeSwapIx, afterSwapIx } = this.logUserSwapBalancesIxs(user.publicKey, inputMint, outputMint, inputMintProgramId, outputMintProgramId);
        const sig = await this.processTxn(user, [...setupIxs, beforeSwapIx, ...mockSwapIxs, afterSwapIx], "execute", "", mockSwapSigners, 300_000);
        console.log("logUserSwapBalances", sig);
        return sig;
    }
    /**
     * Get the total tips for all filled orders from the given orders array
     * @param orders - the list of orders to filter by filled and calculate the total tips
     * @returns the decimal amount of native sol tips
     */
    getTotalTipsForFilledOrdersDecimal(orders) {
        let totalTipsForFilledOrdersLamports = new decimal_js_1.default(0);
        for (const order of orders) {
            if (order.state.status === 1) {
                // Filled
                totalTipsForFilledOrdersLamports = totalTipsForFilledOrdersLamports.add(order.orderTipDecimal);
            }
        }
        return totalTipsForFilledOrdersLamports;
    }
    /**
     * Get the all instructions to close and claim tips for all filled orders from the given orders array
     * @param maker - the maker address to close and claim tips for
     * @param orders - the list of orders to filter by filled and calculate the total tips
     * @returns an array of arrays of instructions to close and claim tips for all filled orders -
     * this should be used as multiple transactions
     */
    getCloseAndClaimTipsForFilledOrdersTxsIxs(maker, orders, batchSize = exports.MAX_CLOSE_ORDER_AND_CLAIM_TIP_ORDERS_IN_TX) {
        let ixsArrays = [];
        ixsArrays.push([]);
        for (const order of orders) {
            if (order.state.status === 1) {
                // Filled
                const orderStateAndAddress = {
                    state: order.state,
                    address: order.address,
                };
                const ixs = this.closeOrderAndClaimTipIx(maker, orderStateAndAddress);
                // Once the batchSize of previous array is hit, create a new array
                if (ixsArrays[ixsArrays.length - 1].length + ixs.length > batchSize) {
                    ixsArrays.push([]);
                }
                ixsArrays[ixsArrays.length - 1].push(...ixs);
            }
        }
        return ixsArrays;
    }
    /**
     * Get the create close order and claim tip instruction
     * @param maker - the maker address
     * @param order - the order state and address
     * @returns the create close order and claim tip instruction
     */
    closeOrderAndClaimTipIx(maker, order, wrapUnwrapSol = true) {
        let ixs = [];
        let closeWsolAtaIxs = [];
        let makerInputAta;
        if (order.state.inputMint.equals(exports.WRAPPED_SOL_MINT)) {
            const { createIxs, fillIxs: _fill, closeIx, ata, } = this.getInitIfNeededWSOLCreateAndCloseIxs(maker, maker, new bn_js_1.default(0));
            makerInputAta = ata;
            if (wrapUnwrapSol) {
                ixs.push(...createIxs);
                closeWsolAtaIxs.push(...closeIx);
            }
        }
        else {
            const { ata, createAtaIx: createMakerInputAta } = (0, utils_1.createAtaIdempotent)(maker, maker, order.state.inputMint, order.state.inputMintProgramId);
            makerInputAta = ata;
            ixs.push(createMakerInputAta);
        }
        ixs.push(limoOperations.closeOrderAndClaimTip({
            maker: maker,
            globalConfig: order.state.globalConfig,
            inputMint: order.state.inputMint,
            outputMint: order.state.outputMint,
            order: order.address,
            programId: this.programId,
            makerInputAta,
            inputTokenProgram: order.state.inputMintProgramId,
        }));
        ixs.push(...closeWsolAtaIxs);
        return ixs;
    }
    /**
     * Close an order and claim tip
     * @param maker - the maker keypair
     * @param order - the order state and address
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param mintDecimals - map of mint addresses and their number of decimals
     * @returns the transaction signature
     */
    async closeOrderAndClaimTip(maker, order, mode, mintDecimals) {
        let ixs = this.closeOrderAndClaimTipIx(maker.publicKey, order);
        let inputMintDecimals;
        let tipMintDecimals;
        if (mintDecimals) {
            inputMintDecimals = mintDecimals.get(order.state.inputMint);
            tipMintDecimals = mintDecimals.get(spl_token_1.NATIVE_MINT);
        }
        inputMintDecimals = inputMintDecimals
            ? inputMintDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, order.state.inputMint);
        tipMintDecimals = tipMintDecimals
            ? tipMintDecimals
            : await (0, utils_1.getMintDecimals)(this._connection, spl_token_1.NATIVE_MINT);
        const log = "Close Order: " +
            order.address.toString() +
            " claiming " +
            (0, utils_1.lamportsToAmountBN)(order.state.remainingInputAmount, inputMintDecimals).toString() +
            " input token ";
        order.state.inputMint.toString().slice(0, 5) +
            " and " +
            (0, utils_1.lamportsToAmountBN)(order.state.tipAmount, tipMintDecimals).toString();
        (" tip ");
        const sig = await this.processTxn(maker, ixs, mode, log, []);
        return sig;
    }
    /**
     * Get the update order instructions - close current order and initialize new order
     * @param order - the order state to close
     * @param user - the user address
     * @param inputMint - the input mint address
     * @param outputMint - the output mint address
     * @param inputAmountLamports - the input amount in lamports
     * @param outputAmountLamports - the output amount in lamports
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param globalConfigOverride - the global config override
     * @returns the create initialize order instruction and keypair to sign the transaction with
     * @throws error if mint decimals not found for mint
     */
    async updateOrderGenericIx(order, user, inputMint, outputMint, inputAmountLamports, outputAmountLamports, inputMintProgramId, outputMintProgramId, globalConfigOverride, wrapUnwrapSol = true) {
        let closeOrderIx = this.closeOrderAndClaimTipIx(user, order, wrapUnwrapSol);
        let [createOrderIx, orderKeypair] = await this.createOrderGenericIx(user, inputMint, outputMint, inputAmountLamports, outputAmountLamports, inputMintProgramId, outputMintProgramId, globalConfigOverride);
        return [[...closeOrderIx, ...createOrderIx], orderKeypair];
    }
    /**
     * Get the update order instructions - close current order and initialize new order
     * @param order - the order state to close
     * @param user - the user keypair
     * @param inputMint - the input mint address
     * @param outputMint - the output mint address
     * @param inputAmountLamports - the input amount in lamports
     * @param outputAmountLamports - the output amount in lamports
     * @param inputMintProgramId - the input mint program id
     * @param outputMintProgramId - the output mint program id
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param globalConfigOverride - the global config override
     * @returns the create initialize order instruction and keypair to sign the transaction with
     * @throws error if mint decimals not found for mint
     */
    async updateOrderGeneric(order, user, inputMint, outputMint, inputAmountLamports, outputAmountLamports, inputMintProgramId, outputMintProgramId, mode = "execute", globalConfigOverride, wrapUnwrapSol = true) {
        const [ixs, orderKp] = await this.updateOrderGenericIx(order, user.publicKey, inputMint, outputMint, inputAmountLamports, outputAmountLamports, inputMintProgramId, outputMintProgramId, globalConfigOverride, wrapUnwrapSol);
        const log = "Update order: " +
            "closing order: " +
            order.toString() +
            " and creating order " +
            orderKp.publicKey.toString();
        const sig = await this.processTxn(user, ixs, mode, log, [orderKp]);
        return [sig, orderKp];
    }
    /**
     * Get the update global config instruction
     * @param admin - the admin address
     * @param mode - the mode to update
     * @param value - the value
     * @param globalConfigOverride - the global config override
     * @returns the update global config instruction
     */
    updateGlobalConfigIx(mode, value, globalConfigOverride) {
        const ixs = [];
        const gc = this.getGlobalConfigStateSync();
        ixs.push(limoOperations.updateGlobalConfigIx(gc.adminAuthority, globalConfigOverride ? globalConfigOverride : this._globalConfig, types_1.UpdateGlobalConfigMode.fromDecoded({ [mode]: "" }), value, this.programId));
        return ixs;
    }
    /**
     * Update the global config
     * @param admin - the admin keypair
     * @param updateMode - the update mode
     * @param value - the value
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature
     */
    async updateGlobalConfig(admin, updateMode, value, mode, globalConfigOverride) {
        await this.getGlobalConfigState();
        const ixs = this.updateGlobalConfigIx(updateMode, value, globalConfigOverride);
        const log = "Update global config: " +
            this._globalConfig.toString() +
            " with mode " +
            updateMode +
            " and value " +
            value.toString();
        console.log("updateGlobalConfig", log);
        const sig = await this.processTxn(admin, ixs, mode, log, []);
        return sig;
    }
    /**
     * Get the update global config admin instruction - should be signed by the current globalConfig.adminAuthorityCached
     * @param globalConfigOverride - the global config override
     * @returns the update global config admin instruction
     */
    async updateGlobalConfigAdminIx(globalConfigOverride) {
        const globalConfigState = globalConfigOverride
            ? await GlobalConfig_1.GlobalConfig.fetch(this._connection, globalConfigOverride)
            : await this.getGlobalConfigState();
        if (!globalConfigState) {
            throw new Error("Global config not found");
        }
        const ix = limoOperations.updateGlobalConfigAdminIx(this._globalConfig, globalConfigState, this.programId);
        return ix;
    }
    /**
     * Update the global config admin
     * @param admin - the admin keypair, should match the current globalConfig.adminAuthorityCached
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature
     */
    async updateGlobalConfigAdmin(admin, mode, globalConfigOverride) {
        const ix = await this.updateGlobalConfigAdminIx(globalConfigOverride);
        const log = "Update global config admin: " +
            this._globalConfig.toString() +
            " with admin " +
            admin.publicKey.toBase58();
        const sig = await this.processTxn(admin, [ix], mode, log, []);
        return sig;
    }
    /**
     * Get the withdraw host tip instruction
     * @param admin - the admin address
     * @param globalConfigOverride - the global config override
     * @returns the withdraw host tip instruction
     */
    withdrawHostTipIx(admin, globalConfigOverride) {
        let ixs = [];
        ixs.push((0, utils_1.withdrawHostTipIx)({
            admin,
            globalConfig: globalConfigOverride
                ? globalConfigOverride
                : this._globalConfig,
            programId: this.programId,
        }));
        return ixs;
    }
    /**
     * Withdraw the host tip
     * @param admin - the admin keypair
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param globalConfigOverride - the global config override
     * @returns the transaction signature
     */
    async withdrawHostTip(admin, mode, globalConfigOverride) {
        const ixs = this.withdrawHostTipIx(admin.publicKey, globalConfigOverride);
        const log = "Withdraw host tip: " +
            this._globalConfig.toString() +
            " with admin " +
            admin.publicKey.toBase58();
        const sig = await this.processTxn(admin, ixs, mode, log, []);
        return ixs;
    }
    /**
     * Get the number of decimals for the order input mint
     * @param order - the order state and address
     * @returns the number of decimals
     */
    async getOrderInputMintDecimals(order) {
        return await (0, utils_1.getMintDecimals)(this._connection, order.state.inputMint);
    }
    /**
     * Get the number of decimals for the order output mint
     * @param order - the order state and address
     * @returns the number of decimals
     */
    async getOrderOutputMintDecimals(order) {
        return await (0, utils_1.getMintDecimals)(this._connection, order.state.outputMint);
    }
    /**
     * Get the number of decimals for given mints array
     * @param mints - an array of mints
     * @returns a PubkeyHashMap of the mints and number of decimals
     */
    async getMintDecimals(mints) {
        const mintDecimals = new utils_1.PubkeyHashMap();
        for (const mint of mints) {
            mintDecimals.set(mint, await (0, utils_1.getMintDecimals)(this._connection, mint));
        }
        return mintDecimals;
    }
    /**
     * Get the number of decimals for all mints in all of the order states
     * @returns a PubkeyHashMap of the mints and number of decimals
     */
    async getAllMintDecimals() {
        const allOrders = await this.getAllOrdersStateAndAddressWithFilters([], undefined, false);
        const mints = [];
        for (const order of allOrders) {
            mints.push(order.state.inputMint);
            mints.push(order.state.outputMint);
        }
        return await this.getMintDecimals(mints);
    }
    async getMintsProgramOwners(mints) {
        const mintAccounts = await this._connection.getMultipleAccountsInfo(mints);
        const mintProgramIds = mintAccounts.map((mintAccount) => {
            if (!mintAccount) {
                throw new Error("Mint not found");
            }
            return mintAccount.owner;
        });
        return mintProgramIds;
    }
    /**
     * Execute a transaction
     * @param ix - the transaction instructions
     * @param signer - the signer keypair
     * @param extraSigners - the extra signers
     * @returns the transaction signature
     */
    async executeTransaction(ix, signer, extraSigners = []) {
        const tx = new web3_js_1.Transaction();
        const { blockhash } = await this._connection.getLatestBlockhash();
        tx.recentBlockhash = blockhash;
        tx.feePayer = signer.publicKey;
        tx.add(...ix);
        const sig = await (0, web3_js_1.sendAndConfirmTransaction)(this._connection, tx, [signer, ...extraSigners], { commitment: "confirmed" });
        return sig;
    }
    /**
     * Process a transaction based on the execution mode
     * @param admin - the admin keypair
     * @param ixs - the transaction instructions
     * @param mode - the execution mode (simulate/execute/multisig)
     * @param debugMessage - the debug message
     * @param extraSigners - the extra signers
     * @param computeUnits - the number of compute units
     * @param priorityFeeLamports - the priority fee in lamports
     * @returns the transaction signature
     */
    async processTxn(admin, ixs, mode, debugMessage, extraSigners, computeUnits = 200_000, priorityFeeLamports = 10000) {
        if (mode === "multisig" || mode === "simulate") {
            console.log("asdsa");
            const { blockhash } = await this._connection.getLatestBlockhash();
            const txn = new web3_js_1.Transaction();
            txn.add(...ixs);
            txn.recentBlockhash = blockhash;
            txn.feePayer = admin.publicKey;
            // if simulate is true, always simulate
            if (mode === "simulate") {
                await (0, utils_1.printSimulateTx)(this._connection, txn);
            }
            else {
                // if simulate is false (multisig is true)
                await (0, utils_1.printMultisigTx)(txn);
            }
            return "";
        }
        else if (mode === "execute") {
            const microLamport = priorityFeeLamports * 10 ** 6; // 1000 lamports
            const microLamportsPrioritizationFee = microLamport / computeUnits;
            const priorityFeeIxs = (0, utils_1.createAddExtraComputeUnitFeeTransaction)(computeUnits, microLamportsPrioritizationFee);
            const sig = await this.executeTransaction([...priorityFeeIxs, ...ixs], admin, extraSigners);
            if (process.env.DEBUG === "true" && debugMessage) {
                console.log(debugMessage);
                console.log("txn: " + sig.toString());
            }
            return sig;
        }
        console.log(debugMessage);
        return "";
    }
    /**
     * Get the wsol create fill and close ixs for a given owner and payer
     * @param owner - the owner address
     * @param payer - the payer address
     * @param amountToDepositLamports - the amount to deposit in lamports
     * @returns the create, fill, and close instructions, toghether with the ata
     */
    getInitIfNeededWSOLCreateAndCloseIxs(owner, payer, amountToDepositLamports) {
        const createIxs = [];
        const { ata, createAtaIx } = (0, utils_1.createAtaIdempotent)(owner, payer, exports.WRAPPED_SOL_MINT, spl_token_1.TOKEN_PROGRAM_ID);
        createIxs.push(createAtaIx);
        const fillIxs = [];
        if (amountToDepositLamports && payer.equals(owner)) {
            fillIxs.push(...this.getDepositWsolIxns(owner, ata, amountToDepositLamports));
        }
        const closeWsolAtaIxn = [];
        if (payer.equals(owner)) {
            closeWsolAtaIxn.push((0, spl_token_2.createCloseAccountInstruction)(ata, owner, owner, [], spl_token_1.TOKEN_PROGRAM_ID));
        }
        return {
            createIxs: createIxs,
            fillIxs: fillIxs,
            closeIx: closeWsolAtaIxn,
            ata,
        };
    }
    /**
     * Get the deposit WSOL instructions
     * @param owner - the owner address
     * @param ata - the ata address
     * @param amountLamports - the amount in lamports
     * @returns the transaction instructions
     */
    getDepositWsolIxns(owner, ata, amountLamports) {
        const ixns = [];
        // Transfer to WSOL ata
        ixns.push(web3_js_1.SystemProgram.transfer({
            fromPubkey: owner,
            toPubkey: ata,
            lamports: BigInt(amountLamports.toString()),
        }));
        // Sync wrapped SOL
        ixns.push(new web3_js_1.TransactionInstruction({
            keys: [
                {
                    pubkey: ata,
                    isSigner: false,
                    isWritable: true,
                },
            ],
            data: Buffer.from(new Uint8Array([17])),
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }));
        return ixns;
    }
}
exports.LimoClient = LimoClient;
//# sourceMappingURL=Limo.js.map