import { PublicKey } from "@solana/web3.js";
import BN from "bn.js";
export declare const NULL_PUBKEY: PublicKey;
/**
 * Helper function to check if a configured pubkey is null or default.
 * @param pubkey
 * @returns {boolean}
 */
export declare function isNotNullPubkey(pubkey: PublicKey): boolean;
/**
 * Custom set implementation for PublicKey
 * Calling toString() on a PublicKey is pretty slow and pubkeys do not support `SameValueZero` comparison, so we use a custom set implementation where keys are compared with `PublicKey.equals(PublicKey)`
 */
export declare class PublicKeySet<T extends PublicKey> {
    private items;
    constructor(items: Array<T>);
    add(item: T): void;
    contains(item: T): boolean;
    private equals;
    isEmpty(): boolean;
    toArray(): T[];
}
/**
 * Custom map implementation for PublicKey, backed by a list for o(n) lookup speed
 * Calling toString() on a PublicKey is pretty slow and pubkeys do not support `SameValueZero` comparison, so we use a custom map implementation where keys are compared with `PublicKey.equals(PublicKey)`
 */
export declare class PublicKeyMap<K extends PublicKey, V> {
    private record;
    set(key: K, value: V): void;
    get(key: K): V | undefined;
    has(key: K): boolean;
    delete(key: K): void;
    private findIndex;
    clear(): void;
    forEach(callback: (value: V, key: K) => void): void;
    keys(): K[];
    values(): V[];
    entries(): [K, V][];
    isEmpty(): boolean;
}
/**
 * Custom map implementation for PublicKey, backed by a hashmap for o(1) lookup speed
 * Calling toString() on a PublicKey is pretty slow and pubkeys do not support `SameValueZero` comparison, so we use a custom map implementation where keys are compared with `PublicKey.equals(PublicKey)`, and a hash is derived from the final 32 bits of the public key
 */
export declare class PubkeyHashMap<K extends PublicKey, V> implements Map<K, V> {
    private buckets;
    size: number;
    constructor(entries?: readonly (readonly [K, V])[] | null);
    [Symbol.iterator](): IterableIterator<[K, V]>;
    [Symbol.toStringTag]: string;
    set(key: K, value: V): this;
    get(key: K): V | undefined;
    has(key: K): boolean;
    delete(key: K): boolean;
    clear(): void;
    isEmpty(): boolean;
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
    keys(): IterableIterator<K>;
    values(): IterableIterator<V>;
    entries(): IterableIterator<[K, V]>;
}
export declare class HashablePublicKey extends PublicKey implements IEquality<HashablePublicKey> {
    static MASK: BN;
    constructor(value: PublicKey | string | Buffer | Uint8Array | Array<number>);
    hashCode(): number;
    private getBN;
}
interface IEquality<T extends IEquality<T>> {
    equals(other: T): boolean;
    hashCode(): number;
}
export {};
//# sourceMappingURL=pubkey.d.ts.map