import * as anchor from "@coral-xyz/anchor";
import { Connection, Keypair, PublicKey, TransactionInstruction, Transaction, Signer, TransactionSignature } from "@solana/web3.js";
import { Decimal } from "decimal.js";
import * as web3 from "@solana/web3.js";
import { Env } from "./setup";
import { LimoClient } from "../Limo";
import { GlobalConfig } from "../rpc_client/accounts/GlobalConfig";
import BN from "bn.js";
export declare const LimoIdl: anchor.Idl;
export declare const WAD: Decimal;
export declare const DEFAULT_TXN_FEE_LAMPORTS = 5000;
export interface GlobalAccounts {
    globalAdmin: Keypair;
    globalConfig: Keypair;
    pdaAuthority: PublicKey;
    tokens: Map<string, TokenInfo>;
    vaults: Map<string, PublicKey>;
    limoClient: LimoClient;
}
export declare class TokenInfo {
    symbol: string;
    mint: PublicKey;
    mintDecimals: number;
    constructor(symbol: string, mint: PublicKey, mintDecimal: number);
}
export interface UserAccounts {
    owner: Keypair;
    tokenAtas: Map<string, PublicKey>;
}
export declare function getLimoProgramId(cluster: string): anchor.web3.PublicKey;
export declare function parseKeypairFile(file: string): Keypair;
export declare function divCeil(a: BN, b: BN): BN;
export declare function amountToLamportsBN(amount: Decimal, decimals: number): BN;
export declare function amountToLamportsDecimal(amount: Decimal, decimals: number): Decimal;
export declare function lamportsToAmountBN(amount: BN, decimals: number): Decimal;
export declare function lamportsToAmountDecimal(amount: Decimal, decimals: number): Decimal;
export declare function createMint(provider: anchor.AnchorProvider, authority: PublicKey, decimals?: number): Promise<PublicKey>;
export declare function createMintFromKeypair(provider: anchor.AnchorProvider, authority: PublicKey, mint: Keypair, decimals?: number): Promise<PublicKey>;
export declare function getMintDecimals(connection: Connection, mint: PublicKey): Promise<number>;
export declare function getMintsProgramOwner(connection: Connection, mint: PublicKey): Promise<PublicKey>;
export declare function printMultisigTx(tx: Transaction): Promise<void>;
export declare function printSimulateTx(conn: Connection, tx: Transaction): Promise<void>;
export declare function solAirdrop(provider: anchor.AnchorProvider, account: PublicKey, solAirdrop: Decimal): Promise<Decimal>;
export declare function solAirdropMin(provider: anchor.AnchorProvider, account: PublicKey, minSolAirdrop: Decimal): Promise<Decimal>;
export declare function checkIfAccountExists(connection: Connection, account: PublicKey): Promise<boolean>;
export declare function getAssociatedTokenAddress(owner: PublicKey, tokenMintAddress: PublicKey, tokenProgram: PublicKey): PublicKey;
export declare function createAssociatedTokenAccountIdempotentInstruction(owner: PublicKey, mint: PublicKey, payer: PublicKey | undefined, tokenProgram: PublicKey, ata?: PublicKey): [PublicKey, TransactionInstruction];
export declare function createAtaIdempotent(user: PublicKey, payer: PublicKey, mint: PublicKey, mintTokenProgram: PublicKey): {
    ata: PublicKey;
    createAtaIx: TransactionInstruction;
};
export declare function setupAta(provider: anchor.AnchorProvider, tokenMintAddress: PublicKey, payer: Keypair, owner?: PublicKey): Promise<PublicKey>;
export declare function mintTo(provider: anchor.AnchorProvider, mintPubkey: PublicKey, tokenAccount: PublicKey, amount: number, decimals: number): Promise<void>;
export declare function getMockSwapInstructions(provider: anchor.AnchorProvider, user: PublicKey, swapInputMint: PublicKey, swapOutputMint: PublicKey, swapInAmountDecimal: Decimal, swapOutAmountDecimal: Decimal, inTokenDecimals: number, outTokenDecimals: number): anchor.web3.TransactionInstruction[];
export declare function transferToken(provider: anchor.AnchorProvider, fromAccount: Signer, fromTokenAccount: PublicKey, toTokenAccount: PublicKey, amount: number): Promise<void>;
/**
 * Get the custom program error code if there's any in the error message and return parsed error code hex to number string
 * @param errMessage string - error message that would contain the word "custom program error:" if it's a customer program error
 * @returns [boolean, string] - probably not a custom program error if false otherwise the second element will be the code number in string
 */
export declare const getCustomProgramErrorCode: (errMessage: string) => [boolean, string];
/**
 *
 * Maps the private Anchor type ProgramError to a normal Error.
 * Pass ProgramErr.msg as the Error message so that it can be used with chai matchers
 *
 * @param fn - function which may throw an anchor ProgramError
 */
export declare function mapAnchorError<T>(fn: Promise<T>): Promise<T>;
export declare function getTokenAccountBalance(conn: Connection, tokenAccount: PublicKey): Promise<Decimal>;
export declare function createAddExtraComputeUnitFeeTransaction(units: number, microLamports: number): TransactionInstruction[];
export declare function getSolBalanceInLamports(provider: anchor.AnchorProvider, account: PublicKey): Promise<number>;
export declare function getSolBalance(provider: anchor.AnchorProvider, account: PublicKey): Promise<Decimal>;
export type Cluster = "localnet" | "devnet" | "mainnet";
export type SolEnv = {
    cluster: Cluster;
    ownerKeypairPath: string;
    endpoint: string;
};
export declare function endpointFromCluster(cluster: string | undefined): string;
export declare function pubkeyFromFile(filepath: string): PublicKey;
export declare function createAddExtraComputeUnitsTransaction(units: number): TransactionInstruction;
export declare function u16ToBytes(num: number): Uint8Array<ArrayBuffer>;
export declare function accountExist(connection: anchor.web3.Connection, account: anchor.web3.PublicKey): Promise<boolean>;
export declare function fetchGlobalConfigWithRetry(env: Env, address: PublicKey): Promise<GlobalConfig>;
export declare function getPdaAuthority(programId: PublicKey, globalConfig: PublicKey): PublicKey;
export declare function getTokenVaultPDA(programId: PublicKey, globalConfig: PublicKey, mint: PublicKey): PublicKey;
export declare function getEventAuthorityPDA(programId: PublicKey): PublicKey;
export declare function getUserSwapBalanceStatePDA(maker: PublicKey, programId: PublicKey): PublicKey;
export declare function getIntermediaryTokenAccountPDA(programId: PublicKey, order: PublicKey): PublicKey;
export declare function getExpressRelayMetadataPDA(programId: PublicKey): PublicKey;
export declare function getExpressRelayConfigRouterPDA(programId: PublicKey, router: PublicKey): PublicKey;
export declare function sendAndConfirmInstructions(env: Env, ixns: [TransactionInstruction]): Promise<web3.TransactionSignature>;
export declare function createKeypairRentExempt(provider: anchor.AnchorProvider, programId: PublicKey, address: Keypair, size: number): Promise<web3.Keypair>;
export declare function getOrderRentExemptLamports(connection: Connection): Promise<number>;
export declare function createKeypairRentExemptIxSync(payer: PublicKey, account: Keypair, size: number, lamports: number, programId?: PublicKey): TransactionInstruction;
export declare function createGlobalConfigPublicKeyRentExempt(provider: anchor.AnchorProvider, programId: PublicKey): Promise<Keypair>;
export declare function executeTransaction(connection: Connection, ix: TransactionInstruction[], signer: Keypair, extraSigners?: Signer[]): Promise<TransactionSignature>;
export declare function buildAndSendTxnWithLogs(c: Connection, tx: Transaction, owner: Keypair, signers: Signer[]): Promise<void>;
export declare function sleep(ms: number): Promise<unknown>;
export declare function scaleDownWads(value: anchor.BN): number;
export declare function convertStakeToAmount(stake: Decimal, totalStaked: Decimal, totalAmount: Decimal): Decimal;
export declare function convertAmountToStake(amount: Decimal, totalStaked: Decimal, totalAmount: Decimal): Decimal;
export declare const parseTokenSymbol: (tokenSymbol: number[]) => string;
//# sourceMappingURL=utils.d.ts.map