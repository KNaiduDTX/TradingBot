"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTokenSymbol = exports.getCustomProgramErrorCode = exports.TokenInfo = exports.DEFAULT_TXN_FEE_LAMPORTS = exports.WAD = exports.LimoIdl = void 0;
exports.getLimoProgramId = getLimoProgramId;
exports.parseKeypairFile = parseKeypairFile;
exports.divCeil = divCeil;
exports.amountToLamportsBN = amountToLamportsBN;
exports.amountToLamportsDecimal = amountToLamportsDecimal;
exports.lamportsToAmountBN = lamportsToAmountBN;
exports.lamportsToAmountDecimal = lamportsToAmountDecimal;
exports.createMint = createMint;
exports.createMintFromKeypair = createMintFromKeypair;
exports.getMintDecimals = getMintDecimals;
exports.getMintsProgramOwner = getMintsProgramOwner;
exports.printMultisigTx = printMultisigTx;
exports.printSimulateTx = printSimulateTx;
exports.solAirdrop = solAirdrop;
exports.solAirdropMin = solAirdropMin;
exports.checkIfAccountExists = checkIfAccountExists;
exports.getAssociatedTokenAddress = getAssociatedTokenAddress;
exports.createAssociatedTokenAccountIdempotentInstruction = createAssociatedTokenAccountIdempotentInstruction;
exports.createAtaIdempotent = createAtaIdempotent;
exports.setupAta = setupAta;
exports.mintTo = mintTo;
exports.getMockSwapInstructions = getMockSwapInstructions;
exports.transferToken = transferToken;
exports.mapAnchorError = mapAnchorError;
exports.getTokenAccountBalance = getTokenAccountBalance;
exports.createAddExtraComputeUnitFeeTransaction = createAddExtraComputeUnitFeeTransaction;
exports.getSolBalanceInLamports = getSolBalanceInLamports;
exports.getSolBalance = getSolBalance;
exports.endpointFromCluster = endpointFromCluster;
exports.pubkeyFromFile = pubkeyFromFile;
exports.createAddExtraComputeUnitsTransaction = createAddExtraComputeUnitsTransaction;
exports.u16ToBytes = u16ToBytes;
exports.accountExist = accountExist;
exports.fetchGlobalConfigWithRetry = fetchGlobalConfigWithRetry;
exports.getPdaAuthority = getPdaAuthority;
exports.getTokenVaultPDA = getTokenVaultPDA;
exports.getEventAuthorityPDA = getEventAuthorityPDA;
exports.getUserSwapBalanceStatePDA = getUserSwapBalanceStatePDA;
exports.getIntermediaryTokenAccountPDA = getIntermediaryTokenAccountPDA;
exports.getExpressRelayMetadataPDA = getExpressRelayMetadataPDA;
exports.getExpressRelayConfigRouterPDA = getExpressRelayConfigRouterPDA;
exports.sendAndConfirmInstructions = sendAndConfirmInstructions;
exports.createKeypairRentExempt = createKeypairRentExempt;
exports.getOrderRentExemptLamports = getOrderRentExemptLamports;
exports.createKeypairRentExemptIxSync = createKeypairRentExemptIxSync;
exports.createGlobalConfigPublicKeyRentExempt = createGlobalConfigPublicKeyRentExempt;
exports.executeTransaction = executeTransaction;
exports.buildAndSendTxnWithLogs = buildAndSendTxnWithLogs;
exports.sleep = sleep;
exports.scaleDownWads = scaleDownWads;
exports.convertStakeToAmount = convertStakeToAmount;
exports.convertAmountToStake = convertAmountToStake;
const anchor = __importStar(require("@coral-xyz/anchor"));
const fs = __importStar(require("fs"));
const LimoErrors = __importStar(require("../rpc_client/errors"));
const web3_js_1 = require("@solana/web3.js");
const decimal_js_1 = require("decimal.js");
const spl_token_1 = require("@solana/spl-token");
const web3 = __importStar(require("@solana/web3.js"));
const limo_json_1 = __importDefault(require("../rpc_client/limo.json"));
const Limo_1 = require("../Limo");
const GlobalConfig_1 = require("../rpc_client/accounts/GlobalConfig");
const programId_1 = require("../rpc_client/programId");
// @ts-ignore
const base58_js_1 = require("base58-js");
const accounts_1 = require("../rpc_client/accounts");
const bn_js_1 = __importDefault(require("bn.js"));
exports.LimoIdl = limo_json_1.default;
exports.WAD = new decimal_js_1.Decimal("1".concat(Array(18 + 1).join("0")));
exports.DEFAULT_TXN_FEE_LAMPORTS = 5000;
const ESCROW_VAULT_SEED = "escrow_vault";
const GLOBAL_AUTH_SEED = "authority";
const EXPRESS_RELAY_MEATADATA_SEED = "metadata";
const EXPRESS_RELAY_CONFIG_ROUTER_SEED = "config_router";
const INTERMEDIARY_OUTPUT_TOKEN_ACCOUNT_SEED = "intermediary";
const EVENT_AUTHORITY_SEED = "__event_authority";
class TokenInfo {
    symbol;
    mint;
    mintDecimals;
    constructor(symbol, mint, mintDecimal) {
        this.symbol = symbol;
        this.mint = mint;
        this.mintDecimals = mintDecimal;
    }
}
exports.TokenInfo = TokenInfo;
function getLimoProgramId(cluster) {
    return programId_1.PROGRAM_ID;
}
function parseKeypairFile(file) {
    return web3_js_1.Keypair.fromSecretKey(new Uint8Array(JSON.parse(require("fs").readFileSync(file))));
}
function divCeil(a, b) {
    return a.add(b).sub(new bn_js_1.default(1)).div(b);
}
function amountToLamportsBN(amount, decimals) {
    let factor = Math.pow(10, decimals);
    return new bn_js_1.default(amount.mul(factor).floor().toString());
}
function amountToLamportsDecimal(amount, decimals) {
    let factor = Math.pow(10, decimals);
    return amount.mul(factor);
}
function lamportsToAmountBN(amount, decimals) {
    let factor = new bn_js_1.default(Math.pow(10, decimals));
    return new decimal_js_1.Decimal(amount.div(factor).toString());
}
function lamportsToAmountDecimal(amount, decimals) {
    let factor = Math.pow(10, decimals);
    return amount.div(factor);
}
async function createMint(provider, authority, decimals = 6) {
    const mint = anchor.web3.Keypair.generate();
    return await createMintFromKeypair(provider, authority, mint, decimals);
}
async function createMintFromKeypair(provider, authority, mint, decimals = 6) {
    const instructions = await createMintInstructions(provider, authority, mint.publicKey, decimals);
    console.log("Mint auth", authority.toString());
    const tx = new anchor.web3.Transaction();
    tx.add(...instructions);
    await provider.sendAndConfirm(tx, [mint]);
    return mint.publicKey;
}
async function getMintDecimals(connection, mint) {
    const mintProgramOwner = await getMintsProgramOwner(connection, mint);
    let info = await (0, spl_token_1.getMint)(connection, mint, connection.commitment, mintProgramOwner);
    return info.decimals;
}
async function getMintsProgramOwner(connection, mint) {
    const mintAccount = await connection.getAccountInfo(mint);
    if (!mintAccount) {
        throw new Error("Mint not found");
    }
    return mintAccount.owner;
}
async function createMintInstructions(provider, authority, mint, decimals) {
    return [
        anchor.web3.SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            newAccountPubkey: mint,
            space: 82,
            lamports: await provider.connection.getMinimumBalanceForRentExemption(82),
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }),
        (0, spl_token_1.createInitializeMintInstruction)(mint, decimals, authority, null, spl_token_1.TOKEN_PROGRAM_ID),
    ];
}
async function printMultisigTx(tx) {
    console.log((0, base58_js_1.binary_to_base58)(tx.serializeMessage()));
}
async function printSimulateTx(conn, tx) {
    console.log("Tx in B64", `https://explorer.solana.com/tx/inspector?message=${encodeURIComponent(tx.serializeMessage().toString("base64"))}`);
    let res = await conn.simulateTransaction(tx);
    console.log("Simulate Response", res);
    console.log("");
}
async function solAirdrop(provider, account, solAirdrop) {
    const airdropTxnId = await provider.connection.requestAirdrop(account, amountToLamportsDecimal(solAirdrop, 9).toNumber());
    await provider.connection.confirmTransaction(airdropTxnId);
    return await getSolBalance(provider, account);
}
async function solAirdropMin(provider, account, minSolAirdrop) {
    const airdropBatchAmount = decimal_js_1.Decimal.max(50, minSolAirdrop);
    let currentBalance = await getSolBalance(provider, account);
    while (currentBalance.lt(minSolAirdrop)) {
        try {
            await provider.connection.requestAirdrop(account, amountToLamportsDecimal(airdropBatchAmount, 9).toNumber());
        }
        catch (e) {
            await sleep(100);
            console.log("Error", e);
        }
        await sleep(100);
        currentBalance = await getSolBalance(provider, account);
    }
    return currentBalance;
}
async function checkIfAccountExists(connection, account) {
    return (await connection.getAccountInfo(account)) != null;
}
function getAssociatedTokenAddress(owner, tokenMintAddress, tokenProgram) {
    return (0, spl_token_1.getAssociatedTokenAddressSync)(tokenMintAddress, owner, true, tokenProgram, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
}
function createAssociatedTokenAccountIdempotentInstruction(owner, mint, payer = owner, tokenProgram, ata) {
    let ataAddress = ata;
    if (!ataAddress) {
        ataAddress = getAssociatedTokenAddress(owner, mint, tokenProgram);
    }
    const createUserTokenAccountIx = (0, spl_token_1.createAssociatedTokenAccountInstruction)(payer, ataAddress, owner, mint, tokenProgram, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
    // idempotent ix discriminator is 1
    createUserTokenAccountIx.data = Buffer.from([1]);
    return [ataAddress, createUserTokenAccountIx];
}
function createAtaIdempotent(user, payer, mint, mintTokenProgram) {
    const [ata, createAtaIx] = createAssociatedTokenAccountIdempotentInstruction(user, mint, payer, mintTokenProgram);
    return { ata, createAtaIx };
}
async function setupAta(provider, tokenMintAddress, payer, owner = payer.publicKey) {
    const ata = getAssociatedTokenAddress(owner, tokenMintAddress, spl_token_1.TOKEN_PROGRAM_ID);
    if (!(await checkIfAccountExists(provider.connection, ata))) {
        const [, ix] = createAssociatedTokenAccountIdempotentInstruction(owner, tokenMintAddress, payer.publicKey, spl_token_1.TOKEN_PROGRAM_ID, ata);
        const tx = new web3_js_1.Transaction().add(ix);
        await provider.sendAndConfirm(tx, [payer]);
    }
    return ata;
}
async function mintTo(provider, mintPubkey, tokenAccount, amount, decimals) {
    const tx = new web3_js_1.Transaction().add((0, spl_token_1.createMintToCheckedInstruction)(mintPubkey, // mint
    tokenAccount, // receiver (sholud be a token account)
    provider.wallet.publicKey, // mint authority
    amount, // amount. if your decimals is 8, you mint 10^8 for 1 token.
    decimals));
    await provider.sendAndConfirm(tx, [], {
        skipPreflight: true,
    });
}
function getMockSwapInstructions(provider, user, swapInputMint, swapOutputMint, swapInAmountDecimal, swapOutAmountDecimal, inTokenDecimals, outTokenDecimals) {
    let mintToIx = [];
    if (swapOutputMint.equals(Limo_1.WRAPPED_SOL_MINT)) {
        // transfer WSOL to user
        mintToIx.push(web3_js_1.SystemProgram.transfer({
            fromPubkey: provider.wallet.publicKey,
            toPubkey: getAssociatedTokenAddress(user, swapOutputMint, spl_token_1.TOKEN_PROGRAM_ID),
            lamports: amountToLamportsDecimal(swapOutAmountDecimal, outTokenDecimals).toNumber(),
        }));
        mintToIx.push(new web3_js_1.TransactionInstruction({
            keys: [
                {
                    pubkey: getAssociatedTokenAddress(user, swapOutputMint, spl_token_1.TOKEN_PROGRAM_ID),
                    isSigner: false,
                    isWritable: true,
                },
            ],
            data: Buffer.from(new Uint8Array([17])),
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }));
    }
    else {
        mintToIx.push((0, spl_token_1.createMintToCheckedInstruction)(swapOutputMint, // mint
        getAssociatedTokenAddress(user, swapOutputMint, spl_token_1.TOKEN_PROGRAM_ID), provider.wallet.publicKey, // mint authority
        amountToLamportsDecimal(swapOutAmountDecimal, outTokenDecimals).toNumber(), outTokenDecimals));
    }
    let burnIx = [];
    if (swapInputMint.equals(Limo_1.WRAPPED_SOL_MINT)) {
        burnIx.push((0, spl_token_1.createCloseAccountInstruction)(getAssociatedTokenAddress(user, swapInputMint, spl_token_1.TOKEN_PROGRAM_ID), user, user, [], spl_token_1.TOKEN_PROGRAM_ID)); // close WSOL ATA so sol is back to native
        burnIx.push(web3_js_1.SystemProgram.transfer({
            fromPubkey: user,
            toPubkey: provider.wallet.publicKey,
            lamports: amountToLamportsDecimal(swapInAmountDecimal, inTokenDecimals).toNumber(),
        }));
        burnIx.push(createAtaIdempotent(user, provider.wallet.publicKey, Limo_1.WRAPPED_SOL_MINT, spl_token_1.TOKEN_PROGRAM_ID).createAtaIx); //reinitialise WSOL ATA as this is supposed to exist
    }
    else {
        burnIx.push((0, spl_token_1.createBurnInstruction)(getAssociatedTokenAddress(user, swapInputMint, spl_token_1.TOKEN_PROGRAM_ID), swapInputMint, user, amountToLamportsDecimal(swapInAmountDecimal, inTokenDecimals).toNumber()));
    }
    return [...burnIx, ...mintToIx];
}
async function transferToken(provider, fromAccount, fromTokenAccount, toTokenAccount, amount) {
    let tx = new web3_js_1.Transaction().add((0, spl_token_1.createTransferInstruction)(fromTokenAccount, toTokenAccount, fromAccount.publicKey, amount, [], spl_token_1.TOKEN_PROGRAM_ID));
    await web3.sendAndConfirmTransaction(provider.connection, tx, [fromAccount]);
    await sleep(500);
}
/**
 * Get the custom program error code if there's any in the error message and return parsed error code hex to number string
 * @param errMessage string - error message that would contain the word "custom program error:" if it's a customer program error
 * @returns [boolean, string] - probably not a custom program error if false otherwise the second element will be the code number in string
 */
const getCustomProgramErrorCode = (errMessage) => {
    const index = errMessage.indexOf("Custom program error:");
    if (index === -1) {
        return [false, "May not be a custom program error"];
    }
    else {
        return [
            true,
            `${parseInt(errMessage.substring(index + 22, index + 28).replace(" ", ""), 16)}`,
        ];
    }
};
exports.getCustomProgramErrorCode = getCustomProgramErrorCode;
/**
 *
 * Maps the private Anchor type ProgramError to a normal Error.
 * Pass ProgramErr.msg as the Error message so that it can be used with chai matchers
 *
 * @param fn - function which may throw an anchor ProgramError
 */
async function mapAnchorError(fn) {
    try {
        return await fn;
    }
    catch (e) {
        let [isCustomProgramError, errorCode] = (0, exports.getCustomProgramErrorCode)(JSON.stringify(e));
        if (isCustomProgramError) {
            let error;
            if (Number(errorCode)) {
                error = LimoErrors.fromCode(Number(errorCode));
                throw new Error(error);
            }
            else if (Number(errorCode) >= 6000 && Number(errorCode) <= 7000) {
                errorCode[errorCode.length - 2] === "0"
                    ? (errorCode = errorCode.slice(-1))
                    : (errorCode = errorCode.slice(-2));
                // @ts-ignore
                error = exports.LimoIdl.errors[errorCode].msg;
                throw new Error(error);
            }
            else {
                throw new Error(e);
            }
        }
        throw e;
    }
}
async function getTokenAccountBalance(conn, tokenAccount) {
    const tokenAccountBalance = await conn.getTokenAccountBalance(tokenAccount);
    return new decimal_js_1.Decimal(tokenAccountBalance.value.amount).div(decimal_js_1.Decimal.pow(10, tokenAccountBalance.value.decimals));
}
function createAddExtraComputeUnitFeeTransaction(units, microLamports) {
    const ixs = [];
    ixs.push(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units }));
    ixs.push(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
        microLamports: Number(microLamports.toFixed(0)),
    }));
    return ixs;
}
async function getSolBalanceInLamports(provider, account) {
    let balance = undefined;
    while (balance === undefined) {
        balance = (await provider.connection.getAccountInfo(account))?.lamports;
    }
    return balance;
}
async function getSolBalance(provider, account) {
    const balance = new decimal_js_1.Decimal(await getSolBalanceInLamports(provider, account));
    return lamportsToAmountDecimal(balance, 9);
}
function endpointFromCluster(cluster) {
    switch (cluster) {
        case "mainnet":
            return "FIXTHIS";
        case "devnet":
            return "FIXTHIS";
        case "localnet":
            return "http://127.0.0.1:8899";
    }
    if (cluster) {
        return cluster;
    }
    return "err";
}
function pubkeyFromFile(filepath) {
    const fileContents = fs.readFileSync(filepath, "utf8");
    const privateArray = fileContents
        .replace("[", "")
        .replace("]", "")
        .split(",")
        .map(function (item) {
        return parseInt(item, 10);
    });
    const array = Uint8Array.from(privateArray);
    const keypair = web3_js_1.Keypair.fromSecretKey(array);
    return keypair.publicKey;
}
function createAddExtraComputeUnitsTransaction(units) {
    return web3.ComputeBudgetProgram.setComputeUnitLimit({ units });
}
function u16ToBytes(num) {
    const arr = new ArrayBuffer(2);
    const view = new DataView(arr);
    view.setUint16(0, num, false);
    return new Uint8Array(arr);
}
async function accountExist(connection, account) {
    const info = await connection.getAccountInfo(account);
    if (info === null || info.data.length === 0) {
        return false;
    }
    return true;
}
async function fetchGlobalConfigWithRetry(env, address) {
    return fetchWithRetry(async () => await GlobalConfig_1.GlobalConfig.fetch(env.conn, address), address);
}
function getPdaAuthority(programId, globalConfig) {
    const [pdaAuthority, _pdaAuthorityBump] = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(GLOBAL_AUTH_SEED), globalConfig.toBuffer()], programId);
    return pdaAuthority;
}
function getTokenVaultPDA(programId, globalConfig, mint) {
    const [vault, _vaultBump] = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(ESCROW_VAULT_SEED), globalConfig.toBuffer(), mint.toBuffer()], programId);
    return vault;
}
function getEventAuthorityPDA(programId) {
    const [eventAuthority, _eventAuthorityBump] = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(EVENT_AUTHORITY_SEED)], programId);
    return eventAuthority;
}
function getUserSwapBalanceStatePDA(maker, programId) {
    const [swapBalanceState, _swapBalanceStateBump] = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from("balances"), maker.toBuffer()], programId);
    return swapBalanceState;
}
function getIntermediaryTokenAccountPDA(programId, order) {
    const [intermediaryTokenAccount, _intermediaryTokenAccount] = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(INTERMEDIARY_OUTPUT_TOKEN_ACCOUNT_SEED), order.toBuffer()], programId);
    return intermediaryTokenAccount;
}
function getExpressRelayMetadataPDA(programId) {
    const [metadata, _metadataBump] = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(EXPRESS_RELAY_MEATADATA_SEED)], programId);
    return metadata;
}
function getExpressRelayConfigRouterPDA(programId, router) {
    const [configRouter, _configRouterBump] = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(EXPRESS_RELAY_CONFIG_ROUTER_SEED), router.toBuffer()], programId);
    return configRouter;
}
async function fetchWithRetry(fetch, address, retries = 3) {
    for (let i = 0; i < retries; i++) {
        let resp = await fetch();
        if (resp !== null) {
            return resp;
        }
        console.log(`[${i + 1}/${retries}] Fetched account ${address} is null. Refetching...`);
    }
    return null;
}
async function sendAndConfirmInstructions(env, ixns) {
    let tx = new web3_js_1.Transaction();
    for (let i = 0; i < ixns.length; i++) {
        tx.add(ixns[i]);
    }
    let { blockhash } = await env.conn.getLatestBlockhash();
    tx.recentBlockhash = blockhash;
    tx.feePayer = env.admin.publicKey;
    return await web3.sendAndConfirmTransaction(env.conn, tx, [env.admin]);
}
async function createKeypairRentExempt(provider, programId, address, size) {
    const tx = new web3_js_1.Transaction();
    tx.add(createKeypairRentExemptIxSync(provider.wallet.publicKey, address, size, await provider.connection.getMinimumBalanceForRentExemption(size), programId));
    await provider.sendAndConfirm(tx, [address]);
    return address;
}
async function getOrderRentExemptLamports(connection) {
    return await connection.getMinimumBalanceForRentExemption(accounts_1.Order.layout.span + 8);
}
function createKeypairRentExemptIxSync(payer, account, size, lamports, programId = Limo_1.limoId) {
    return web3_js_1.SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: account.publicKey,
        space: size,
        lamports: lamports,
        programId: programId,
    });
}
async function createGlobalConfigPublicKeyRentExempt(provider, programId) {
    const config = web3_js_1.Keypair.generate();
    const key = await createKeypairRentExempt(provider, programId, config, GlobalConfig_1.GlobalConfig.layout.getSpan() + 8);
    return key;
}
async function executeTransaction(connection, ix, signer, extraSigners = []) {
    const tx = new web3_js_1.Transaction();
    const { blockhash } = await connection.getLatestBlockhash();
    tx.recentBlockhash = blockhash;
    tx.feePayer = signer.publicKey;
    tx.add(...ix);
    const sig = await (0, web3_js_1.sendAndConfirmTransaction)(connection, tx, [signer, ...extraSigners], { commitment: "confirmed" });
    return sig;
}
async function buildAndSendTxnWithLogs(c, tx, owner, signers) {
    const { blockhash } = await c.getLatestBlockhash();
    tx.recentBlockhash = blockhash;
    tx.feePayer = owner.publicKey;
    try {
        const sig = await c.sendTransaction(tx, [owner, ...signers]);
        console.log("Transaction Hash:", sig);
        await sleep(5000);
        const res = await c.getTransaction(sig, {
            commitment: "confirmed",
        });
        console.log("Transaction Logs:\n", res.meta.logMessages);
    }
    catch (e) {
        console.log(e);
        await sleep(5000);
        const sig = e.toString().split(" failed ")[0].split("Transaction ")[1];
        const res = await c.getTransaction(sig, {
            commitment: "confirmed",
        });
        console.log("Txn", res.meta.logMessages);
    }
}
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
function scaleDownWads(value) {
    return new decimal_js_1.Decimal(value.toString()).div(exports.WAD).toNumber();
}
function convertStakeToAmount(stake, totalStaked, totalAmount) {
    if (stake === new decimal_js_1.Decimal(0)) {
        return new decimal_js_1.Decimal(0);
    }
    if (totalStaked !== new decimal_js_1.Decimal(0)) {
        return stake.mul(totalAmount).div(totalStaked);
    }
    else {
        return stake.add(totalAmount);
    }
}
function convertAmountToStake(amount, totalStaked, totalAmount) {
    if (amount === new decimal_js_1.Decimal(0)) {
        return new decimal_js_1.Decimal(0);
    }
    if (totalAmount !== new decimal_js_1.Decimal(0)) {
        return totalStaked.mul(amount).div(totalAmount);
    }
    else {
        return amount;
    }
}
const parseTokenSymbol = (tokenSymbol) => {
    return String.fromCharCode(...tokenSymbol.filter((x) => x > 0));
};
exports.parseTokenSymbol = parseTokenSymbol;
//# sourceMappingURL=utils.js.map