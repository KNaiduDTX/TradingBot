"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setUpProgram = setUpProgram;
exports.createGlobalAccounts = createGlobalAccounts;
exports.setGlobalAccounts = setGlobalAccounts;
exports.createUser = createUser;
const web3_js_1 = require("@solana/web3.js");
const anchor = __importStar(require("@coral-xyz/anchor"));
const utils_1 = require("./utils");
const utils_2 = require("./utils");
const decimal_js_1 = __importDefault(require("decimal.js"));
const Limo_1 = require("../Limo");
const spl_token_1 = require("@solana/spl-token");
function setUpProgram(args) {
    // Cluster & admin
    if (!args.clusterOverride) {
        throw new Error("Cluster is required");
    }
    const cluster = args.clusterOverride;
    const config = {
        commitment: anchor.AnchorProvider.defaultOptions().commitment,
        confirmTransactionInitialTimeout: 220000,
    };
    const connection = new web3_js_1.Connection((0, utils_1.endpointFromCluster)(cluster), config);
    const payer = args.adminFilePath
        ? (0, utils_2.parseKeypairFile)(args.adminFilePath)
        : web3_js_1.Keypair.generate();
    // @ts-ignore
    const wallet = new anchor.Wallet(payer);
    const provider = new anchor.AnchorProvider(connection, wallet, anchor.AnchorProvider.defaultOptions());
    const admin = payer;
    anchor.setProvider(provider);
    // Programs
    const limoProgramId = args.programOverride || (0, utils_1.getLimoProgramId)(cluster);
    const program = new anchor.Program(utils_2.LimoIdl, limoProgramId);
    return {
        admin,
        provider,
        conn: connection,
        program,
        cluster: cluster,
    };
}
async function createGlobalAccounts(env, owner = env.admin, tokenSymbols = ["SOL", "USDC", "KMNO"]) {
    const globalConfig = web3_js_1.Keypair.generate();
    const tokenInfos = new Map();
    const tokenVaults = new Map();
    for (const token of tokenSymbols) {
        if (token === "SOL") {
            tokenInfos.set(token, new utils_1.TokenInfo(token, Limo_1.WRAPPED_SOL_MINT, 9));
            let tokenVault = (0, utils_1.getTokenVaultPDA)(env.program.programId, globalConfig.publicKey, Limo_1.WRAPPED_SOL_MINT);
            tokenVaults.set(token, tokenVault);
            (0, utils_1.solAirdrop)(env.provider, owner.publicKey, new decimal_js_1.default(100));
        }
        else {
            const mint = await (0, utils_1.createMint)(env.provider, env.provider.wallet.publicKey, 6);
            let tokenVault = (0, utils_1.getTokenVaultPDA)(env.program.programId, globalConfig.publicKey, mint);
            tokenInfos.set(token, new utils_1.TokenInfo(token, mint, 6));
            tokenVaults.set(token, tokenVault);
            const tokenAta = await (0, utils_1.setupAta)(env.provider, mint, owner);
            await (0, utils_1.mintTo)(env.provider, mint, tokenAta, (0, utils_1.amountToLamportsDecimal)(new decimal_js_1.default(100000.0), 6).toNumber(), 6);
        }
    }
    let pdaAuthority = (0, utils_1.getPdaAuthority)(env.program.programId, globalConfig.publicKey);
    const limoClient = new Limo_1.LimoClient(env.conn, undefined);
    const globalAccounts = {
        globalAdmin: owner,
        globalConfig,
        pdaAuthority,
        tokens: tokenInfos,
        vaults: tokenVaults,
        limoClient,
    };
    (0, utils_1.solAirdrop)(env.provider, pdaAuthority, new decimal_js_1.default(0.1));
    return globalAccounts;
}
async function setGlobalAccounts(env, owner = env.admin, skipInitVaults = false) {
    const globalAccounts = await createGlobalAccounts(env, owner);
    const limoClient = globalAccounts.limoClient;
    await limoClient.createGlobalConfig(globalAccounts.globalAdmin, globalAccounts.globalConfig);
    limoClient.setGlobalConfig(globalAccounts.globalConfig.publicKey);
    if (!skipInitVaults) {
        for (const [, token] of globalAccounts.tokens.entries()) {
            await limoClient.initializeVault(globalAccounts.globalAdmin, token.mint);
        }
    }
    return globalAccounts;
}
async function createUser(env, globalAccounts, tokenAndAirdropAmounts, owner) {
    if (!owner) {
        owner = new anchor.web3.Keypair();
    }
    const userAtas = new Map();
    for (const { token, amount } of tokenAndAirdropAmounts) {
        const tokenInfo = globalAccounts.tokens.get(token);
        userAtas.set(token, (0, utils_1.getAssociatedTokenAddress)(owner.publicKey, tokenInfo.mint, spl_token_1.TOKEN_PROGRAM_ID));
        if (amount.isZero()) {
            continue;
        }
        if (token === "SOL") {
            await (0, utils_1.solAirdrop)(env.provider, owner.publicKey, amount);
            await (0, utils_1.sleep)(1000);
        }
        else {
            const tokenAta = await (0, utils_1.setupAta)(env.provider, tokenInfo.mint, owner);
            await (0, utils_1.mintTo)(env.provider, tokenInfo.mint, tokenAta, (0, utils_1.amountToLamportsDecimal)(amount, tokenInfo.mintDecimals).toNumber(), tokenInfo.mintDecimals);
            await (0, utils_1.sleep)(1000);
        }
    }
    const testingUser = {
        owner,
        tokenAtas: userAtas,
    };
    return testingUser;
}
//# sourceMappingURL=setup.js.map