"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Order = void 0;
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = __importDefault(require("bn.js")); // eslint-disable-line @typescript-eslint/no-unused-vars
const borsh = __importStar(require("@coral-xyz/borsh")); // eslint-disable-line @typescript-eslint/no-unused-vars
const programId_1 = require("../programId");
class Order {
    globalConfig;
    maker;
    inputMint;
    inputMintProgramId;
    outputMint;
    outputMintProgramId;
    /** The amount of input token the maker wants to swap */
    initialInputAmount;
    /** The amount of output token the maker wants to receive */
    expectedOutputAmount;
    /** The amount of input token remaining to be swapped */
    remainingInputAmount;
    /** The amount of output token that the maker has received so far */
    filledOutputAmount;
    /**
     * The amount of tips the maker is due to receive for this order -
     * in lamports, stored in the pda_authority account
     */
    tipAmount;
    /** The number of times the order has been filled */
    numberOfFills;
    orderType;
    status;
    inVaultBump;
    /**
     * This is normally set to 0, but can be set to 1 to indicate that the
     * order is part of a flash operation, in whcih case the order can not be
     * modified until the flash operation is completed.
     */
    flashIxLock;
    padding0;
    lastUpdatedTimestamp;
    /**
     * This is only used for flash operations, and is set to the blanance on the start
     * operation, and than back to 0 on the end operation. It is used to compute the difference
     * between start and end balances in order to compute the amount received from a potential swap
     */
    flashStartTakerOutputBalance;
    padding;
    static discriminator = Buffer.from([
        134, 173, 223, 185, 77, 86, 28, 51,
    ]);
    static layout = borsh.struct([
        borsh.publicKey("globalConfig"),
        borsh.publicKey("maker"),
        borsh.publicKey("inputMint"),
        borsh.publicKey("inputMintProgramId"),
        borsh.publicKey("outputMint"),
        borsh.publicKey("outputMintProgramId"),
        borsh.u64("initialInputAmount"),
        borsh.u64("expectedOutputAmount"),
        borsh.u64("remainingInputAmount"),
        borsh.u64("filledOutputAmount"),
        borsh.u64("tipAmount"),
        borsh.u64("numberOfFills"),
        borsh.u8("orderType"),
        borsh.u8("status"),
        borsh.u8("inVaultBump"),
        borsh.u8("flashIxLock"),
        borsh.array(borsh.u8(), 4, "padding0"),
        borsh.u64("lastUpdatedTimestamp"),
        borsh.u64("flashStartTakerOutputBalance"),
        borsh.array(borsh.u64(), 19, "padding"),
    ]);
    constructor(fields) {
        this.globalConfig = fields.globalConfig;
        this.maker = fields.maker;
        this.inputMint = fields.inputMint;
        this.inputMintProgramId = fields.inputMintProgramId;
        this.outputMint = fields.outputMint;
        this.outputMintProgramId = fields.outputMintProgramId;
        this.initialInputAmount = fields.initialInputAmount;
        this.expectedOutputAmount = fields.expectedOutputAmount;
        this.remainingInputAmount = fields.remainingInputAmount;
        this.filledOutputAmount = fields.filledOutputAmount;
        this.tipAmount = fields.tipAmount;
        this.numberOfFills = fields.numberOfFills;
        this.orderType = fields.orderType;
        this.status = fields.status;
        this.inVaultBump = fields.inVaultBump;
        this.flashIxLock = fields.flashIxLock;
        this.padding0 = fields.padding0;
        this.lastUpdatedTimestamp = fields.lastUpdatedTimestamp;
        this.flashStartTakerOutputBalance = fields.flashStartTakerOutputBalance;
        this.padding = fields.padding;
    }
    static async fetch(c, address, programId = programId_1.PROGRAM_ID) {
        const info = await c.getAccountInfo(address);
        if (info === null) {
            return null;
        }
        if (!info.owner.equals(programId)) {
            throw new Error("account doesn't belong to this program");
        }
        return this.decode(info.data);
    }
    static async fetchMultiple(c, addresses, programId = programId_1.PROGRAM_ID) {
        const infos = await c.getMultipleAccountsInfo(addresses);
        return infos.map((info) => {
            if (info === null) {
                return null;
            }
            if (!info.owner.equals(programId)) {
                throw new Error("account doesn't belong to this program");
            }
            return this.decode(info.data);
        });
    }
    static decode(data) {
        if (!data.slice(0, 8).equals(Order.discriminator)) {
            throw new Error("invalid account discriminator");
        }
        const dec = Order.layout.decode(data.slice(8));
        return new Order({
            globalConfig: dec.globalConfig,
            maker: dec.maker,
            inputMint: dec.inputMint,
            inputMintProgramId: dec.inputMintProgramId,
            outputMint: dec.outputMint,
            outputMintProgramId: dec.outputMintProgramId,
            initialInputAmount: dec.initialInputAmount,
            expectedOutputAmount: dec.expectedOutputAmount,
            remainingInputAmount: dec.remainingInputAmount,
            filledOutputAmount: dec.filledOutputAmount,
            tipAmount: dec.tipAmount,
            numberOfFills: dec.numberOfFills,
            orderType: dec.orderType,
            status: dec.status,
            inVaultBump: dec.inVaultBump,
            flashIxLock: dec.flashIxLock,
            padding0: dec.padding0,
            lastUpdatedTimestamp: dec.lastUpdatedTimestamp,
            flashStartTakerOutputBalance: dec.flashStartTakerOutputBalance,
            padding: dec.padding,
        });
    }
    toJSON() {
        return {
            globalConfig: this.globalConfig.toString(),
            maker: this.maker.toString(),
            inputMint: this.inputMint.toString(),
            inputMintProgramId: this.inputMintProgramId.toString(),
            outputMint: this.outputMint.toString(),
            outputMintProgramId: this.outputMintProgramId.toString(),
            initialInputAmount: this.initialInputAmount.toString(),
            expectedOutputAmount: this.expectedOutputAmount.toString(),
            remainingInputAmount: this.remainingInputAmount.toString(),
            filledOutputAmount: this.filledOutputAmount.toString(),
            tipAmount: this.tipAmount.toString(),
            numberOfFills: this.numberOfFills.toString(),
            orderType: this.orderType,
            status: this.status,
            inVaultBump: this.inVaultBump,
            flashIxLock: this.flashIxLock,
            padding0: this.padding0,
            lastUpdatedTimestamp: this.lastUpdatedTimestamp.toString(),
            flashStartTakerOutputBalance: this.flashStartTakerOutputBalance.toString(),
            padding: this.padding.map((item) => item.toString()),
        };
    }
    static fromJSON(obj) {
        return new Order({
            globalConfig: new web3_js_1.PublicKey(obj.globalConfig),
            maker: new web3_js_1.PublicKey(obj.maker),
            inputMint: new web3_js_1.PublicKey(obj.inputMint),
            inputMintProgramId: new web3_js_1.PublicKey(obj.inputMintProgramId),
            outputMint: new web3_js_1.PublicKey(obj.outputMint),
            outputMintProgramId: new web3_js_1.PublicKey(obj.outputMintProgramId),
            initialInputAmount: new bn_js_1.default(obj.initialInputAmount),
            expectedOutputAmount: new bn_js_1.default(obj.expectedOutputAmount),
            remainingInputAmount: new bn_js_1.default(obj.remainingInputAmount),
            filledOutputAmount: new bn_js_1.default(obj.filledOutputAmount),
            tipAmount: new bn_js_1.default(obj.tipAmount),
            numberOfFills: new bn_js_1.default(obj.numberOfFills),
            orderType: obj.orderType,
            status: obj.status,
            inVaultBump: obj.inVaultBump,
            flashIxLock: obj.flashIxLock,
            padding0: obj.padding0,
            lastUpdatedTimestamp: new bn_js_1.default(obj.lastUpdatedTimestamp),
            flashStartTakerOutputBalance: new bn_js_1.default(obj.flashStartTakerOutputBalance),
            padding: obj.padding.map((item) => new bn_js_1.default(item)),
        });
    }
}
exports.Order = Order;
//# sourceMappingURL=Order.js.map