"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.ClientError = void 0;
exports.checkHex = checkHex;
exports.checkAddress = checkAddress;
const openapi_fetch_1 = __importDefault(require("openapi-fetch"));
const viem_1 = require("viem");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const types_1 = require("./types");
const web3_js_1 = require("@solana/web3.js");
const anchor = __importStar(require("@coral-xyz/anchor"));
const limo_sdk_1 = require("@kamino-finance/limo-sdk");
const utils_1 = require("@kamino-finance/limo-sdk/dist/utils");
const svm = __importStar(require("./svm"));
const web3_js_2 = require("@solana/web3.js");
const bytes_1 = require("@coral-xyz/anchor/dist/cjs/utils/bytes");
__exportStar(require("./types"), exports);
__exportStar(require("./const"), exports);
class ClientError extends Error {
    static newHttpError(error, status) {
        const message = `Auction server http error ${status ?? ""} - ${error}`;
        return new ClientError(message);
    }
    static newWebsocketError(error) {
        const message = `Auction server websocket error - ${error}`;
        return new ClientError(message);
    }
}
exports.ClientError = ClientError;
const DEFAULT_WS_OPTIONS = {
    response_timeout: 10000,
    ping_interval: 32000, // 30 seconds + 2 seconds to account for extra latency
};
function checkHex(hex) {
    if ((0, viem_1.isHex)(hex)) {
        return hex;
    }
    throw new ClientError(`Invalid hex: ${hex}`);
}
function checkAddress(address) {
    if ((0, viem_1.isAddress)(address)) {
        return address;
    }
    throw new ClientError(`Invalid address: ${address}`);
}
class Client {
    clientOptions;
    wsOptions;
    websocket;
    idCounter = 0;
    callbackRouter = {};
    pingTimeout;
    websocketOpportunityCallback;
    websocketBidStatusCallback;
    websocketSvmChainUpdateCallback;
    websocketRemoveOpportunitiesCallback;
    websocketCloseCallback;
    getAuthorization() {
        return this.clientOptions.apiKey
            ? {
                Authorization: `Bearer ${this.clientOptions.apiKey}`,
            }
            : {};
    }
    constructor(clientOptions, wsOptions, opportunityCallback, bidStatusCallback, svmChainUpdateCallback, removeOpportunitiesCallback, websocketCloseCallback) {
        this.clientOptions = clientOptions;
        this.clientOptions.headers = {
            ...(this.clientOptions.headers ?? {}),
            ...this.getAuthorization(),
        };
        this.wsOptions = { ...DEFAULT_WS_OPTIONS, ...wsOptions };
        this.pingTimeout = undefined;
        this.websocketOpportunityCallback = opportunityCallback;
        this.websocketBidStatusCallback = bidStatusCallback;
        this.websocketSvmChainUpdateCallback = svmChainUpdateCallback;
        this.websocketRemoveOpportunitiesCallback = removeOpportunitiesCallback;
        this.websocketCloseCallback =
            websocketCloseCallback ??
                (() => {
                    throw ClientError.newWebsocketError("Websocket connection was closed");
                });
    }
    connectWebsocket() {
        const websocketEndpoint = new URL(this.clientOptions.baseUrl);
        websocketEndpoint.protocol =
            websocketEndpoint.protocol === "https:" ? "wss:" : "ws:";
        websocketEndpoint.pathname = "/v1/ws";
        this.websocket = new isomorphic_ws_1.default(websocketEndpoint.toString(), {
            headers: this.getAuthorization(),
        });
        this.websocket.on("message", async (data) => {
            const message = JSON.parse(data.toString());
            if ("type" in message && message.type === "new_opportunity") {
                if (typeof this.websocketOpportunityCallback === "function") {
                    const convertedOpportunity = this.convertOpportunity(message.opportunity);
                    if (convertedOpportunity !== undefined) {
                        await this.websocketOpportunityCallback(convertedOpportunity);
                    }
                }
            }
            else if ("type" in message && message.type === "bid_status_update") {
                if (typeof this.websocketBidStatusCallback === "function") {
                    await this.websocketBidStatusCallback({
                        id: message.status.id,
                        ...message.status.bid_status,
                    });
                }
            }
            else if ("type" in message && message.type === "svm_chain_update") {
                if (typeof this.websocketSvmChainUpdateCallback === "function") {
                    await this.websocketSvmChainUpdateCallback({
                        chainId: message.update.chain_id,
                        blockhash: message.update.blockhash,
                        latestPrioritizationFee: BigInt(message.update.latest_prioritization_fee),
                    });
                }
            }
            else if ("type" in message && message.type === "remove_opportunities") {
                if (typeof this.websocketRemoveOpportunitiesCallback === "function") {
                    const opportunityDelete = {
                        chainType: types_1.ChainType.SVM,
                        chainId: message.opportunity_delete.chain_id,
                        program: message.opportunity_delete.program,
                        permissionAccount: new web3_js_1.PublicKey(message.opportunity_delete.permission_account),
                        router: new web3_js_1.PublicKey(message.opportunity_delete.router),
                    };
                    await this.websocketRemoveOpportunitiesCallback(opportunityDelete);
                }
            }
            else if ("id" in message && message.id) {
                // Response to a request sent earlier via the websocket with the same id
                const callback = this.callbackRouter[message.id];
                if (callback !== undefined) {
                    callback(message);
                    delete this.callbackRouter[message.id];
                }
            }
            else if ("error" in message) {
                // Can not route error messages to the callback router as they don't have an id
                console.error(message.error);
            }
        });
        this.websocket.on("error", (error) => {
            console.error(ClientError.newWebsocketError(error.message));
        });
        this.websocket.on("ping", () => {
            if (this.pingTimeout !== undefined) {
                clearTimeout(this.pingTimeout);
            }
            this.pingTimeout = setTimeout(() => {
                console.error(ClientError.newWebsocketError("Received no ping. Terminating connection."));
                this.websocket?.terminate();
            }, this.wsOptions.ping_interval);
        });
        this.websocket.on("close", () => {
            // TODO: can we reconnect?
            this.websocketCloseCallback();
        });
    }
    /**
     * Subscribes to the specified chains
     *
     * The opportunity handler will be called for opportunities on the specified chains
     * If the opportunity handler is not set, an error will be thrown
     * @param chains
     */
    async subscribeChains(chains) {
        if (this.websocketOpportunityCallback === undefined) {
            throw new ClientError("Opportunity handler not set");
        }
        await this.requestViaWebsocket({
            method: "subscribe",
            params: {
                chain_ids: chains,
            },
        });
    }
    /**
     * Unsubscribes from the specified chains
     *
     * The opportunity handler will no longer be called for opportunities on the specified chains
     * @param chains
     */
    async unsubscribeChains(chains) {
        await this.requestViaWebsocket({
            method: "unsubscribe",
            params: {
                chain_ids: chains,
            },
        });
    }
    /**
     * Cancels a bid
     *
     * Bids can only be cancelled if they are in awaiting_signature state
     * @param chains
     */
    async cancelBid(bid_id, chain_id) {
        await this.requestViaWebsocket({
            method: "cancel_bid",
            params: {
                data: {
                    bid_id,
                    chain_id,
                },
            },
        });
    }
    async requestViaWebsocket(msg) {
        const msg_with_id = {
            ...msg,
            id: (this.idCounter++).toString(),
        };
        return new Promise((resolve, reject) => {
            this.callbackRouter[msg_with_id.id] = (response) => {
                if (response.status === "success") {
                    resolve(response.result);
                }
                else {
                    reject(ClientError.newWebsocketError(response.result));
                }
            };
            if (this.websocket === undefined) {
                this.connectWebsocket();
            }
            if (this.websocket !== undefined) {
                if (this.websocket.readyState === isomorphic_ws_1.default.CONNECTING) {
                    this.websocket.on("open", () => {
                        this.websocket?.send(JSON.stringify(msg_with_id));
                    });
                }
                else if (this.websocket.readyState === isomorphic_ws_1.default.OPEN) {
                    this.websocket.send(JSON.stringify(msg_with_id));
                }
                else {
                    reject(ClientError.newWebsocketError("Websocket connection closing or already closed"));
                }
            }
            setTimeout(() => {
                delete this.callbackRouter[msg_with_id.id];
                reject(ClientError.newWebsocketError("Websocket response timeout"));
            }, this.wsOptions.response_timeout);
        });
    }
    /**
     * Fetches opportunities
     * @param chainId Chain id to fetch opportunities for. e.g: sepolia
     * @param fromTime A date object representing the datetime to fetch opportunities from. If undefined, fetches from the beginning of time.
     * @param limit Number of opportunities to return
     * @returns List of opportunities
     */
    async getOpportunities(chainId, fromTime, limit) {
        const client = (0, openapi_fetch_1.default)(this.clientOptions);
        const opportunities = await client.GET("/v1/opportunities", {
            params: {
                query: { chain_id: chainId, from_time: fromTime?.toISOString(), limit },
            },
        });
        if (opportunities.data === undefined) {
            throw new ClientError("No opportunities found");
        }
        return opportunities.data.flatMap((opportunity) => {
            const convertedOpportunity = this.convertOpportunity(opportunity);
            if (convertedOpportunity === undefined) {
                return [];
            }
            return convertedOpportunity;
        });
    }
    /**
     * Submits an opportunity to be exposed to searchers
     * @param opportunity Opportunity to submit
     */
    async submitOpportunity(opportunity) {
        const client = (0, openapi_fetch_1.default)(this.clientOptions);
        const encoded_order = Buffer.alloc(limo_sdk_1.Order.discriminator.length + limo_sdk_1.Order.layout.span);
        limo_sdk_1.Order.discriminator.copy(encoded_order);
        limo_sdk_1.Order.layout.encode(opportunity.order.state, encoded_order, limo_sdk_1.Order.discriminator.length);
        const remainingOutputAmount = anchor.BN.max(opportunity.order.state.expectedOutputAmount.sub(opportunity.order.state.filledOutputAmount), new anchor.BN(0));
        const body = {
            chain_id: opportunity.chainId,
            version: "v1",
            program: opportunity.program,
            order: encoded_order.toString("base64"),
            slot: opportunity.slot,
            order_address: opportunity.order.address.toBase58(),
            buy_tokens: [
                {
                    token: opportunity.order.state.inputMint.toBase58(),
                    amount: opportunity.order.state.remainingInputAmount.toNumber(),
                },
            ],
            sell_tokens: [
                {
                    token: opportunity.order.state.outputMint.toBase58(),
                    amount: remainingOutputAmount.toNumber(),
                },
            ],
            permission_account: opportunity.order.address.toBase58(),
            router: (0, utils_1.getPdaAuthority)(limo_sdk_1.limoId, opportunity.order.state.globalConfig).toBase58(),
        };
        const response = await client.POST("/v1/opportunities", {
            body: body,
        });
        if (response.error) {
            throw ClientError.newHttpError(JSON.stringify(response.error), response.response.status);
        }
    }
    /**
     * Remove an opportunity from the server and update the searchers
     * @param opportunity Opportunity to be removed
     */
    async removeOpportunity(opportunity) {
        if (opportunity.program !== "limo") {
            throw new ClientError("Only limo opportunities can be removed");
        }
        const client = (0, openapi_fetch_1.default)(this.clientOptions);
        const body = {
            chain_type: opportunity.chainType,
            chain_id: opportunity.chainId,
            version: "v1",
            program: opportunity.program,
            permission_account: opportunity.permissionAccount.toBase58(),
            router: opportunity.router.toBase58(),
        };
        const response = await client.DELETE("/v1/opportunities", {
            body,
        });
        if (response.error) {
            throw ClientError.newHttpError(JSON.stringify(response.error), response.response.status);
        }
    }
    /**
     * Gets the best quote for a given quote request
     * @param quoteRequest Quote request to submit
     * @returns Quote response representing the best quote for the request
     */
    async getQuote(quoteRequest) {
        const client = (0, openapi_fetch_1.default)(this.clientOptions);
        const body = {
            chain_id: quoteRequest.chainId,
            input_token_mint: quoteRequest.inputTokenMint.toBase58(),
            output_token_mint: quoteRequest.outputTokenMint.toBase58(),
            referral_fee_info: quoteRequest.referralFeeInfo
                ? {
                    router: quoteRequest.referralFeeInfo.router.toBase58(),
                    referral_fee_ppm: quoteRequest.referralFeeInfo.referralFeePpm,
                }
                : undefined,
            specified_token_amount: quoteRequest.specifiedTokenAmount,
            user_wallet_address: quoteRequest.userWallet
                ? quoteRequest.userWallet.toBase58()
                : undefined,
            memo: quoteRequest.memo ?? undefined,
            cancellable: quoteRequest.cancellable ?? undefined,
            minimum_lifetime: quoteRequest.minimumLifetime ?? undefined,
            version: "v1",
        };
        // TODO: we may want to wrap all the GET/POST calls in a try/catch block to handle errors
        const response = await client.POST("/v1/opportunities/quote", {
            body,
        });
        if (response.error) {
            throw ClientError.newHttpError(JSON.stringify(response.error), response.response.status);
        }
        return this.convertQuoteResponse(response.data);
    }
    /**
     * Posts a submit quote request to the server
     * @param submitQuote The quote data to be submitted on-chain
     * @returns The fully signed transaction that was submitted on-chain
     */
    async submitQuote(submitQuote) {
        const client = (0, openapi_fetch_1.default)(this.clientOptions);
        const body = {
            reference_id: submitQuote.referenceId,
            user_signature: submitQuote.userSignature,
        };
        const response = await client.POST("/v1/{chain_id}/quotes/submit", {
            params: {
                path: {
                    chain_id: submitQuote.chainId,
                },
            },
            body,
        });
        if (response.error) {
            throw ClientError.newHttpError(JSON.stringify(response.error), response.response.status);
        }
        return web3_js_2.VersionedTransaction.deserialize(new Uint8Array(bytes_1.base64.decode(response.data.transaction)));
    }
    /**
     * Submits a raw bid for a permission key
     * @param bid
     * @param subscribeToUpdates If true, the client will subscribe to bid status updates via websocket and will call the bid status callback if set
     * @returns The id of the submitted bid, you can use this id to track the status of the bid
     */
    async submitBid(bid, subscribeToUpdates = true) {
        const serverBid = this.toServerBid(bid);
        if (subscribeToUpdates) {
            const result = await this.requestViaWebsocket({
                method: "post_bid",
                params: {
                    bid: serverBid,
                },
            });
            if (result === null) {
                throw ClientError.newWebsocketError("Empty response in websocket for bid submission");
            }
            return result.id;
        }
        else {
            const client = (0, openapi_fetch_1.default)(this.clientOptions);
            const response = await client.POST("/v1/bids", {
                body: serverBid,
            });
            if (response.error) {
                throw ClientError.newHttpError(JSON.stringify(response.error), response.response.status);
            }
            else if (response.data === undefined) {
                throw ClientError.newHttpError("No data returned");
            }
            else {
                return response.data.id;
            }
        }
    }
    /**
     * Get bids for an api key
     * @param fromTime The datetime to fetch bids from. If undefined or null, fetches from the beginning of time.
     * @returns The paginated bids response
     */
    async getBids(fromTime) {
        const client = (0, openapi_fetch_1.default)(this.clientOptions);
        const response = await client.GET("/v1/bids", {
            params: { query: { from_time: fromTime?.toISOString() } },
        });
        if (response.error) {
            throw ClientError.newHttpError(JSON.stringify(response.error), response.response.status);
        }
        else if (response.data === undefined) {
            throw ClientError.newHttpError("No data returned");
        }
        else {
            return response.data;
        }
    }
    /**
     * Converts an opportunity from the server to the client format
     * Returns undefined if the opportunity version is not supported
     * @param opportunity
     * @returns Opportunity in the converted client format
     */
    convertOpportunity(opportunity) {
        if (opportunity.version !== "v1") {
            console.warn(`Can not handle opportunity version: ${opportunity.version}. Please upgrade your client.`);
            return undefined;
        }
        if (opportunity.program === "limo") {
            const order = limo_sdk_1.Order.decode(Buffer.from(opportunity.order, "base64"));
            return {
                chainId: opportunity.chain_id,
                slot: opportunity.slot,
                opportunityId: opportunity.opportunity_id,
                order: {
                    state: order,
                    address: new web3_js_1.PublicKey(opportunity.order_address),
                },
                program: "limo",
            };
        }
        else if (opportunity.program === "swap") {
            let tokens;
            if (opportunity.tokens.side_specified === "searcher") {
                tokens = {
                    type: "searcher_specified",
                    searcherToken: new web3_js_1.PublicKey(opportunity.tokens.searcher_token),
                    userToken: new web3_js_1.PublicKey(opportunity.tokens.user_token),
                    searcherAmount: BigInt(opportunity.tokens.searcher_amount),
                    tokenProgramSearcher: new web3_js_1.PublicKey(opportunity.tokens.token_program_searcher),
                    tokenProgramUser: new web3_js_1.PublicKey(opportunity.tokens.token_program_user),
                };
            }
            else {
                tokens = {
                    type: "user_specified",
                    searcherToken: new web3_js_1.PublicKey(opportunity.tokens.searcher_token),
                    userToken: new web3_js_1.PublicKey(opportunity.tokens.user_token),
                    userTokenAmountIncludingFees: BigInt(opportunity.tokens.user_amount_including_fees),
                    userAmount: BigInt(opportunity.tokens.user_amount),
                    tokenProgramSearcher: new web3_js_1.PublicKey(opportunity.tokens.token_program_searcher),
                    tokenProgramUser: new web3_js_1.PublicKey(opportunity.tokens.token_program_user),
                };
            }
            return {
                chainId: opportunity.chain_id,
                opportunityId: opportunity.opportunity_id,
                program: "swap",
                referralFeeBps: opportunity.referral_fee_bps,
                referralFeePpm: opportunity.referral_fee_ppm,
                platformFeeBps: opportunity.platform_fee_bps,
                platformFeePpm: opportunity.platform_fee_ppm,
                feeToken: opportunity.fee_token,
                permissionAccount: new web3_js_1.PublicKey(opportunity.permission_account),
                routerAccount: new web3_js_1.PublicKey(opportunity.router_account),
                userWalletAddress: new web3_js_1.PublicKey(opportunity.user_wallet_address),
                tokens,
                tokenInitializationConfigs: {
                    expressRelayFeeReceiverAta: opportunity.token_account_initialization_configs
                        .express_relay_fee_receiver_ata,
                    relayerFeeReceiverAta: opportunity.token_account_initialization_configs
                        .relayer_fee_receiver_ata,
                    routerFeeReceiverAta: opportunity.token_account_initialization_configs
                        .router_fee_receiver_ta,
                    userAtaMintSearcher: opportunity.token_account_initialization_configs
                        .user_ata_mint_searcher,
                    userAtaMintUser: opportunity.token_account_initialization_configs.user_ata_mint_user,
                },
                memo: opportunity.memo ?? undefined,
                userMintUserBalance: new anchor.BN(opportunity.user_mint_user_balance.toString()),
                cancellable: opportunity.cancellable,
                minimumDeadline: opportunity.minimum_deadline,
                profileId: opportunity.profile_id ?? undefined,
            };
        }
        else {
            console.warn("Unsupported opportunity", opportunity);
        }
    }
    toServerBid(bid) {
        if (bid.type === "swap") {
            return {
                chain_id: bid.chainId,
                opportunity_id: bid.opportunityId,
                type: "swap",
                transaction: bid.transaction
                    .serialize({ requireAllSignatures: false })
                    .toString("base64"),
            };
        }
        else {
            return {
                chain_id: bid.chainId,
                slot: bid.slot,
                transaction: bid.transaction
                    .serialize({ requireAllSignatures: false })
                    .toString("base64"),
            };
        }
    }
    /**
     * Converts a quote response from the server to the client format
     * @param quoteResponse
     * @returns Quote response in the converted client format
     */
    convertQuoteResponse(quoteResponse) {
        return {
            chainId: quoteResponse.chain_id,
            expirationTime: quoteResponse.expiration_time
                ? new Date(quoteResponse.expiration_time * 1000)
                : undefined,
            inputToken: {
                token: new web3_js_1.PublicKey(quoteResponse.input_token.token),
                amount: BigInt(quoteResponse.input_token.amount),
            },
            outputToken: {
                token: new web3_js_1.PublicKey(quoteResponse.output_token.token),
                amount: BigInt(quoteResponse.output_token.amount),
            },
            transaction: quoteResponse.transaction
                ? web3_js_2.VersionedTransaction.deserialize(new Uint8Array(bytes_1.base64.decode(quoteResponse.transaction)))
                : undefined,
            referenceId: quoteResponse.reference_id,
        };
    }
    // SVM specific functions
    /**
     * Fetches the Express Relay SVM config necessary for bidding
     * @param chainId The id for the chain you want to fetch the config for
     * @param connection The connection to use for fetching the config
     */
    async getExpressRelaySvmConfig(chainId, connection) {
        return svm.getExpressRelaySvmConfig(chainId, connection);
    }
    /**
     * Constructs a SubmitBid instruction, which can be added to a transaction to permission it on the given permission key
     * @param searcher The address of the searcher that is submitting the bid
     * @param router The identifying address of the router that the permission key is for
     * @param permissionKey The 32-byte permission key as an SVM PublicKey
     * @param bidAmount The amount of the bid in lamports
     * @param deadline The deadline for the bid in seconds since Unix epoch
     * @param chainId The chain ID as a string, e.g. "solana"
     * @param relayerSigner The address of the relayer that is submitting the bid
     * @param feeReceiverRelayer The fee collection address of the relayer
     * @returns The SubmitBid instruction
     */
    async constructSubmitBidInstruction(searcher, router, permissionKey, bidAmount, deadline, chainId, relayerSigner, feeReceiverRelayer) {
        return svm.constructSubmitBidInstruction(searcher, router, permissionKey, bidAmount, deadline, chainId, relayerSigner, feeReceiverRelayer);
    }
    /**
     * Constructs an SVM On-chain bid, by adding a SubmitBid instruction to a transaction
     * @param tx The transaction to add a SubmitBid instruction to. This transaction should already check for the appropriate permissions.
     * @param searcher The address of the searcher that is submitting the bid
     * @param router The identifying address of the router that the permission key is for
     * @param permissionKey The 32-byte permission key as an SVM PublicKey
     * @param bidAmount The amount of the bid in lamports
     * @param deadline The deadline for the bid in seconds since Unix epoch
     * @param chainId The chain ID as a string, e.g. "solana"
     * @param relayerSigner The address of the relayer that is submitting the bid
     * @param feeReceiverRelayer The fee collection address of the relayer
     * @returns The constructed SVM bid
     */
    async constructSvmBid(tx, searcher, router, permissionKey, bidAmount, deadline, chainId, relayerSigner, feeReceiverRelayer) {
        return svm.constructSvmBid(tx, searcher, router, permissionKey, bidAmount, deadline, chainId, relayerSigner, feeReceiverRelayer);
    }
    /**
     * Constructs a Swap Bid, by adding swap instruction + idempotent token account creation instructions to a transaction
     * @param tx The transaction to add the instructions to
     * @param searcher The address of the searcher filling the swap order
     * @param swapOpportunity The swap opportunity to bid on
     * @param bidAmount The amount of the bid in either searcher side or user side tokens depending on the swap opportunity
     * @param deadline The deadline for the bid in seconds since Unix epoch
     * @param chainId The chain ID as a string, e.g. "solana"
     * @param feeReceiverRelayer The fee collection address of the relayer
     * @param relayerSigner The address of the relayer that is handling the bid
     */
    async constructSwapBid(tx, searcher, swapOpportunity, bidAmount, deadline, chainId, feeReceiverRelayer, relayerSigner) {
        return svm.constructSwapBid(tx, searcher, swapOpportunity, bidAmount, deadline, chainId, feeReceiverRelayer, relayerSigner);
    }
}
exports.Client = Client;
