"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FEE_SPLIT_PRECISION_PPM = exports.FEE_SPLIT_PRECISION = void 0;
exports.getConfigRouterPda = getConfigRouterPda;
exports.getExpressRelayMetadataPda = getExpressRelayMetadataPda;
exports.constructSubmitBidInstruction = constructSubmitBidInstruction;
exports.getAssociatedTokenAddress = getAssociatedTokenAddress;
exports.createAtaIdempotentInstruction = createAtaIdempotentInstruction;
exports.constructSwapInstruction = constructSwapInstruction;
exports.getWrapSolInstructions = getWrapSolInstructions;
exports.getUnwrapSolInstruction = getUnwrapSolInstruction;
exports.constructSwapBid = constructSwapBid;
exports.constructSvmBid = constructSvmBid;
exports.getExpressRelaySvmConfig = getExpressRelaySvmConfig;
const web3_js_1 = require("@solana/web3.js");
const anchor = __importStar(require("@coral-xyz/anchor"));
const spl_token_1 = require("@solana/spl-token");
const anchor_1 = require("@coral-xyz/anchor");
const idlExpressRelay_json_1 = __importDefault(require("./idl/idlExpressRelay.json"));
const const_1 = require("./const");
const nodewallet_1 = __importDefault(require("@coral-xyz/anchor/dist/cjs/nodewallet"));
const spl_memo_1 = require("@solana/spl-memo");
function getExpressRelayProgram(chain) {
    if (!const_1.SVM_CONSTANTS[chain]) {
        throw new Error(`Chain ${chain} not supported`);
    }
    return const_1.SVM_CONSTANTS[chain].expressRelayProgram;
}
exports.FEE_SPLIT_PRECISION = new anchor.BN(10000);
exports.FEE_SPLIT_PRECISION_PPM = new anchor.BN(1000000);
const RENT_TOKEN_ACCOUNT_LAMPORTS = 2039280;
function getConfigRouterPda(chain, router) {
    const expressRelayProgram = getExpressRelayProgram(chain);
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("config_router"), router.toBuffer()], expressRelayProgram)[0];
}
function getExpressRelayMetadataPda(chain) {
    const expressRelayProgram = getExpressRelayProgram(chain);
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("metadata")], expressRelayProgram)[0];
}
async function constructSubmitBidInstruction(searcher, router, permissionKey, bidAmount, deadline, chainId, relayerSigner, feeReceiverRelayer) {
    const expressRelay = new anchor_1.Program(idlExpressRelay_json_1.default, {});
    const configRouter = getConfigRouterPda(chainId, router);
    const expressRelayMetadata = getExpressRelayMetadataPda(chainId);
    const svmConstants = const_1.SVM_CONSTANTS[chainId];
    const ixSubmitBid = await expressRelay.methods
        .submitBid({
        deadline,
        bidAmount,
    })
        .accountsStrict({
        searcher,
        relayerSigner,
        permission: permissionKey,
        router,
        configRouter,
        expressRelayMetadata,
        feeReceiverRelayer,
        systemProgram: anchor.web3.SystemProgram.programId,
        sysvarInstructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
    })
        .instruction();
    ixSubmitBid.programId = svmConstants.expressRelayProgram;
    return ixSubmitBid;
}
function getAssociatedTokenAddress(owner, tokenMintAddress, tokenProgram) {
    return (0, spl_token_1.getAssociatedTokenAddressSync)(tokenMintAddress, owner, true, //allow owner to be off-curve
    tokenProgram, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
}
function createAtaIdempotentInstruction(owner, mint, payer = owner, tokenProgram) {
    const ataAddress = getAssociatedTokenAddress(owner, mint, tokenProgram);
    const createUserTokenAccountIx = (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(payer, ataAddress, owner, mint, tokenProgram, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
    return [ataAddress, createUserTokenAccountIx];
}
async function constructSwapInstruction(searcher, swapOpportunity, bidAmount, deadline, chainId, feeReceiverRelayer, relayerSigner) {
    const expressRelay = new anchor_1.Program(idlExpressRelay_json_1.default, {});
    const expressRelayMetadata = getExpressRelayMetadataPda(chainId);
    const svmConstants = const_1.SVM_CONSTANTS[chainId];
    const { searcherToken, tokenProgramSearcher, tokenProgramUser, userToken, user, mintFee, feeTokenProgram, router, } = extractSwapInfo(swapOpportunity);
    const bidAmountIncludingFees = getBidAmountIncludingFees(swapOpportunity, bidAmount);
    const swapV2Args = {
        amountSearcher: swapOpportunity.tokens.type === "searcher_specified"
            ? new anchor.BN(swapOpportunity.tokens.searcherAmount.toString())
            : bidAmountIncludingFees,
        amountUser: swapOpportunity.tokens.type === "user_specified"
            ? new anchor.BN(swapOpportunity.tokens.userTokenAmountIncludingFees.toString())
            : bidAmountIncludingFees,
        referralFeePpm: new anchor.BN(swapOpportunity.referralFeePpm),
        swapPlatformFeePpm: new anchor.BN(swapOpportunity.platformFeePpm),
        deadline,
        feeToken: swapOpportunity.feeToken === "searcher_token"
            ? { searcher: {} }
            : { user: {} },
    };
    const ixSwap = await expressRelay.methods
        .swapV2(swapV2Args)
        .accountsStrict({
        expressRelayMetadata,
        searcher,
        user: swapOpportunity.userWalletAddress,
        searcherTaMintSearcher: getAssociatedTokenAddress(searcher, searcherToken, tokenProgramSearcher),
        searcherTaMintUser: getAssociatedTokenAddress(searcher, userToken, tokenProgramUser),
        userAtaMintSearcher: getAssociatedTokenAddress(user, searcherToken, tokenProgramSearcher),
        tokenProgramSearcher: tokenProgramSearcher,
        mintSearcher: searcherToken,
        userAtaMintUser: getAssociatedTokenAddress(user, userToken, tokenProgramUser),
        tokenProgramUser: tokenProgramUser,
        mintUser: userToken,
        routerFeeReceiverTa: getAssociatedTokenAddress(router, mintFee, feeTokenProgram),
        relayerFeeReceiverAta: getAssociatedTokenAddress(feeReceiverRelayer, mintFee, feeTokenProgram),
        tokenProgramFee: feeTokenProgram,
        mintFee,
        expressRelayFeeReceiverAta: getAssociatedTokenAddress(expressRelayMetadata, mintFee, feeTokenProgram),
        relayerSigner,
    })
        .instruction();
    ixSwap.programId = svmConstants.expressRelayProgram;
    return ixSwap;
}
function extractSwapInfo(swapOpportunity) {
    const tokenProgramSearcher = swapOpportunity.tokens.tokenProgramSearcher;
    const tokenProgramUser = swapOpportunity.tokens.tokenProgramUser;
    const searcherToken = swapOpportunity.tokens.searcherToken;
    const userToken = swapOpportunity.tokens.userToken;
    const user = swapOpportunity.userWalletAddress;
    const [mintFee, feeTokenProgram] = swapOpportunity.feeToken === "searcher_token"
        ? [searcherToken, tokenProgramSearcher]
        : [userToken, tokenProgramUser];
    const router = swapOpportunity.routerAccount;
    const tokenInitializationConfigs = swapOpportunity.tokenInitializationConfigs;
    const memo = swapOpportunity.memo;
    const cancellable = swapOpportunity.cancellable;
    const userMintUserBalance = swapOpportunity.userMintUserBalance;
    return {
        searcherToken,
        tokenProgramSearcher,
        tokenProgramUser,
        userToken,
        user,
        mintFee,
        feeTokenProgram,
        router,
        tokenInitializationConfigs,
        memo,
        cancellable,
        userMintUserBalance,
    };
}
function getTokenAccountToCreate(searcher, user, params) {
    if (params.config === "unneeded") {
        return undefined;
    }
    return {
        payer: params.config === "searcher_payer" ? searcher : user,
        owner: params.owner,
        mint: params.mint,
        program: params.program,
    };
}
function getTokenAccountsToCreate(searcher, swapOpportunity, feeReceiverRelayer, tokenInitializationConfigs) {
    const expressRelayMetadata = getExpressRelayMetadataPda(swapOpportunity.chainId);
    const { user, router, mintFee, feeTokenProgram, tokenProgramSearcher, searcherToken: mintSearcher, tokenProgramUser, userToken: mintUser, } = extractSwapInfo(swapOpportunity);
    const tokenAccountInitializationParams = [
        {
            config: tokenInitializationConfigs.userAtaMintSearcher,
            owner: user,
            mint: mintSearcher,
            program: tokenProgramSearcher,
        },
        {
            config: tokenInitializationConfigs.userAtaMintUser,
            owner: user,
            mint: mintUser,
            program: tokenProgramUser,
        },
        {
            config: tokenInitializationConfigs.routerFeeReceiverAta,
            owner: router,
            mint: mintFee,
            program: feeTokenProgram,
        },
        {
            config: tokenInitializationConfigs.relayerFeeReceiverAta,
            owner: feeReceiverRelayer,
            mint: mintFee,
            program: feeTokenProgram,
        },
        {
            config: tokenInitializationConfigs.expressRelayFeeReceiverAta,
            owner: expressRelayMetadata,
            mint: mintFee,
            program: feeTokenProgram,
        },
    ];
    return tokenAccountInitializationParams
        .map((params) => getTokenAccountToCreate(searcher, user, params))
        .filter((account) => account !== undefined);
}
function getWrapSolInstructions(payer, owner, amount, createAta = true) {
    const instructions = [];
    const [ata, instruction] = createAtaIdempotentInstruction(owner, spl_token_1.NATIVE_MINT, payer, spl_token_1.TOKEN_PROGRAM_ID);
    if (createAta) {
        instructions.push(instruction);
    }
    instructions.push(web3_js_1.SystemProgram.transfer({
        fromPubkey: owner,
        toPubkey: ata,
        lamports: BigInt(amount.toString()),
    }));
    instructions.push((0, spl_token_1.createSyncNativeInstruction)(ata, spl_token_1.TOKEN_PROGRAM_ID));
    return instructions;
}
function getUnwrapSolInstruction(owner) {
    const ata = getAssociatedTokenAddress(owner, spl_token_1.NATIVE_MINT, spl_token_1.TOKEN_PROGRAM_ID);
    return (0, spl_token_1.createCloseAccountInstruction)(ata, owner, owner);
}
/**
 * Adjusts the bid amount in the case where the amount that needs to be provided by the searcher is specified and the fees are in the user token.
 * In this case, searchers' bids represent how many tokens they would like to receive.
 * However, for the searcher to receive `bidAmount`, the user needs to provide `bidAmount * (FEE_SPLIT_PRECISION / (FEE_SPLIT_PRECISION - fees))`
 * This function handles this adjustment.
 */
function getBidAmountIncludingFees(swapOpportunity, bidAmount) {
    if (swapOpportunity.tokens.type === "searcher_specified" &&
        swapOpportunity.feeToken === "user_token") {
        // scale bid amount by FEE_SPLIT_PRECISION/(FEE_SPLIT_PRECISION-fees) to account for fees
        const denominator = exports.FEE_SPLIT_PRECISION_PPM.sub(new anchor.BN(swapOpportunity.platformFeePpm + swapOpportunity.referralFeePpm));
        const numerator = bidAmount.mul(exports.FEE_SPLIT_PRECISION_PPM);
        // add denominator - 1 to round up
        return numerator.add(denominator.sub(new anchor.BN(1))).div(denominator);
    }
    return bidAmount;
}
function getUserAmountToWrap(amountUser, userMintUserBalance, tokenAccountInitializationConfigs) {
    const numberOfAtasPaidByUser = [
        tokenAccountInitializationConfigs.userAtaMintUser,
        tokenAccountInitializationConfigs.userAtaMintSearcher,
    ].filter((config) => config === "user_payer").length;
    return anchor.BN.min(amountUser, anchor.BN.max(userMintUserBalance.sub(new anchor.BN(numberOfAtasPaidByUser * RENT_TOKEN_ACCOUNT_LAMPORTS)), new anchor.BN(0)));
}
async function constructSwapBid(tx, searcher, swapOpportunity, bidAmount, deadline, chainId, feeReceiverRelayer, relayerSigner) {
    const { userToken, searcherToken, user, tokenInitializationConfigs, userMintUserBalance, } = extractSwapInfo(swapOpportunity);
    if (swapOpportunity.memo) {
        tx.instructions.push((0, spl_memo_1.createMemoInstruction)(swapOpportunity.memo));
    }
    const tokenAccountsToCreate = getTokenAccountsToCreate(searcher, swapOpportunity, feeReceiverRelayer, tokenInitializationConfigs);
    for (const account of tokenAccountsToCreate) {
        tx.instructions.push(createAtaIdempotentInstruction(account.owner, account.mint, account.payer, account.program)[1]);
    }
    if (userToken.equals(spl_token_1.NATIVE_MINT)) {
        const amountUser = swapOpportunity.tokens.type === "user_specified"
            ? new anchor.BN(swapOpportunity.tokens.userTokenAmountIncludingFees.toString())
            : getBidAmountIncludingFees(swapOpportunity, bidAmount);
        const amountUserToWrap = getUserAmountToWrap(amountUser, userMintUserBalance, tokenInitializationConfigs);
        tx.instructions.push(...getWrapSolInstructions(searcher, user, amountUserToWrap, false));
    }
    const swapInstruction = await constructSwapInstruction(searcher, swapOpportunity, bidAmount, deadline, chainId, feeReceiverRelayer, relayerSigner);
    tx.instructions.push(swapInstruction);
    if (searcherToken.equals(spl_token_1.NATIVE_MINT) || userToken.equals(spl_token_1.NATIVE_MINT)) {
        tx.instructions.push(getUnwrapSolInstruction(user));
    }
    return {
        transaction: tx,
        opportunityId: swapOpportunity.opportunityId,
        type: "swap",
        chainId: chainId,
        env: "svm",
    };
}
async function constructSvmBid(tx, searcher, router, permissionKey, bidAmount, deadline, chainId, relayerSigner, feeReceiverRelayer) {
    const ixSubmitBid = await constructSubmitBidInstruction(searcher, router, permissionKey, bidAmount, deadline, chainId, relayerSigner, feeReceiverRelayer);
    tx.instructions.unshift(ixSubmitBid);
    return {
        transaction: tx,
        chainId: chainId,
        type: "onchain",
        env: "svm",
    };
}
async function getExpressRelaySvmConfig(chainId, connection) {
    const provider = new anchor_1.AnchorProvider(connection, new nodewallet_1.default(new web3_js_1.Keypair()));
    const expressRelay = new anchor_1.Program(idlExpressRelay_json_1.default, provider);
    const metadata = await expressRelay.account.expressRelayMetadata.fetch(getExpressRelayMetadataPda(chainId));
    return {
        feeReceiverRelayer: metadata.feeReceiverRelayer,
        relayerSigner: metadata.relayerSigner,
    };
}
