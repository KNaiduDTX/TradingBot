"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const anchor = __importStar(require("@coral-xyz/anchor"));
const simpleSearcherSvm_1 = require("./simpleSearcherSvm");
class SearcherLimo extends simpleSearcherSvm_1.SimpleSearcherSvm {
    withLatency;
    bidMargin;
    apiKey;
    fillRate;
    constructor(endpointExpressRelay, chainId, searcher, endpointSvm, bid, fillRate, withLatency, bidMargin, apiKey) {
        super(endpointExpressRelay, chainId, searcher, endpointSvm, bid, apiKey);
        this.withLatency = withLatency;
        this.bidMargin = bidMargin;
        this.apiKey = apiKey;
        this.fillRate = new anchor.BN(fillRate);
    }
    async getBidAmount() {
        const margin = new anchor.BN(Math.floor(Math.random() * (this.bidMargin * 2 + 1)) - this.bidMargin);
        return this.bid.add(margin);
    }
    async opportunityHandler(opportunity) {
        if (this.withLatency) {
            const latency = Math.floor(Math.random() * 300);
            console.log(`Adding latency of ${latency}ms`);
            await new Promise((resolve) => setTimeout(resolve, latency));
        }
        return super.opportunityHandler(opportunity);
    }
    getInputAmount(order) {
        return anchor.BN.min(super.getInputAmount(order), order.state.initialInputAmount.mul(this.fillRate).div(new anchor.BN(100)));
    }
}
async function run() {
    const argv = (0, simpleSearcherSvm_1.makeParser)()
        .option("fill-rate", {
        description: "How much of the initial order size to fill in percentage. Default is 100%",
        type: "number",
        default: 100,
    })
        .option("with-latency", {
        description: "Whether to add random latency to the bid submission. Default is false",
        type: "boolean",
        default: false,
    })
        .option("bid-margin", {
        description: "The margin to add or subtract from the bid. For example, 1 means the bid range is [bid - 1, bid + 1]. Default is 0",
        type: "number",
        default: 0,
    })
        .parseSync();
    const searcherKeyPair = (0, simpleSearcherSvm_1.getKeypair)(argv.privateKey, argv.privateKeyJsonFile);
    const simpleSearcher = new SearcherLimo(argv.endpointExpressRelay, argv.chainId, searcherKeyPair, argv.endpointSvm, argv.bid, argv.fillRate, argv.withLatency, argv.bidMargin, argv.apiKey);
    await simpleSearcher.start();
}
if (require.main === module) {
    run();
}
