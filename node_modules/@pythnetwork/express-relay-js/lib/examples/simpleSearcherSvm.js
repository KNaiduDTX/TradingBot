"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleSearcherSvm = void 0;
exports.makeParser = makeParser;
exports.getKeypair = getKeypair;
const yargs_1 = __importDefault(require("yargs"));
const helpers_1 = require("yargs/helpers");
const fs_1 = __importDefault(require("fs"));
const index_1 = require("../index");
const const_1 = require("../const");
const anchor = __importStar(require("@coral-xyz/anchor"));
const web3_js_1 = require("@solana/web3.js");
const limo = __importStar(require("@kamino-finance/limo-sdk"));
const utils_1 = require("@kamino-finance/limo-sdk/dist/utils");
const svm_1 = require("../svm");
class SimpleSearcherSvm {
    endpointExpressRelay;
    chainId;
    searcher;
    endpointSvm;
    apiKey;
    client;
    connectionSvm;
    mintDecimals = {};
    expressRelayConfig;
    latestChainUpdate = {};
    bid;
    bidChainId = {};
    constructor(endpointExpressRelay, chainId, searcher, endpointSvm, bid, apiKey) {
        this.endpointExpressRelay = endpointExpressRelay;
        this.chainId = chainId;
        this.searcher = searcher;
        this.endpointSvm = endpointSvm;
        this.apiKey = apiKey;
        this.client = new index_1.Client({
            baseUrl: endpointExpressRelay,
            apiKey,
        }, undefined, this.opportunityHandler.bind(this), this.bidStatusHandler.bind(this), this.svmChainUpdateHandler.bind(this), this.removeOpportunitiesHandler.bind(this), this.websocketCloseHandler.bind(this));
        this.bid = new anchor.BN(bid);
        this.connectionSvm = new web3_js_1.Connection(endpointSvm, "confirmed");
    }
    async websocketCloseHandler() {
        console.log("Websocket closed. Exiting...");
        process.exit(1);
    }
    async bidStatusHandler(bidStatus) {
        console.log(`Bid status for bid ${bidStatus.id}: ${JSON.stringify(bidStatus)}`);
        // It's possible to cancel bids with status awaiting_signature
        // Doing it here randomly for demonstration purposes
        if (bidStatus.type === "awaiting_signature") {
            if (this.bidChainId[bidStatus.id] && Math.random() < 1.0 / 3.0) {
                try {
                    await this.client.cancelBid(bidStatus.id, this.bidChainId[bidStatus.id]);
                    console.log(`Cancelled bid ${bidStatus.id}`);
                }
                catch (error) {
                    console.error(`Failed to cancel bid ${bidStatus.id}: ${error}`);
                }
            }
        }
    }
    async getMintDecimalsCached(mint) {
        const mintAddress = mint.toBase58();
        if (this.mintDecimals[mintAddress]) {
            return this.mintDecimals[mintAddress];
        }
        const decimals = await (0, utils_1.getMintDecimals)(this.connectionSvm, mint);
        this.mintDecimals[mintAddress] = decimals;
        return decimals;
    }
    generateComputeBudgetInstructions() {
        // This limit assumes no other custom instructions exist in the transaction, you may need to adjust
        // this limit depending on your integration
        const computeLimitInstruction = web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: 300000,
        });
        const feeInstruction = web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: this.latestChainUpdate[this.chainId].latestPrioritizationFee,
        });
        return [computeLimitInstruction, feeInstruction];
    }
    /**
     * Generates a bid for a given limo opportunity.
     * The transaction in this bid transfers assets from the searcher's wallet to fulfill the limit order.
     * @param opportunity The SVM opportunity to bid on.
     * @returns The generated bid object.
     */
    async generateBidLimo(opportunity) {
        const order = opportunity.order;
        const limoClient = new limo.LimoClient(this.connectionSvm, order.state.globalConfig);
        const ixsTakeOrder = await this.generateTakeOrderIxs(limoClient, order);
        const bidAmount = await this.getBidAmount(opportunity);
        const config = await this.getExpressRelayConfig();
        const ixSubmitBid = await (0, svm_1.constructSubmitBidInstruction)(this.searcher.publicKey, (0, utils_1.getPdaAuthority)(limoClient.getProgramID(), order.state.globalConfig), order.address, bidAmount, new anchor.BN(Math.round(Date.now() / 1000 + 15)), this.chainId, config.relayerSigner, config.feeReceiverRelayer);
        const tx = new anchor.web3.Transaction().add(...this.generateComputeBudgetInstructions(), ixSubmitBid, ...ixsTakeOrder);
        tx.recentBlockhash = this.latestChainUpdate[this.chainId].blockhash;
        tx.sign(this.searcher);
        return {
            transaction: tx,
            chainId: this.chainId,
            type: "onchain",
            env: "svm",
            slot: opportunity.slot,
        };
    }
    /**
     * Generates a bid for a given swap opportunity.
     * The transaction in this bid transfers assets from the searcher's wallet to the specified wallets to fulfill the opportunity.
     * @param opportunity The SVM opportunity to bid on.
     * @returns The generated bid object.
     */
    async generateBidSwap(opportunity) {
        const bidAmount = await this.getBidAmount(opportunity);
        const txRaw = new anchor.web3.Transaction().add(...this.generateComputeBudgetInstructions());
        const config = await this.getExpressRelayConfig();
        const bid = await (0, svm_1.constructSwapBid)(txRaw, this.searcher.publicKey, opportunity, bidAmount, new anchor.BN(opportunity.minimumDeadline), this.chainId, config.feeReceiverRelayer, config.relayerSigner);
        bid.transaction.recentBlockhash =
            this.latestChainUpdate[this.chainId].blockhash;
        bid.transaction.feePayer = this.searcher.publicKey;
        bid.transaction.partialSign(this.searcher);
        return bid;
    }
    /**
     * Generates a bid for a given opportunity.
     * The transaction in this bid transfers assets from the searcher's wallet to fulfill the opportunity.
     * @param opportunity The SVM opportunity to bid on.
     * @returns The generated bid object.
     */
    async generateBid(opportunity) {
        if (opportunity.program === "limo") {
            return this.generateBidLimo(opportunity);
        }
        else {
            // swap opportunity
            return this.generateBidSwap(opportunity);
        }
    }
    async getExpressRelayConfig() {
        if (!this.expressRelayConfig) {
            this.expressRelayConfig = await this.client.getExpressRelaySvmConfig(this.chainId, this.connectionSvm);
        }
        return this.expressRelayConfig;
    }
    /**
     * Calculates the bid amount for a given order.
     * @param opportunity The opportunity to be fulfilled
     * @returns The bid amount in the necessary token
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getBidAmount(opportunity) {
        // this should be replaced by a more sophisticated logic to determine the bid amount
        return this.bid;
    }
    /**
     * Creates the take order instructions on the Limo program
     * @param limoClient The Limo client
     * @param order The limit order to be fulfilled
     * @returns The Limo TakeOrder instructions used to fulfill the order
     */
    async generateTakeOrderIxs(limoClient, order) {
        const inputMintDecimals = await this.getMintDecimalsCached(order.state.inputMint);
        const outputMintDecimals = await this.getMintDecimalsCached(order.state.outputMint);
        const inputAmount = this.getInputAmount(order);
        // take the ceiling of the division by adding order.state.initialInputAmount - 1
        const outputAmount = inputAmount
            .mul(order.state.expectedOutputAmount)
            .add(order.state.initialInputAmount)
            .sub(new anchor.BN(1))
            .div(order.state.initialInputAmount);
        console.log("Order address", order.address.toBase58());
        console.log("Fill rate", inputAmount.toNumber() / order.state.initialInputAmount.toNumber());
        console.log("Sell token", order.state.inputMint.toBase58(), "amount:", inputAmount.toNumber() / 10 ** inputMintDecimals);
        console.log("Buy token", order.state.outputMint.toBase58(), "amount:", outputAmount.toNumber() / 10 ** outputMintDecimals);
        return limoClient.takeOrderIx(this.searcher.publicKey, order, inputAmount, outputAmount, const_1.SVM_CONSTANTS[this.chainId].expressRelayProgram);
    }
    getInputAmount(order) {
        return order.state.remainingInputAmount;
    }
    async opportunityHandler(opportunity) {
        if (!this.latestChainUpdate[this.chainId]) {
            console.log(`No recent blockhash for chain ${this.chainId}, skipping bid`);
            return;
        }
        const bid = await this.generateBid(opportunity);
        try {
            const bidId = await this.client.submitBid(bid);
            this.bidChainId[bidId] = opportunity.chainId;
            console.log(`Successful bid. Opportunity id ${opportunity.opportunityId} Bid id ${bidId}`);
        }
        catch (error) {
            console.error(`Failed to bid on opportunity ${opportunity.opportunityId}: ${error}`);
        }
    }
    async svmChainUpdateHandler(update) {
        this.latestChainUpdate[update.chainId] = update;
    }
    // NOTE: Developers are responsible for implementing custom removal logic specific to their use case.
    async removeOpportunitiesHandler(opportunityDelete) {
        console.log(`Opportunities ${JSON.stringify(opportunityDelete)} don't exist anymore`);
    }
    async start() {
        console.log(`Using searcher pubkey: ${this.searcher.publicKey.toBase58()}`);
        try {
            await this.client.subscribeChains([this.chainId]);
            console.log(`Subscribed to chain ${this.chainId}. Waiting for opportunities...`);
        }
        catch (error) {
            console.error(error);
            this.client.websocket?.close();
        }
    }
}
exports.SimpleSearcherSvm = SimpleSearcherSvm;
function makeParser() {
    return (0, yargs_1.default)((0, helpers_1.hideBin)(process.argv))
        .option("endpoint-express-relay", {
        description: "Express relay endpoint. e.g: https://per-staging.dourolabs.app/",
        type: "string",
        demandOption: true,
    })
        .option("chain-id", {
        description: "Chain id to bid on Limo opportunities for. e.g: solana",
        type: "string",
        demandOption: true,
        choices: Object.keys(const_1.SVM_CONSTANTS),
    })
        .option("bid", {
        description: "Bid amount in lamports",
        type: "number",
        default: 100,
    })
        .option("private-key", {
        description: "Private key of the searcher in base58 format",
        type: "string",
        conflicts: "private-key-json-file",
    })
        .option("private-key-json-file", {
        description: "Path to a json file containing the private key of the searcher in array of bytes format",
        type: "string",
        conflicts: "private-key",
    })
        .option("api-key", {
        description: "The API key of the searcher to authenticate with the server for fetching and submitting bids",
        type: "string",
        demandOption: false,
    })
        .option("endpoint-svm", {
        description: "SVM RPC endpoint",
        type: "string",
        demandOption: true,
    })
        .help()
        .alias("help", "h");
}
function getKeypair(privateKey, privateKeyJsonFile) {
    if (privateKey) {
        const secretKey = anchor.utils.bytes.bs58.decode(privateKey);
        return web3_js_1.Keypair.fromSecretKey(secretKey);
    }
    else {
        if (privateKeyJsonFile) {
            return web3_js_1.Keypair.fromSecretKey(Uint8Array.from(JSON.parse(fs_1.default.readFileSync(privateKeyJsonFile, "utf-8"))));
        }
        else {
            throw new Error("Either private-key or private-key-json-file must be provided");
        }
    }
}
async function run() {
    const argv = makeParser().parseSync();
    const searcherKeyPair = getKeypair(argv.privateKey, argv.privateKeyJsonFile);
    const simpleSearcher = new SimpleSearcherSvm(argv.endpointExpressRelay, argv.chainId, searcherKeyPair, argv.endpointSvm, argv.bid, argv.apiKey);
    await simpleSearcher.start();
}
if (require.main === module) {
    run();
}
