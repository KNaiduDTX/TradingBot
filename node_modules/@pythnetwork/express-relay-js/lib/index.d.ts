import type { components } from "./serverTypes";
import { ClientOptions as FetchClientOptions } from "openapi-fetch";
import { Address, Hex } from "viem";
import WebSocket from "isomorphic-ws";
import { Bid, BidId, BidsResponse, BidStatusUpdate, ExpressRelaySvmConfig, Opportunity, OpportunityCreate, SvmChainUpdate, OpportunityDelete, QuoteRequest, QuoteResponse, BidSvmOnChain, BidSvmSwap, OpportunitySvmSwap, SubmitQuote } from "./types";
import { Connection, PublicKey, Transaction, TransactionInstruction } from "@solana/web3.js";
import * as anchor from "@coral-xyz/anchor";
import { VersionedTransaction } from "@solana/web3.js";
export * from "./types";
export * from "./const";
export declare class ClientError extends Error {
    static newHttpError(error: string, status?: number): ClientError;
    static newWebsocketError(error: string): ClientError;
}
type ClientOptions = FetchClientOptions & {
    baseUrl: string;
    apiKey?: string;
};
export interface WsOptions {
    /**
     * Max time to wait for a response from the server in milliseconds
     */
    response_timeout: number;
    /**
     * Heartbeat interval at which the server is expected to send a ping
     */
    ping_interval: number;
}
export declare function checkHex(hex: string): Hex;
export declare function checkAddress(address: string): Address;
export declare class Client {
    clientOptions: ClientOptions;
    wsOptions: WsOptions;
    websocket?: WebSocket;
    idCounter: number;
    callbackRouter: Record<string, (response: components["schemas"]["ServerResultMessage"]) => void>;
    private pingTimeout;
    private websocketOpportunityCallback?;
    private websocketBidStatusCallback?;
    private websocketSvmChainUpdateCallback?;
    private websocketRemoveOpportunitiesCallback?;
    private websocketCloseCallback;
    private getAuthorization;
    constructor(clientOptions: ClientOptions, wsOptions?: WsOptions, opportunityCallback?: (opportunity: Opportunity) => Promise<void>, bidStatusCallback?: (statusUpdate: BidStatusUpdate) => Promise<void>, svmChainUpdateCallback?: (update: SvmChainUpdate) => Promise<void>, removeOpportunitiesCallback?: (opportunityDelete: OpportunityDelete) => Promise<void>, websocketCloseCallback?: () => Promise<void>);
    private connectWebsocket;
    /**
     * Subscribes to the specified chains
     *
     * The opportunity handler will be called for opportunities on the specified chains
     * If the opportunity handler is not set, an error will be thrown
     * @param chains
     */
    subscribeChains(chains: string[]): Promise<void>;
    /**
     * Unsubscribes from the specified chains
     *
     * The opportunity handler will no longer be called for opportunities on the specified chains
     * @param chains
     */
    unsubscribeChains(chains: string[]): Promise<void>;
    /**
     * Cancels a bid
     *
     * Bids can only be cancelled if they are in awaiting_signature state
     * @param chains
     */
    cancelBid(bid_id: string, chain_id: string): Promise<void>;
    requestViaWebsocket(msg: components["schemas"]["ClientMessage"]): Promise<components["schemas"]["APIResponse"] | null>;
    /**
     * Fetches opportunities
     * @param chainId Chain id to fetch opportunities for. e.g: sepolia
     * @param fromTime A date object representing the datetime to fetch opportunities from. If undefined, fetches from the beginning of time.
     * @param limit Number of opportunities to return
     * @returns List of opportunities
     */
    getOpportunities(chainId?: string, fromTime?: Date, limit?: number): Promise<Opportunity[]>;
    /**
     * Submits an opportunity to be exposed to searchers
     * @param opportunity Opportunity to submit
     */
    submitOpportunity(opportunity: OpportunityCreate): Promise<void>;
    /**
     * Remove an opportunity from the server and update the searchers
     * @param opportunity Opportunity to be removed
     */
    removeOpportunity(opportunity: OpportunityDelete): Promise<void>;
    /**
     * Gets the best quote for a given quote request
     * @param quoteRequest Quote request to submit
     * @returns Quote response representing the best quote for the request
     */
    getQuote(quoteRequest: QuoteRequest): Promise<QuoteResponse>;
    /**
     * Posts a submit quote request to the server
     * @param submitQuote The quote data to be submitted on-chain
     * @returns The fully signed transaction that was submitted on-chain
     */
    submitQuote(submitQuote: SubmitQuote): Promise<VersionedTransaction>;
    /**
     * Submits a raw bid for a permission key
     * @param bid
     * @param subscribeToUpdates If true, the client will subscribe to bid status updates via websocket and will call the bid status callback if set
     * @returns The id of the submitted bid, you can use this id to track the status of the bid
     */
    submitBid(bid: Bid, subscribeToUpdates?: boolean): Promise<BidId>;
    /**
     * Get bids for an api key
     * @param fromTime The datetime to fetch bids from. If undefined or null, fetches from the beginning of time.
     * @returns The paginated bids response
     */
    getBids(fromTime?: Date): Promise<BidsResponse>;
    /**
     * Converts an opportunity from the server to the client format
     * Returns undefined if the opportunity version is not supported
     * @param opportunity
     * @returns Opportunity in the converted client format
     */
    convertOpportunity(opportunity: components["schemas"]["Opportunity"]): Opportunity | undefined;
    private toServerBid;
    /**
     * Converts a quote response from the server to the client format
     * @param quoteResponse
     * @returns Quote response in the converted client format
     */
    convertQuoteResponse(quoteResponse: components["schemas"]["QuoteSvm"]): QuoteResponse;
    /**
     * Fetches the Express Relay SVM config necessary for bidding
     * @param chainId The id for the chain you want to fetch the config for
     * @param connection The connection to use for fetching the config
     */
    getExpressRelaySvmConfig(chainId: string, connection: Connection): Promise<ExpressRelaySvmConfig>;
    /**
     * Constructs a SubmitBid instruction, which can be added to a transaction to permission it on the given permission key
     * @param searcher The address of the searcher that is submitting the bid
     * @param router The identifying address of the router that the permission key is for
     * @param permissionKey The 32-byte permission key as an SVM PublicKey
     * @param bidAmount The amount of the bid in lamports
     * @param deadline The deadline for the bid in seconds since Unix epoch
     * @param chainId The chain ID as a string, e.g. "solana"
     * @param relayerSigner The address of the relayer that is submitting the bid
     * @param feeReceiverRelayer The fee collection address of the relayer
     * @returns The SubmitBid instruction
     */
    constructSubmitBidInstruction(searcher: PublicKey, router: PublicKey, permissionKey: PublicKey, bidAmount: anchor.BN, deadline: anchor.BN, chainId: string, relayerSigner: PublicKey, feeReceiverRelayer: PublicKey): Promise<TransactionInstruction>;
    /**
     * Constructs an SVM On-chain bid, by adding a SubmitBid instruction to a transaction
     * @param tx The transaction to add a SubmitBid instruction to. This transaction should already check for the appropriate permissions.
     * @param searcher The address of the searcher that is submitting the bid
     * @param router The identifying address of the router that the permission key is for
     * @param permissionKey The 32-byte permission key as an SVM PublicKey
     * @param bidAmount The amount of the bid in lamports
     * @param deadline The deadline for the bid in seconds since Unix epoch
     * @param chainId The chain ID as a string, e.g. "solana"
     * @param relayerSigner The address of the relayer that is submitting the bid
     * @param feeReceiverRelayer The fee collection address of the relayer
     * @returns The constructed SVM bid
     */
    constructSvmBid(tx: Transaction, searcher: PublicKey, router: PublicKey, permissionKey: PublicKey, bidAmount: anchor.BN, deadline: anchor.BN, chainId: string, relayerSigner: PublicKey, feeReceiverRelayer: PublicKey): Promise<BidSvmOnChain>;
    /**
     * Constructs a Swap Bid, by adding swap instruction + idempotent token account creation instructions to a transaction
     * @param tx The transaction to add the instructions to
     * @param searcher The address of the searcher filling the swap order
     * @param swapOpportunity The swap opportunity to bid on
     * @param bidAmount The amount of the bid in either searcher side or user side tokens depending on the swap opportunity
     * @param deadline The deadline for the bid in seconds since Unix epoch
     * @param chainId The chain ID as a string, e.g. "solana"
     * @param feeReceiverRelayer The fee collection address of the relayer
     * @param relayerSigner The address of the relayer that is handling the bid
     */
    constructSwapBid(tx: Transaction, searcher: PublicKey, swapOpportunity: OpportunitySvmSwap, bidAmount: anchor.BN, deadline: anchor.BN, chainId: string, feeReceiverRelayer: PublicKey, relayerSigner: PublicKey): Promise<BidSvmSwap>;
}
//# sourceMappingURL=index.d.ts.map