"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Serum3Side = exports.Serum3SelfTradeBehavior = exports.Serum3OrderType = exports.Serum3Market = void 0;
exports.generateSerum3MarketExternalVaultSignerAddress = generateSerum3MarketExternalVaultSignerAddress;
const bytes_1 = require("@coral-xyz/anchor/dist/cjs/utils/bytes");
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("../constants");
const I80F48_1 = require("../numbers/I80F48");
class Serum3Market {
    publicKey;
    group;
    baseTokenIndex;
    quoteTokenIndex;
    serumProgram;
    serumMarketExternal;
    marketIndex;
    registrationTime;
    reduceOnly;
    forceClose;
    oraclePriceBand;
    name;
    static from(publicKey, obj) {
        return new Serum3Market(publicKey, obj.group, obj.baseTokenIndex, obj.quoteTokenIndex, obj.name, obj.serumProgram, obj.serumMarketExternal, obj.marketIndex, obj.registrationTime, obj.reduceOnly == 1, obj.forceClose == 1, obj.oraclePriceBand);
    }
    constructor(publicKey, group, baseTokenIndex, quoteTokenIndex, name, serumProgram, serumMarketExternal, marketIndex, registrationTime, reduceOnly, forceClose, oraclePriceBand) {
        this.publicKey = publicKey;
        this.group = group;
        this.baseTokenIndex = baseTokenIndex;
        this.quoteTokenIndex = quoteTokenIndex;
        this.serumProgram = serumProgram;
        this.serumMarketExternal = serumMarketExternal;
        this.marketIndex = marketIndex;
        this.registrationTime = registrationTime;
        this.reduceOnly = reduceOnly;
        this.forceClose = forceClose;
        this.oraclePriceBand = oraclePriceBand;
        this.name = bytes_1.utf8.decode(new Uint8Array(name)).split('\x00')[0];
    }
    async findOoPda(programId, mangoAccount) {
        const [openOrderPublicKey] = await web3_js_1.PublicKey.findProgramAddress([
            Buffer.from('Serum3OO'),
            mangoAccount.toBuffer(),
            this.publicKey.toBuffer(),
        ], programId);
        return openOrderPublicKey;
    }
    getFeeRates(taker = true) {
        // See https://github.com/openbook-dex/program/blob/master/dex/src/fees.rs#L81
        const ratesBps = this.name === 'USDT/USDC'
            ? { maker: -0.5, taker: 1 }
            : { maker: -2, taker: 4 };
        return taker ? ratesBps.taker * 0.0001 : ratesBps.maker * 0.0001;
    }
    /**
     *
     * @param group
     * @returns maximum leverage one can bid on this market, this is only for display purposes,
     *  also see getMaxQuoteForSerum3BidUi and getMaxBaseForSerum3AskUi
     */
    maxBidLeverage(group) {
        const baseBank = group.getFirstBankByTokenIndex(this.baseTokenIndex);
        const quoteBank = group.getFirstBankByTokenIndex(this.quoteTokenIndex);
        if (quoteBank.initLiabWeight.sub(baseBank.initAssetWeight).lte((0, I80F48_1.ZERO_I80F48)())) {
            return (0, I80F48_1.MAX_I80F48)().toNumber();
        }
        return (0, I80F48_1.ONE_I80F48)()
            .div(quoteBank.initLiabWeight.sub(baseBank.initAssetWeight))
            .toNumber();
    }
    /**
     *
     * @param group
     * @returns maximum leverage one can ask on this market, this is only for display purposes,
     *  also see getMaxQuoteForSerum3BidUi and getMaxBaseForSerum3AskUi
     */
    maxAskLeverage(group) {
        const baseBank = group.getFirstBankByTokenIndex(this.baseTokenIndex);
        const quoteBank = group.getFirstBankByTokenIndex(this.quoteTokenIndex);
        if (baseBank.initLiabWeight.sub(quoteBank.initAssetWeight).lte((0, I80F48_1.ZERO_I80F48)())) {
            return (0, I80F48_1.MAX_I80F48)().toNumber();
        }
        return (0, I80F48_1.ONE_I80F48)()
            .div(baseBank.initLiabWeight.sub(quoteBank.initAssetWeight))
            .toNumber();
    }
    async loadBids(client, group) {
        const serum3MarketExternal = group.getSerum3ExternalMarket(this.serumMarketExternal);
        return await serum3MarketExternal.loadBids(client.program.provider.connection);
    }
    async loadAsks(client, group) {
        const serum3MarketExternal = group.getSerum3ExternalMarket(this.serumMarketExternal);
        return await serum3MarketExternal.loadAsks(client.program.provider.connection);
    }
    async computePriceForMarketOrderOfSize(client, group, size, side) {
        const ob = side == 'buy'
            ? await this.loadBids(client, group)
            : await this.loadAsks(client, group);
        let acc = 0;
        let selectedOrder;
        const orderSize = size;
        for (const order of ob.getL2(size * 2 /* TODO Fix random constant */)) {
            acc += order[1];
            if (acc >= orderSize) {
                selectedOrder = order;
                break;
            }
        }
        if (!selectedOrder) {
            throw new Error('Unable to place market order for this order size. Please retry.');
        }
        if (side === 'buy') {
            return selectedOrder[0] * 1.05 /* TODO Fix random constant */;
        }
        else {
            return selectedOrder[0] * 0.95 /* TODO Fix random constant */;
        }
    }
    async logOb(client, group) {
        let res = ``;
        res += `  ${this.name} OrderBook`;
        let orders = await this?.loadAsks(client, group);
        for (const order of orders.items(true)) {
            res += `\n  ${order.price.toString().padStart(10)}, ${order.size
                .toString()
                .padStart(10)}`;
        }
        res += `\n  --------------------------`;
        orders = await this?.loadBids(client, group);
        for (const order of orders.items(true)) {
            res += `\n  ${order.price.toString().padStart(10)}, ${order.size
                .toString()
                .padStart(10)}`;
        }
        return res;
    }
}
exports.Serum3Market = Serum3Market;
// eslint-disable-next-line @typescript-eslint/no-namespace
var Serum3OrderType;
(function (Serum3OrderType) {
    Serum3OrderType.limit = { limit: {} };
    Serum3OrderType.immediateOrCancel = { immediateOrCancel: {} };
    Serum3OrderType.postOnly = { postOnly: {} };
})(Serum3OrderType || (exports.Serum3OrderType = Serum3OrderType = {}));
// eslint-disable-next-line @typescript-eslint/no-namespace
var Serum3SelfTradeBehavior;
(function (Serum3SelfTradeBehavior) {
    Serum3SelfTradeBehavior.decrementTake = { decrementTake: {} };
    Serum3SelfTradeBehavior.cancelProvide = { cancelProvide: {} };
    Serum3SelfTradeBehavior.abortTransaction = { abortTransaction: {} };
})(Serum3SelfTradeBehavior || (exports.Serum3SelfTradeBehavior = Serum3SelfTradeBehavior = {}));
// eslint-disable-next-line @typescript-eslint/no-namespace
var Serum3Side;
(function (Serum3Side) {
    Serum3Side.bid = { bid: {} };
    Serum3Side.ask = { ask: {} };
})(Serum3Side || (exports.Serum3Side = Serum3Side = {}));
async function generateSerum3MarketExternalVaultSignerAddress(cluster, serum3Market, serum3MarketExternal) {
    return await web3_js_1.PublicKey.createProgramAddress([
        serum3Market.serumMarketExternal.toBuffer(),
        serum3MarketExternal.decoded.vaultSignerNonce.toArrayLike(Buffer, 'le', 8),
    ], constants_1.OPENBOOK_PROGRAM_ID[cluster]);
}
