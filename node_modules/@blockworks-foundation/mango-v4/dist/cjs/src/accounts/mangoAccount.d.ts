import { BN } from '@coral-xyz/anchor';
import { OpenOrders, Order } from '@project-serum/serum/lib/market';
import { PublicKey, TransactionInstruction } from '@solana/web3.js';
import { MangoClient } from '../client';
import { I80F48, I80F48Dto } from '../numbers/I80F48';
import { MangoSignatureStatus } from '../utils/rpc';
import { Bank, TokenIndex } from './bank';
import { Group } from './group';
import { PerpMarket, PerpMarketIndex, PerpOrder } from './perp';
import { MarketIndex } from './serum3';
export declare class MangoAccount {
    publicKey: PublicKey;
    group: PublicKey;
    owner: PublicKey;
    delegate: PublicKey;
    accountNum: number;
    beingLiquidated: boolean;
    inHealthRegion: boolean;
    netDeposits: BN;
    perpSpotTransfers: BN;
    healthRegionBeginInitHealth: BN;
    frozenUntil: BN;
    buybackFeesAccruedCurrent: BN;
    buybackFeesAccruedPrevious: BN;
    buybackFeesExpiryTimestamp: BN;
    sequenceNumber: number;
    headerVersion: number;
    lastCollateralFeeCharge: BN;
    serum3OosMapByMarketIndex: Map<number, OpenOrders>;
    name: string;
    tokens: TokenPosition[];
    serum3: Serum3Orders[];
    perps: PerpPosition[];
    perpOpenOrders: PerpOo[];
    tokenConditionalSwaps: TokenConditionalSwap[];
    static from(publicKey: PublicKey, obj: {
        group: PublicKey;
        owner: PublicKey;
        name: number[];
        delegate: PublicKey;
        accountNum: number;
        beingLiquidated: number;
        inHealthRegion: number;
        netDeposits: BN;
        perpSpotTransfers: BN;
        healthRegionBeginInitHealth: BN;
        frozenUntil: BN;
        buybackFeesAccruedCurrent: BN;
        buybackFeesAccruedPrevious: BN;
        buybackFeesExpiryTimestamp: BN;
        sequenceNumber: number;
        headerVersion: number;
        tokens: unknown;
        serum3: unknown;
        perps: unknown;
        perpOpenOrders: unknown;
        tokenConditionalSwaps: unknown;
        lastCollateralFeeCharge: BN;
    }): MangoAccount;
    constructor(publicKey: PublicKey, group: PublicKey, owner: PublicKey, name: number[], delegate: PublicKey, accountNum: number, beingLiquidated: boolean, inHealthRegion: boolean, netDeposits: BN, perpSpotTransfers: BN, healthRegionBeginInitHealth: BN, frozenUntil: BN, buybackFeesAccruedCurrent: BN, buybackFeesAccruedPrevious: BN, buybackFeesExpiryTimestamp: BN, sequenceNumber: number, headerVersion: number, lastCollateralFeeCharge: BN, tokens: TokenPositionDto[], serum3: Serum3PositionDto[], perps: PerpPositionDto[], perpOpenOrders: PerpOoDto[], tokenConditionalSwaps: TokenConditionalSwapDto[], serum3OosMapByMarketIndex: Map<number, OpenOrders>);
    reload(client: MangoClient): Promise<MangoAccount>;
    reloadWithSlot(client: MangoClient): Promise<{
        value: MangoAccount;
        slot: number;
    }>;
    reloadSerum3OpenOrders(client: MangoClient): Promise<MangoAccount>;
    loadSerum3OpenOrders(serum3OosMapByOo: Map<string, OpenOrders>): void;
    isDelegate(client: MangoClient): boolean;
    isOperational(): boolean;
    tokenPositionsForNotConfidentOrStaleOracles(client: MangoClient, group: Group): Promise<Bank[]>;
    tokensActive(): TokenPosition[];
    serum3Active(): Serum3Orders[];
    tokenConditionalSwapsActive(): TokenConditionalSwap[];
    perpPositionExistsForMarket(perpMarket: PerpMarket): boolean;
    perpOrderExistsForMarket(perpMarket: PerpMarket): boolean;
    perpActive(): PerpPosition[];
    perpOrdersActive(): PerpOo[];
    getToken(tokenIndex: TokenIndex): TokenPosition | undefined;
    getSerum3Account(marketIndex: MarketIndex): Serum3Orders | undefined;
    getPerpPosition(perpMarketIndex: PerpMarketIndex): PerpPosition | undefined;
    getPerpPositionUi(group: Group, perpMarketIndex: PerpMarketIndex, useEventQueue?: boolean): number;
    getSerum3OoAccount(marketIndex: MarketIndex): OpenOrders;
    /**
     *
     * @param bank
     * @returns native balance for a token, is signed
     */
    getTokenBalance(bank: Bank): I80F48;
    getEffectiveTokenBalance(group: Group, bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns native deposits for a token, 0 if position has borrows
     */
    getTokenDeposits(bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns native borrows for a token, 0 if position has deposits
     */
    getTokenBorrows(bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns UI balance for a token, is signed
     */
    getTokenBalanceUi(bank: Bank): number;
    getTokenInUseCount(bank: Bank): number;
    /**
     *
     * @param bank
     * @returns UI deposits for a token, 0 or more
     */
    getTokenDepositsUi(bank: Bank): number;
    /**
     *
     * @param bank
     * @returns UI borrows for a token, 0 or less
     */
    getTokenBorrowsUi(bank: Bank): number;
    /**
     * Health, see health.rs or https://docs.mango.markets/mango-markets/health-overview
     * @param healthType
     * @returns raw health number, in native quote
     */
    getHealth(group: Group, healthType: HealthType): I80F48;
    getHealthContributionPerAssetUi(group: Group, healthType: HealthType): {
        asset: string;
        contribution: number;
        contributionDetails: {
            spotUi: number;
            perpMarketContributions: {
                market: string;
                contributionUi: number;
            }[];
        } | undefined;
    }[];
    perpMaxSettle(group: Group, perpMarketSettleTokenIndex: TokenIndex): I80F48;
    /**
     * Health ratio, which is computed so `100 * (assets-liabs)/liabs`
     * Note: health ratio is technically ∞ if liabs are 0
     * @param healthType
     * @returns health ratio, in percentage form
     */
    getHealthRatio(group: Group, healthType: HealthType): I80F48;
    /**
     * Health ratio
     * @param healthType
     * @returns health ratio, in percentage form, capped to 100
     */
    getHealthRatioUi(group: Group, healthType: HealthType): number;
    /**
     * Sum of all the assets i.e. token deposits, borrows, total assets in spot open orders, and perps positions.
     * @returns equity, in native quote
     */
    getEquity(group: Group): I80F48;
    /**
     * The amount of native quote you could withdraw against your existing assets.
     * @returns collateral value, in native quote
     */
    getCollateralValue(group: Group): I80F48;
    /**
     * Sum of all positive assets.
     * @returns assets, in native quote
     */
    getAssetsValue(group: Group, healthType?: HealthType): I80F48;
    /**
     * Sum of all negative assets.
     * @returns liabs, in native quote
     */
    getLiabsValue(group: Group): I80F48;
    /**
     * @returns Overall PNL, in native quote
     * PNL is defined here as spot value + serum3 open orders value + perp value - net deposits value (evaluated at native quote price at the time of the deposit/withdraw)
     * spot value + serum3 open orders value + perp value is returned by getEquity (open orders values are added to spot token values implicitly)
     */
    getPnl(group: Group): I80F48;
    /**
     * @returns token cumulative interest, in native token units. Sum of deposit and borrow interest.
     * Caveat: This will only return cumulative interest since the tokenPosition was last opened.
     * If the tokenPosition was closed and reopened multiple times it is necessary to add this result to
     * cumulative interest at each of the prior tokenPosition closings (from mango API) to get the all time
     * cumulative interest.
     */
    getCumulativeInterest(bank: Bank): number;
    /**
     * The amount of given native token you can withdraw including borrows, considering all existing assets as collateral.
     * @returns amount of given native token you can borrow, considering all existing assets as collateral, in native token
     *
     * TODO: take into account net_borrow_limit and min_vault_to_deposits_ratio
     * TODO: see max_borrow_for_health_fn
     */
    getMaxWithdrawWithBorrowForToken(group: Group, mintPk: PublicKey): I80F48;
    getMaxWithdrawWithBorrowForTokenUi(group: Group, mintPk: PublicKey): number;
    calculateEquivalentSourceAmount(sourceBank: Bank, targetBank: Bank, targetRemainingDepositLimit: BN): I80F48;
    /**
     * The max amount of given source ui token you can swap to a target token.
     * @returns max amount of given source ui token you can swap to a target token, in ui token
     */
    getMaxSourceUiForTokenSwap(group: Group, sourceMintPk: PublicKey, targetMintPk: PublicKey, slippageAndFeesFactor?: number): number;
    /**
     * Simulates new health ratio after applying tokenChanges to the token positions.
     * Note: token changes are expected in ui amounts
     *
     * e.g. useful to simulate health after a potential swap.
     * Note: health ratio is technically ∞ if liabs are 0
     * @returns health ratio, in percentage form
     */
    simHealthRatioWithTokenPositionUiChanges(group: Group, uiTokenChanges: {
        uiTokenAmount: number;
        mintPk: PublicKey;
    }[], healthType?: HealthType): number;
    loadSerum3OpenOrdersAccounts(client: MangoClient): Promise<OpenOrders[]>;
    loadSerum3OpenOrdersForMarket(client: MangoClient, group: Group, externalMarketPk: PublicKey): Promise<Order[]>;
    /**
     * TODO REWORK, know to break in binary search, also make work for limit orders
     *
     * @param group
     * @param externalMarketPk
     * @returns maximum ui quote which can be traded at oracle price for base token given current health
     */
    getMaxQuoteForSerum3BidUi(group: Group, externalMarketPk: PublicKey): number;
    /**
     * TODO REWORK, know to break in binary search, also make work for limit orders
     * @param group
     * @param externalMarketPk
     * @returns maximum ui base which can be traded at oracle price for quote token given current health
     */
    getMaxBaseForSerum3AskUi(group: Group, externalMarketPk: PublicKey): number;
    /**
     *
     * @param group
     * @param uiQuoteAmount
     * @param externalMarketPk
     * @param healthType
     * @returns health ratio after a bid with uiQuoteAmount is placed
     */
    simHealthRatioWithSerum3BidUiChanges(group: Group, uiQuoteAmount: number, externalMarketPk: PublicKey, healthType?: HealthType): number;
    /**
     *
     * @param group
     * @param uiBaseAmount
     * @param externalMarketPk
     * @param healthType
     * @returns health ratio after an ask with uiBaseAmount is placed
     */
    simHealthRatioWithSerum3AskUiChanges(group: Group, uiBaseAmount: number, externalMarketPk: PublicKey, healthType?: HealthType): number;
    serum3SettleFundsForAllMarkets(client: MangoClient, group: Group): Promise<MangoSignatureStatus[]>;
    serum3CancelAllOrdersForAllMarkets(client: MangoClient, group: Group): Promise<MangoSignatureStatus[]>;
    /**
     * TODO: also think about limit orders
     *
     * The max ui quote you can place a market/ioc bid on the market,
     * price is the ui price at which you think the order would materialiase.
     * @param group
     * @param perpMarketName
     * @returns maximum ui quote which can be traded at oracle price for quote token given current health
     */
    getMaxQuoteForPerpBidUi(group: Group, perpMarketIndex: PerpMarketIndex): number;
    /**
     * TODO: also think about limit orders
     *
     * The max ui base you can place a market/ioc ask on the market,
     * price is the ui price at which you think the order would materialiase.
     * @param group
     * @param perpMarketName
     * @param uiPrice ui price at which ask would be placed at
     * @returns max ui base ask
     */
    getMaxBaseForPerpAskUi(group: Group, perpMarketIndex: PerpMarketIndex): number;
    simHealthRatioWithPerpBidUiChanges(group: Group, perpMarketIndex: PerpMarketIndex, size: number, healthType?: HealthType): number;
    simHealthRatioWithPerpAskUiChanges(group: Group, perpMarketIndex: PerpMarketIndex, size: number, healthType?: HealthType): number;
    loadPerpOpenOrdersForMarket(client: MangoClient, group: Group, perpMarketIndex: PerpMarketIndex, forceReload?: boolean): Promise<PerpOrder[]>;
    getBuybackFeesAccrued(): BN;
    getBuybackFeesAccruedUi(): number;
    getMaxFeesBuyback(group: Group): BN;
    getMaxFeesBuybackUi(group: Group): number;
    buildIxsForStaleOrUnconfidentOracles(client: MangoClient, group: Group): Promise<TransactionInstruction[]>;
    buildIxsForStaleOrUnconfidentOraclesInternal(group: Group, relevantOraclesToAUserAction: PublicKey[]): Promise<TransactionInstruction[]>;
    toString(group?: Group, onlyTokens?: boolean): string;
}
export declare class TokenPosition {
    indexedPosition: I80F48;
    tokenIndex: TokenIndex;
    inUseCount: number;
    previousIndex: I80F48;
    cumulativeDepositInterest: number;
    cumulativeBorrowInterest: number;
    static TokenIndexUnset: number;
    static from(dto: TokenPositionDto): TokenPosition;
    constructor(indexedPosition: I80F48, tokenIndex: TokenIndex, inUseCount: number, previousIndex: I80F48, cumulativeDepositInterest: number, cumulativeBorrowInterest: number);
    isActive(): boolean;
    /**
     *
     * @param bank
     * @returns native balance
     */
    balance(bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns native deposits, 0 if position has borrows
     */
    deposits(bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns native borrows, 0 if position has deposits
     */
    borrows(bank: Bank): I80F48;
    /**
     * @param bank
     * @returns UI balance, is signed
     */
    balanceUi(bank: Bank): number;
    /**
     * @param bank
     * @returns UI deposits, 0 if position has borrows
     */
    depositsUi(bank: Bank): number;
    /**
     * @param bank
     * @returns UI borrows, 0 if position has deposits
     */
    borrowsUi(bank: Bank): number;
    toString(group?: Group, index?: number): string;
}
export declare class TokenPositionDto {
    indexedPosition: I80F48Dto;
    tokenIndex: number;
    inUseCount: number;
    reserved: number[];
    previousIndex: I80F48Dto;
    cumulativeDepositInterest: number;
    cumulativeBorrowInterest: number;
    constructor(indexedPosition: I80F48Dto, tokenIndex: number, inUseCount: number, reserved: number[], previousIndex: I80F48Dto, cumulativeDepositInterest: number, cumulativeBorrowInterest: number);
}
export declare class Serum3Orders {
    openOrders: PublicKey;
    marketIndex: MarketIndex;
    baseTokenIndex: TokenIndex;
    quoteTokenIndex: TokenIndex;
    highestPlacedBidInv: number;
    lowestPlacedAsk: number;
    static Serum3MarketIndexUnset: number;
    static from(dto: Serum3PositionDto): Serum3Orders;
    constructor(openOrders: PublicKey, marketIndex: MarketIndex, baseTokenIndex: TokenIndex, quoteTokenIndex: TokenIndex, highestPlacedBidInv: number, lowestPlacedAsk: number);
    isActive(): boolean;
}
export declare class Serum3PositionDto {
    openOrders: PublicKey;
    marketIndex: number;
    baseBorrowsWithoutFee: BN;
    quoteBorrowsWithoutFee: BN;
    baseTokenIndex: number;
    quoteTokenIndex: number;
    highestPlacedBidInv: number;
    lowestPlacedAsk: number;
    reserved: number[];
    constructor(openOrders: PublicKey, marketIndex: number, baseBorrowsWithoutFee: BN, quoteBorrowsWithoutFee: BN, baseTokenIndex: number, quoteTokenIndex: number, highestPlacedBidInv: number, lowestPlacedAsk: number, reserved: number[]);
}
export interface CumulativeFunding {
    cumulativeLongFunding: number;
    cumulativeShortFunding: number;
}
export declare class PerpPosition {
    marketIndex: PerpMarketIndex;
    settlePnlLimitWindow: number;
    settlePnlLimitSettledInCurrentWindowNative: BN;
    basePositionLots: BN;
    quotePositionNative: I80F48;
    quoteRunningNative: BN;
    longSettledFunding: I80F48;
    shortSettledFunding: I80F48;
    bidsBaseLots: BN;
    asksBaseLots: BN;
    takerBaseLots: BN;
    takerQuoteLots: BN;
    cumulativeLongFunding: number;
    cumulativeShortFunding: number;
    makerVolume: BN;
    takerVolume: BN;
    perpSpotTransfers: BN;
    avgEntryPricePerBaseLot: number;
    deprecatedRealizedTradePnlNative: I80F48;
    oneshotSettlePnlAllowance: I80F48;
    recurringSettlePnlAllowance: BN;
    realizedPnlForPositionNative: I80F48;
    static PerpMarketIndexUnset: number;
    static from(dto: PerpPositionDto): PerpPosition;
    static emptyFromPerpMarketIndex(perpMarketIndex: PerpMarketIndex): PerpPosition;
    constructor(marketIndex: PerpMarketIndex, settlePnlLimitWindow: number, settlePnlLimitSettledInCurrentWindowNative: BN, basePositionLots: BN, quotePositionNative: I80F48, quoteRunningNative: BN, longSettledFunding: I80F48, shortSettledFunding: I80F48, bidsBaseLots: BN, asksBaseLots: BN, takerBaseLots: BN, takerQuoteLots: BN, cumulativeLongFunding: number, cumulativeShortFunding: number, makerVolume: BN, takerVolume: BN, perpSpotTransfers: BN, avgEntryPricePerBaseLot: number, deprecatedRealizedTradePnlNative: I80F48, oneshotSettlePnlAllowance: I80F48, recurringSettlePnlAllowance: BN, realizedPnlForPositionNative: I80F48);
    isActive(): boolean;
    getBasePosition(perpMarket: PerpMarket): I80F48;
    getBasePositionUi(perpMarket: PerpMarket, useEventQueue?: boolean): number;
    getQuotePositionUi(perpMarket: PerpMarket, useEventQueue?: boolean): number;
    getNotionalValueUi(perpMarket: PerpMarket, useEventQueue?: boolean): number;
    getUnsettledFunding(perpMarket: PerpMarket): I80F48;
    getUnsettledFundingUi(perpMarket: PerpMarket): number;
    /**
     * @returns perp position cumulative funding, in quote token units.
     * If the user paid $1 in funding for a short position, this would be -1e6.
     * Caveat: This will only return cumulative interest since the perp position was last opened.
     * If the perp position was closed and reopened multiple times it is necessary to add this result to
     * cumulative funding at each of the prior perp position closings (from mango API) to get the all time
     * cumulative funding.
     */
    getCumulativeFunding(perpMarket: PerpMarket): CumulativeFunding;
    /**
     * @returns perp position cumulative funding.
     * Caveat: This will only return cumulative interest since the perp position was last opened.
     */
    getCumulativeFundingUi(perpMarket: PerpMarket): number;
    getEquity(perpMarket: PerpMarket): I80F48;
    getEquityUi(perpMarket: PerpMarket): number;
    hasOpenOrders(): boolean;
    getAverageEntryPrice(perpMarket: PerpMarket): I80F48;
    getAverageEntryPriceUi(perpMarket: PerpMarket): number;
    getLiquidationPrice(group: Group, mangoAccount: MangoAccount): I80F48 | null;
    getLiquidationPriceUi(group: Group, mangoAccount: MangoAccount): number | null;
    getBreakEvenPrice(perpMarket: PerpMarket): I80F48;
    getBreakEvenPriceUi(perpMarket: PerpMarket): number;
    canSettlePnl(group: Group, perpMarket: PerpMarket, account: MangoAccount): boolean;
    updateSettleLimit(perpMarket: PerpMarket): void;
    availableSettleLimit(perpMarket: PerpMarket): [BN, BN];
    applyPnlSettleLimit(pnl: I80F48, perpMarket: PerpMarket): I80F48;
    getUnsettledPnl(perpMarket: PerpMarket): I80F48;
    getUnsettledPnlUi(perpMarket: PerpMarket): number;
    getSettleablePnl(group: Group, perpMarket: PerpMarket, account: MangoAccount): I80F48;
    getSettleablePnlUi(group: Group, perpMarket: PerpMarket, account: MangoAccount): number;
    cumulativePnlOverPositionLifetimeUi(perpMarket: PerpMarket): number;
    getUnRealizedPnlUi(perpMarket: PerpMarket): number;
    getRealizedPnlUi(): number;
    toString(perpMarket?: PerpMarket): string;
}
export declare class PerpPositionDto {
    marketIndex: number;
    settlePnlLimitWindow: number;
    settlePnlLimitSettledInCurrentWindowNative: BN;
    basePositionLots: BN;
    quotePositionNative: {
        val: BN;
    };
    quoteRunningNative: BN;
    longSettledFunding: I80F48Dto;
    shortSettledFunding: I80F48Dto;
    bidsBaseLots: BN;
    asksBaseLots: BN;
    takerBaseLots: BN;
    takerQuoteLots: BN;
    cumulativeLongFunding: number;
    cumulativeShortFunding: number;
    makerVolume: BN;
    takerVolume: BN;
    perpSpotTransfers: BN;
    avgEntryPricePerBaseLot: number;
    deprecatedRealizedTradePnlNative: I80F48Dto;
    oneshotSettlePnlAllowance: I80F48Dto;
    recurringSettlePnlAllowance: BN;
    realizedPnlForPositionNative: I80F48Dto;
    constructor(marketIndex: number, settlePnlLimitWindow: number, settlePnlLimitSettledInCurrentWindowNative: BN, basePositionLots: BN, quotePositionNative: {
        val: BN;
    }, quoteRunningNative: BN, longSettledFunding: I80F48Dto, shortSettledFunding: I80F48Dto, bidsBaseLots: BN, asksBaseLots: BN, takerBaseLots: BN, takerQuoteLots: BN, cumulativeLongFunding: number, cumulativeShortFunding: number, makerVolume: BN, takerVolume: BN, perpSpotTransfers: BN, avgEntryPricePerBaseLot: number, deprecatedRealizedTradePnlNative: I80F48Dto, oneshotSettlePnlAllowance: I80F48Dto, recurringSettlePnlAllowance: BN, realizedPnlForPositionNative: I80F48Dto);
}
export declare class PerpOo {
    sideAndTree: any;
    orderMarket: number;
    clientId: BN;
    id: BN;
    static OrderMarketUnset: number;
    static from(dto: PerpOoDto): PerpOo;
    constructor(sideAndTree: any, orderMarket: number, clientId: BN, id: BN);
    isActive(): boolean;
}
export declare class PerpOoDto {
    sideAndTree: any;
    market: number;
    clientId: BN;
    id: BN;
    constructor(sideAndTree: any, market: number, clientId: BN, id: BN);
}
export type TokenConditionalSwapDisplayPriceStyle = {
    sellTokenPerBuyToken: Record<string, never>;
} | {
    buyTokenPerSellToken: Record<string, never>;
};
export declare namespace TokenConditionalSwapDisplayPriceStyle {
    const sellTokenPerBuyToken: {
        sellTokenPerBuyToken: {};
    };
    const buyTokenPerSellToken: {
        buyTokenPerSellToken: {};
    };
}
export type TokenConditionalSwapIntention = {
    unknown: Record<string, never>;
} | {
    stopLoss: Record<string, never>;
} | {
    takeProfit: Record<string, never>;
};
export declare namespace TokenConditionalSwapIntention {
    const unknown: {
        unknown: {};
    };
    const stopLoss: {
        stopLoss: {};
    };
    const takeProfit: {
        takeProfit: {};
    };
}
export declare class TokenConditionalSwap {
    id: BN;
    maxBuy: BN;
    maxSell: BN;
    bought: BN;
    sold: BN;
    expiryTimestamp: BN;
    priceLowerLimit: number;
    priceUpperLimit: number;
    pricePremiumRate: number;
    takerFeeRate: number;
    makerFeeRate: number;
    buyTokenIndex: TokenIndex;
    sellTokenIndex: TokenIndex;
    isConfigured: boolean;
    allowCreatingDeposits: boolean;
    allowCreatingBorrows: boolean;
    priceDisplayStyle: TokenConditionalSwapDisplayPriceStyle;
    intention: TokenConditionalSwapIntention;
    static from(dto: TokenConditionalSwapDto): TokenConditionalSwap;
    constructor(id: BN, maxBuy: BN, maxSell: BN, bought: BN, sold: BN, expiryTimestamp: BN, priceLowerLimit: number, priceUpperLimit: number, pricePremiumRate: number, takerFeeRate: number, makerFeeRate: number, buyTokenIndex: TokenIndex, sellTokenIndex: TokenIndex, isConfigured: boolean, allowCreatingDeposits: boolean, allowCreatingBorrows: boolean, priceDisplayStyle: TokenConditionalSwapDisplayPriceStyle, intention: TokenConditionalSwapIntention);
    getMaxBuyUi(group: Group): number;
    getMaxSellUi(group: Group): number;
    getBoughtUi(group: Group): number;
    getSoldUi(group: Group): number;
    getExpiryTimestampInEpochSeconds(): number;
    private priceLimitToUi;
    getPriceLowerLimitUi(group: Group): number;
    getPriceUpperLimitUi(group: Group): number;
    getThresholdPriceUi(group: Group): number;
    getCurrentPairPriceUi(group: Group): number;
    getPricePremium(): number;
    getCurrentlySuggestedPremium(group: Group): number;
    static computePremium(group: Group, buyBank: Bank, sellBank: Bank, maxBuy: BN, maxSell: BN, maxBuyUi: number, maxSellUi: number): number;
    getBuyToken(group: Group): Bank;
    getSellToken(group: Group): Bank;
    getAllowCreatingDeposits(): boolean;
    getAllowCreatingBorrows(): boolean;
    toString(group: Group): string;
}
export declare class TokenConditionalSwapDto {
    id: BN;
    maxBuy: BN;
    maxSell: BN;
    bought: BN;
    sold: BN;
    expiryTimestamp: BN;
    priceLowerLimit: number;
    priceUpperLimit: number;
    pricePremiumRate: number;
    takerFeeRate: number;
    makerFeeRate: number;
    buyTokenIndex: number;
    sellTokenIndex: number;
    isConfigured: number;
    allowCreatingDeposits: number;
    allowCreatingBorrows: number;
    displayPriceStyle: number;
    intention: number;
    constructor(id: BN, maxBuy: BN, maxSell: BN, bought: BN, sold: BN, expiryTimestamp: BN, priceLowerLimit: number, priceUpperLimit: number, pricePremiumRate: number, takerFeeRate: number, makerFeeRate: number, buyTokenIndex: number, sellTokenIndex: number, isConfigured: number, allowCreatingDeposits: number, allowCreatingBorrows: number, displayPriceStyle: number, intention: number);
}
export declare class HealthType {
    static maint: {
        maint: {};
    };
    static init: {
        init: {};
    };
    static liquidationEnd: {
        liquidationEnd: {};
    };
}
