import { BN, Program, Provider } from '@coral-xyz/anchor';
import { AccountInfo, AddressLookupTableAccount, Cluster, Commitment, Connection, PublicKey, TransactionInstruction, VersionedTransaction } from '@solana/web3.js';
import { Bank, MintInfo, TokenIndex } from './accounts/bank';
import { Group } from './accounts/group';
import { MangoAccount, TokenConditionalSwapDisplayPriceStyle, TokenConditionalSwapIntention } from './accounts/mangoAccount';
import { StubOracle } from './accounts/oracle';
import { PerpMarket, PerpMarketIndex, PerpOrderSide, PerpOrderType, PerpSelfTradeBehavior } from './accounts/perp';
import { MarketIndex, Serum3Market, Serum3OrderType, Serum3SelfTradeBehavior, Serum3Side } from './accounts/serum3';
import { IxGateParams, PerpEditParams, TokenEditParams, TokenRegisterParams } from './clientIxParamBuilder';
import { Id } from './ids';
import { MangoV4 } from './mango_v4';
import { FlashLoanType, HealthCheckKind, OracleConfigParams } from './types';
import { LatestBlockhash, MangoSignatureStatus, SendTransactionOpts } from './utils/rpc';
export declare const DEFAULT_TOKEN_CONDITIONAL_SWAP_COUNT = 8;
export declare const PERP_SETTLE_PNL_CU_LIMIT = 400000;
export declare const PERP_SETTLE_FEES_CU_LIMIT = 20000;
export declare const SERUM_SETTLE_FUNDS_CU_LIMIT = 65000;
export declare enum AccountRetriever {
    Scanning = 0,
    Fixed = 1
}
export type IdsSource = 'api' | 'static' | 'get-program-accounts';
export type FallbackOracleConfig = 'never' | 'all' | 'dynamic' | PublicKey[];
export type MangoClientOptions = {
    idsSource?: IdsSource;
    postSendTxCallback?: (callbackOpts: TxCallbackOptions) => void;
    postTxConfirmationCallback?: (callbackOpts: TxCallbackOptions) => void;
    prioritizationFee?: number;
    estimateFee?: boolean;
    txConfirmationCommitment?: Commitment;
    openbookFeesToDao?: boolean;
    prependedGlobalAdditionalInstructions?: TransactionInstruction[];
    multipleConnections?: Connection[];
    fallbackOracleConfig?: FallbackOracleConfig;
    turnOffPriceImpactLoading?: boolean;
};
export type TxCallbackOptions = {
    txid: string;
    txSignatureBlockHash: LatestBlockhash;
    instructions?: VersionedTransaction;
};
export declare class MangoClient {
    program: Program<MangoV4>;
    programId: PublicKey;
    cluster: Cluster;
    opts: MangoClientOptions;
    private idsSource;
    private postSendTxCallback?;
    postTxConfirmationCallback?: (callbackOpts: TxCallbackOptions) => void;
    private prioritizationFee;
    private estimateFee;
    private txConfirmationCommitment;
    private openbookFeesToDao;
    private prependedGlobalAdditionalInstructions;
    private fallbackOracleConfig;
    private fixedFallbacks;
    multipleConnections: Connection[];
    turnOffPriceImpactLoading: boolean;
    constructor(program: Program<MangoV4>, programId: PublicKey, cluster: Cluster, opts?: MangoClientOptions);
    get connection(): Connection;
    get walletPk(): PublicKey;
    sendAndConfirmTransaction(ixs: TransactionInstruction[], opts?: SendTransactionOpts): Promise<MangoSignatureStatus>;
    sendAndConfirmTransaction(ixs: TransactionInstruction[], opts?: {
        confirmInBackground: true;
    } & SendTransactionOpts): Promise<MangoSignatureStatus>;
    sendAndConfirmTransactionForGroup(group: Group, ixs: TransactionInstruction[], opts?: SendTransactionOpts): Promise<MangoSignatureStatus>;
    sendAndConfirmTransactionForGroup(group: Group, ixs: TransactionInstruction[], opts?: {
        confirmInBackground: true;
    } & SendTransactionOpts): Promise<MangoSignatureStatus>;
    adminTokenWithdrawFees(group: Group, bank: Bank, tokenAccountPk: PublicKey): Promise<MangoSignatureStatus>;
    adminPerpWithdrawFees(group: Group, perpMarket: PerpMarket, tokenAccountPk: PublicKey): Promise<MangoSignatureStatus>;
    groupCreate(groupNum: number, testing: boolean, version: number, insuranceMintPk: PublicKey): Promise<MangoSignatureStatus>;
    groupEdit(group: Group, admin?: PublicKey, fastListingAdmin?: PublicKey, securityAdmin?: PublicKey, testing?: number, version?: number, depositLimitQuote?: BN, feesPayWithMngo?: boolean, feesMngoBonusRate?: number, feesSwapMangoAccount?: PublicKey, feesMngoTokenIndex?: TokenIndex, feesExpiryInterval?: BN, allowedFastListingsPerInterval?: number, collateralFeeInterval?: BN): Promise<MangoSignatureStatus>;
    groupChangeInsuranceFund(group: Group, withdrawDestination: PublicKey, newInsuranceMint: PublicKey): Promise<MangoSignatureStatus>;
    ixGateSet(group: Group, ixGateParams: IxGateParams): Promise<MangoSignatureStatus>;
    groupClose(group: Group): Promise<MangoSignatureStatus>;
    getGroup(groupPk: PublicKey): Promise<Group>;
    getGroupsForCreator(creatorPk: PublicKey): Promise<Group[]>;
    getGroupForCreator(creatorPk: PublicKey, groupNum: number): Promise<Group>;
    getIds(groupPk: PublicKey): Promise<Id | undefined>;
    tokenRegister(group: Group, mintPk: PublicKey, oraclePk: PublicKey, fallbackOraclePk: PublicKey, tokenIndex: number, name: string, params: TokenRegisterParams): Promise<MangoSignatureStatus>;
    tokenRegisterTrustless(group: Group, mintPk: PublicKey, oraclePk: PublicKey, tokenIndex: number, name: string): Promise<MangoSignatureStatus>;
    tokenEdit(group: Group, mintPk: PublicKey, params: TokenEditParams): Promise<MangoSignatureStatus>;
    tokenForceCloseBorrowsWithToken(group: Group, liqor: MangoAccount, liqee: MangoAccount, assetTokenIndex: TokenIndex, liabTokenIndex: TokenIndex, maxLiabTransfer?: number): Promise<MangoSignatureStatus>;
    tokenForceWithdraw(group: Group, mangoAccount: MangoAccount, tokenIndex: TokenIndex): Promise<MangoSignatureStatus>;
    tokenDeregister(group: Group, mintPk: PublicKey): Promise<MangoSignatureStatus>;
    getBanksForGroup(group: Group): Promise<Bank[]>;
    getMintInfosForGroup(group: Group): Promise<MintInfo[]>;
    getMintInfoForTokenIndex(group: Group, tokenIndex: TokenIndex): Promise<MintInfo[]>;
    stubOracleCreate(group: Group, mintPk: PublicKey, price: number): Promise<MangoSignatureStatus>;
    stubOracleClose(group: Group, oracle: PublicKey): Promise<MangoSignatureStatus>;
    stubOracleSet(group: Group, oraclePk: PublicKey, price: number): Promise<MangoSignatureStatus>;
    getStubOracle(group: Group, mintPk?: PublicKey): Promise<StubOracle[]>;
    createMangoAccount(group: Group, accountNumber?: number, name?: string, tokenCount?: number, serum3Count?: number, perpCount?: number, perpOoCount?: number): Promise<MangoSignatureStatus>;
    expandMangoAccount(group: Group, account: MangoAccount, tokenCount: number, serum3Count: number, perpCount: number, perpOoCount: number): Promise<MangoSignatureStatus>;
    accountExpandV2(group: Group, account: MangoAccount, tokenCount: number, serum3Count: number, perpCount: number, perpOoCount: number, tokenConditionalSwapCount: number): Promise<MangoSignatureStatus>;
    accountExpandV2Ix(group: Group, account: MangoAccount, tokenCount: number, serum3Count: number, perpCount: number, perpOoCount: number, tokenConditionalSwapCount: number): Promise<TransactionInstruction>;
    editMangoAccount(group: Group, mangoAccount: MangoAccount, name?: string, delegate?: PublicKey, temporaryDelegate?: PublicKey, delegateExpiry?: number): Promise<MangoSignatureStatus>;
    toggleMangoAccountFreeze(group: Group, mangoAccount: MangoAccount, freeze: boolean): Promise<MangoSignatureStatus>;
    sequenceCheckIx(group: Group, mangoAccount: MangoAccount): Promise<TransactionInstruction>;
    healthCheckIx(group: Group, mangoAccount: MangoAccount, minHealthValue: number, checkKind: HealthCheckKind): Promise<TransactionInstruction>;
    getMangoAccount(mangoAccountPk: PublicKey, loadSerum3Oo?: boolean): Promise<MangoAccount>;
    private getMangoAccountFromPk;
    getMangoAccountFromAi(mangoAccountPk: PublicKey, ai: AccountInfo<Buffer>): MangoAccount;
    getMangoAccountWithSlot(mangoAccountPk: PublicKey, loadSerum3Oo?: boolean): Promise<{
        slot: number;
        value: MangoAccount;
    } | undefined>;
    getMangoAccountForOwner(group: Group, ownerPk: PublicKey, accountNumber: number, loadSerum3Oo?: boolean): Promise<MangoAccount | undefined>;
    getMangoAccountsForOwner(group: Group, ownerPk: PublicKey, loadSerum3Oo?: boolean): Promise<MangoAccount[]>;
    getMangoAccountsForDelegate(group: Group, delegate: PublicKey, loadSerum3Oo?: boolean): Promise<MangoAccount[]>;
    getAllMangoAccounts(group: Group, loadSerum3Oo?: boolean): Promise<MangoAccount[]>;
    /**
     * Note: this ix doesn't settle liabs, reduce open positions, or withdraw tokens to wallet,
     * it simply closes the account. To close successfully ensure all positions are closed, or
     * use forceClose flag
     * @param group
     * @param mangoAccount
     * @param forceClose
     * @returns
     */
    closeMangoAccount(group: Group, mangoAccount: MangoAccount, forceClose?: boolean): Promise<MangoSignatureStatus>;
    emptyAndCloseMangoAccount(group: Group, mangoAccount: MangoAccount): Promise<MangoSignatureStatus>;
    accountBuybackFeesWithMngoIx(group: Group, mangoAccount: MangoAccount, maxBuybackUsd?: number): Promise<TransactionInstruction>;
    accountBuybackFeesWithMngo(group: Group, mangoAccount: MangoAccount, maxBuyback?: number): Promise<MangoSignatureStatus>;
    tokenDeposit(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, amount: number, reduceOnly?: boolean): Promise<MangoSignatureStatus>;
    tokenDepositNative(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, nativeAmount: BN, reduceOnly?: boolean, intoExisting?: boolean): Promise<MangoSignatureStatus>;
    tokenWithdrawAllDepositForAllUnconfidentOrStaleOracles(group: Group, mangoAccount: MangoAccount): Promise<MangoSignatureStatus>;
    /**
     * Withdraw the entire deposit balance for a token, effectively freeing the token position
     *
     * @param group
     * @param mangoAccount
     * @param mintPk
     * @returns
     */
    tokenWithdrawAllDepositForMint(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey): Promise<MangoSignatureStatus>;
    tokenWithdraw(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, amount: number, allowBorrow: boolean): Promise<MangoSignatureStatus>;
    tokenWithdrawNativeIx(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, nativeAmount: BN, allowBorrow: boolean): Promise<TransactionInstruction[]>;
    tokenWithdrawNative(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, nativeAmount: BN, allowBorrow: boolean): Promise<MangoSignatureStatus>;
    serum3RegisterMarket(group: Group, serum3MarketExternalPk: PublicKey, baseBank: Bank, quoteBank: Bank, marketIndex: number, name: string, oraclePriceBand: number): Promise<MangoSignatureStatus>;
    serum3ConsumeEvents(group: Group, serum3MarketExternalPk: PublicKey): Promise<MangoSignatureStatus>;
    serum3EditMarketIx(group: Group, serum3MarketIndex: MarketIndex, admin: PublicKey, reduceOnly: boolean | null, forceClose: boolean | null, name: string | null, oraclePriceBand: number | null): Promise<TransactionInstruction>;
    serum3EditMarket(group: Group, serum3MarketIndex: MarketIndex, reduceOnly: boolean | null, forceClose: boolean | null, name: string | null, oraclePriceBand: number | null): Promise<MangoSignatureStatus>;
    serum3deregisterMarket(group: Group, externalMarketPk: PublicKey): Promise<MangoSignatureStatus>;
    serum3GetMarkets(group: Group, baseTokenIndex?: number, quoteTokenIndex?: number): Promise<Serum3Market[]>;
    serum3CreateOpenOrders(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<MangoSignatureStatus>;
    serum3CreateOpenOrdersIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionInstruction>;
    serum3CloseOpenOrdersIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionInstruction>;
    serum3CloseOpenOrders(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<MangoSignatureStatus>;
    serum3LiqForceCancelOrders(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, limit?: number): Promise<MangoSignatureStatus>;
    serum3PlaceOrderIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, price: number, size: number, selfTradeBehavior: Serum3SelfTradeBehavior, orderType: Serum3OrderType, clientOrderId: number, limit: number): Promise<TransactionInstruction[]>;
    serum3PlaceOrderV1Ix(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, price: number, size: number, selfTradeBehavior: Serum3SelfTradeBehavior, orderType: Serum3OrderType, clientOrderId: number, limit: number): Promise<TransactionInstruction[]>;
    serum3PlaceOrderV2Ix(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, price: number, size: number, selfTradeBehavior: Serum3SelfTradeBehavior, orderType: Serum3OrderType, clientOrderId: number, limit: number): Promise<TransactionInstruction[]>;
    serum3PlaceOrder(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, price: number, size: number, selfTradeBehavior: Serum3SelfTradeBehavior, orderType: Serum3OrderType, clientOrderId: number, limit: number): Promise<MangoSignatureStatus>;
    serum3CancelAllOrdersIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, limit?: number): Promise<TransactionInstruction>;
    serum3CancelAllOrders(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, limit?: number): Promise<MangoSignatureStatus>;
    serum3SettleFundsIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionInstruction>;
    serum3SettleFundsV2Ix(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionInstruction>;
    serum3SettleFunds(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<MangoSignatureStatus>;
    serum3CancelOrderIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, orderId: BN): Promise<TransactionInstruction>;
    serum3CancelOrder(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, orderId: BN): Promise<MangoSignatureStatus>;
    serum3CancelOrderByClientIdIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, clientOrderId: BN): Promise<TransactionInstruction>;
    serum3CancelOrderByClientId(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, clientOrderId: BN): Promise<MangoSignatureStatus>;
    perpCreateMarket(group: Group, oraclePk: PublicKey, perpMarketIndex: number, name: string, oracleConfig: OracleConfigParams, baseDecimals: number, quoteLotSize: number, baseLotSize: number, maintBaseAssetWeight: number, initBaseAssetWeight: number, maintBaseLiabWeight: number, initBaseLiabWeight: number, maintOverallAssetWeight: number, initOverallAssetWeight: number, baseLiquidationFee: number, makerFee: number, takerFee: number, feePenalty: number, minFunding: number, maxFunding: number, impactQuantity: number, groupInsuranceFund: boolean, settleFeeFlat: number, settleFeeAmountThreshold: number, settleFeeFractionLowHealth: number, settleTokenIndex: number, settlePnlLimitFactor: number, settlePnlLimitWindowSize: number, positivePnlLiquidationFee: number, platformLiquidationFee: number): Promise<MangoSignatureStatus>;
    perpEditMarket(group: Group, perpMarketIndex: PerpMarketIndex, params: PerpEditParams): Promise<MangoSignatureStatus>;
    perpForceClosePosition(group: Group, perpMarketIndex: PerpMarketIndex, accountA: MangoAccount, accountB: MangoAccount): Promise<MangoSignatureStatus>;
    perpCloseMarket(group: Group, perpMarketIndex: PerpMarketIndex): Promise<MangoSignatureStatus>;
    perpGetMarkets(group: Group): Promise<PerpMarket[]>;
    perpDeactivatePositionIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex): Promise<TransactionInstruction>;
    perpDeactivatePosition(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex): Promise<MangoSignatureStatus>;
    perpCloseAll(group: Group, mangoAccount: MangoAccount, slippage?: number): Promise<MangoSignatureStatus>;
    perpPlaceOrder(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, price: number, quantity: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<MangoSignatureStatus>;
    perpPlaceOrderIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, price: number, quantity: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<TransactionInstruction>;
    perpPlaceOrderV2Ix(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, price: number, quantity: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, selfTradeBehavior?: PerpSelfTradeBehavior, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<TransactionInstruction>;
    perpPlaceOrderPegged(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, priceOffset: number, quantity: number, pegLimit?: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<MangoSignatureStatus>;
    perpPlaceOrderPeggedIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, priceOffset: number, quantity: number, pegLimit?: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<TransactionInstruction>;
    perpPlaceOrderPeggedV2Ix(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, priceOffset: number, quantity: number, pegLimit?: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, selfTradeBehavior?: PerpSelfTradeBehavior, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<TransactionInstruction>;
    perpCancelOrderByClientOrderIdIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, clientOrderId: BN): Promise<TransactionInstruction>;
    perpCancelOrderIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, orderId: BN): Promise<TransactionInstruction>;
    perpCancelOrder(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, orderId: BN): Promise<MangoSignatureStatus>;
    perpCancelAllOrders(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, limit: number): Promise<MangoSignatureStatus>;
    perpCancelAllOrdersIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, limit: number): Promise<TransactionInstruction>;
    settleAll(client: MangoClient, group: Group, mangoAccount: MangoAccount, allMangoAccounts?: MangoAccount[]): Promise<MangoSignatureStatus>;
    perpSettlePnlAndFees(group: Group, profitableAccount: MangoAccount, unprofitableAccount: MangoAccount, accountToSettleFeesFor: MangoAccount, settler: MangoAccount, perpMarketIndex: PerpMarketIndex, maxSettleAmount?: number): Promise<MangoSignatureStatus>;
    perpSettlePnl(group: Group, profitableAccount: MangoAccount, unprofitableAccount: MangoAccount, settler: MangoAccount, perpMarketIndex: PerpMarketIndex): Promise<MangoSignatureStatus>;
    perpSettlePnlIx(group: Group, profitableAccount: MangoAccount, unprofitableAccount: MangoAccount, settler: MangoAccount, perpMarketIndex: PerpMarketIndex): Promise<TransactionInstruction>;
    perpSettleFees(group: Group, account: MangoAccount, perpMarketIndex: PerpMarketIndex, maxSettleAmount?: number): Promise<MangoSignatureStatus>;
    perpSettleFeesIx(group: Group, account: MangoAccount, perpMarketIndex: PerpMarketIndex, maxSettleAmount?: number): Promise<TransactionInstruction>;
    perpConsumeEvents(group: Group, perpMarketIndex: PerpMarketIndex, accounts: PublicKey[], limit: number): Promise<MangoSignatureStatus>;
    perpConsumeEventsIx(group: Group, perpMarketIndex: PerpMarketIndex, accounts: PublicKey[], limit: number): Promise<TransactionInstruction>;
    perpConsumeAllEvents(group: Group, perpMarketIndex: PerpMarketIndex): Promise<void>;
    perpUpdateFundingIx(group: Group, perpMarket: PerpMarket): Promise<TransactionInstruction>;
    marginTrade({ group, mangoAccount, inputMintPk, amountIn, outputMintPk, userDefinedInstructions, userDefinedAlts, flashLoanType, sequenceCheck, }: {
        group: Group;
        mangoAccount: MangoAccount;
        inputMintPk: PublicKey;
        amountIn: number;
        outputMintPk: PublicKey;
        userDefinedInstructions: TransactionInstruction[];
        userDefinedAlts: AddressLookupTableAccount[];
        flashLoanType: FlashLoanType;
        sequenceCheck: boolean;
    }): Promise<MangoSignatureStatus>;
    tokenUpdateIndexAndRate(group: Group, mintPk: PublicKey): Promise<MangoSignatureStatus>;
    tokenUpdateIndexAndRateIx(group: Group, mintPk: PublicKey): Promise<TransactionInstruction>;
    liqTokenWithToken(group: Group, liqor: MangoAccount, liqee: MangoAccount, assetMintPk: PublicKey, liabMintPk: PublicKey, maxLiabTransfer: number): Promise<MangoSignatureStatus>;
    tcsTakeProfitOnDeposit(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, thresholdPrice: number, thresholdPriceInSellPerBuyToken: boolean, maxSell: number | null, pricePremium: number | null, expiryTimestamp: number | null): Promise<MangoSignatureStatus>;
    tcsTakeProfitOnDepositIx(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, thresholdPrice: number, thresholdPriceInSellPerBuyToken: boolean, maxSell: number | null, pricePremium: number | null, expiryTimestamp: number | null): Promise<TransactionInstruction[]>;
    tcsStopLossOnDeposit(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, thresholdPrice: number, thresholdPriceInSellPerBuyToken: boolean, maxSell: number | null, pricePremium: number | null, expiryTimestamp: number | null): Promise<MangoSignatureStatus>;
    tcsStopLossOnDepositIx(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, thresholdPrice: number, thresholdPriceInSellPerBuyToken: boolean, maxSell: number | null, pricePremium: number | null, expiryTimestamp: number | null): Promise<TransactionInstruction[]>;
    tcsTakeProfitOnBorrow(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, thresholdPrice: number, thresholdPriceInSellPerBuyToken: boolean, maxBuyUi: number | null, pricePremium: number | null, allowMargin: boolean | null, expiryTimestamp: number | null): Promise<MangoSignatureStatus>;
    tcsTakeProfitOnBorrowIx(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, thresholdPrice: number, thresholdPriceInSellPerBuyToken: boolean, maxBuyUi: number | null, pricePremium: number | null, allowMargin: boolean | null, expiryTimestamp: number | null): Promise<TransactionInstruction[]>;
    tcsStopLossOnBorrow(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, thresholdPrice: number, thresholdPriceInSellPerBuyToken: boolean, maxBuyUi: number | null, pricePremium: number | null, allowMargin: boolean | null, expiryTimestamp: number | null): Promise<MangoSignatureStatus>;
    tcsStopLossOnBorrowIx(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, thresholdPrice: number, thresholdPriceInSellPerBuyToken: boolean, maxBuyUi: number | null, pricePremium: number | null, allowMargin: boolean | null, expiryTimestamp: number | null): Promise<TransactionInstruction[]>;
    tokenConditionalSwapCreateIx(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, lowerLimitNativeNative: number, upperLimitNativeNative: number, maxBuy: number, maxSell: number, tcsIntention: 'TakeProfitOnDeposit' | 'StopLossOnDeposit' | 'TakeProfitOnBorrow' | 'StopLossOnBorrow' | null, pricePremium: number | null, allowCreatingDeposits: boolean, allowCreatingBorrows: boolean, expiryTimestamp: number | null, displayPriceInSellTokenPerBuyToken: boolean): Promise<TransactionInstruction[]>;
    tokenConditionalSwapCreate(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, lowerLimitNativeNative: number, upperLimitNativeNative: number, maxBuy: number, maxSell: number, tcsIntention: 'TakeProfitOnDeposit' | 'StopLossOnDeposit' | 'TakeProfitOnBorrow' | 'StopLossOnBorrow' | null, pricePremium: number | null, allowCreatingDeposits: boolean, allowCreatingBorrows: boolean, expiryTimestamp: number | null, displayPriceInSellTokenPerBuyToken: boolean): Promise<MangoSignatureStatus>;
    tokenConditionalSwapCreateLinearAuctionIx(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, priceStart: number, priceEnd: number, maxBuy: number, maxSell: number, allowCreatingDeposits: boolean, allowCreatingBorrows: boolean, displayPriceInSellTokenPerBuyToken: boolean, startTimestamp: number, durationSeconds: number, expiryTimestamp: number | null): Promise<TransactionInstruction[]>;
    tokenConditionalSwapCreateLinearAuction(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, priceStart: number, priceEnd: number, maxBuy: number, maxSell: number, allowCreatingDeposits: boolean, allowCreatingBorrows: boolean, displayPriceInSellTokenPerBuyToken: boolean, startTimestamp: number, durationSeconds: number, expiryTimestamp: number | null): Promise<MangoSignatureStatus>;
    tokenConditionalSwapCreatePremiumAuctionIx(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, lowerLimitNative: number, upperLimitNative: number, maxBuy: number, maxSell: number, tcsIntention: 'TakeProfitOnDeposit' | 'StopLossOnDeposit' | 'TakeProfitOnBorrow' | 'StopLossOnBorrow' | null, maxPricePremiumPercent: number | null, allowCreatingDeposits: boolean, allowCreatingBorrows: boolean, expiryTimestamp: number | null, displayPriceInSellTokenPerBuyToken: boolean, durationSeconds: any, premiumMultiplier?: number, extraPricePremiumBps?: number): Promise<TransactionInstruction[]>;
    tokenConditionalSwapCreatePremiumAuction(group: Group, account: MangoAccount, sellBank: Bank, buyBank: Bank, lowerLimit: number, upperLimit: number, maxBuy: number, maxSell: number, tcsIntention: 'TakeProfitOnDeposit' | 'StopLossOnDeposit' | 'TakeProfitOnBorrow' | 'StopLossOnBorrow' | null, maxPricePremiumPercent: number | null, allowCreatingDeposits: boolean, allowCreatingBorrows: boolean, expiryTimestamp: number | null, displayPriceInSellTokenPerBuyToken: boolean, durationSeconds: number): Promise<MangoSignatureStatus>;
    tokenConditionalSwapCreateRaw(group: Group, account: MangoAccount, buyMintPk: PublicKey, sellMintPk: PublicKey, maxBuy: BN, maxSell: BN, expiryTimestamp: number | null, priceLowerLimit: number, priceUpperLimit: number, pricePremiumRate: number, allowCreatingDeposits: boolean, allowCreatingBorrows: boolean, priceDisplayStyle: TokenConditionalSwapDisplayPriceStyle, intention: TokenConditionalSwapIntention): Promise<MangoSignatureStatus>;
    tokenConditionalSwapCreateRawIx(group: Group, account: MangoAccount, buyMintPk: PublicKey, sellMintPk: PublicKey, maxBuy: BN, maxSell: BN, expiryTimestamp: number | null, priceLowerLimit: number, priceUpperLimit: number, pricePremiumRate: number, allowCreatingDeposits: boolean, allowCreatingBorrows: boolean, priceDisplayStyle: TokenConditionalSwapDisplayPriceStyle, intention: TokenConditionalSwapIntention): Promise<TransactionInstruction[]>;
    tokenConditionalSwapCancelIx(group: Group, account: MangoAccount, tokenConditionalSwapId: BN): Promise<TransactionInstruction>;
    tokenConditionalSwapCancel(group: Group, account: MangoAccount, tokenConditionalSwapId: BN): Promise<MangoSignatureStatus>;
    tokenConditionalSwapCancelAll(group: Group, account: MangoAccount): Promise<MangoSignatureStatus>;
    tokenConditionalSwapTrigger(group: Group, liqee: MangoAccount, liqor: MangoAccount, tokenConditionalSwapId: BN, maxBuyTokenToLiqee: number, maxSellTokenToLiqor: number): Promise<MangoSignatureStatus>;
    tokenConditionalSwapTriggerIx(group: Group, liqee: MangoAccount, liqor: MangoAccount, tokenConditionalSwapId: BN, maxBuyTokenToLiqee: number, maxSellTokenToLiqor: number): Promise<TransactionInstruction>;
    altSet(group: Group, addressLookupTable: PublicKey, index: number): Promise<MangoSignatureStatus>;
    altExtend(group: Group, addressLookupTable: PublicKey, index: number, pks: PublicKey[]): Promise<MangoSignatureStatus>;
    healthRegionBeginIx(group: Group, account: MangoAccount, banks?: Bank[], perpMarkets?: PerpMarket[]): Promise<TransactionInstruction>;
    healthRegionEndIx(group: Group, account: MangoAccount, banks?: Bank[], perpMarkets?: PerpMarket[]): Promise<TransactionInstruction>;
    static connect(provider: Provider, cluster: Cluster, programId: PublicKey, opts?: MangoClientOptions): MangoClient;
    /**
     * Connect with defaults,
     *  - random ephemeral keypair,
     *  - fetch ids using gPa
     *  - connects to mainnet-beta
     *  - uses well known program Id
     * @param clusterUrl
     * @returns
     */
    static connectDefault(clusterUrl: string): MangoClient;
    static connectForGroupName(provider: Provider, groupName: string): MangoClient;
    /**
     * Builds health remaining accounts.
     *
     * For single mango account it builds a list of PublicKeys
     * which is compatbile with Fixed account retriever.
     *
     * For multiple mango accounts it uses same logic as for fixed
     * but packing all banks, then perp markets, and then serum oo accounts, which
     * should always be compatible with Scanning account retriever.
     *
     * @param group
     * @param mangoAccounts
     * @param banks - banks in which new positions might be opened
     * @param perpMarkets - markets in which new positions might be opened
     * @param openOrdersForMarket - markets in which new positions might be opened
     * @returns
     */
    buildHealthRemainingAccounts(group: Group, mangoAccounts: MangoAccount[], banks?: Bank[], perpMarkets?: PerpMarket[], openOrdersForMarket?: [Serum3Market, PublicKey][]): Promise<PublicKey[]>;
    /**This function assumes that the provided group has loaded banks*/
    deriveFallbackOracleContexts(group: Group): Promise<Map<string, [PublicKey, PublicKey]>>;
    modifyPerpOrder(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, orderId: BN, side: PerpOrderSide, price: number, quantity: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<MangoSignatureStatus>;
    modifySerum3Order(group: Group, orderId: BN, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, price: number, size: number, selfTradeBehavior: Serum3SelfTradeBehavior, orderType: Serum3OrderType, clientOrderId: number, limit: number): Promise<MangoSignatureStatus>;
    /**
     * Returns an estimate of a prioritization fee for a set of instructions.
     *
     * The estimate is based on the median fees of writable accounts that will be involved in the transaction.
     *
     * @param ixs - the instructions that make up the transaction
     * @returns prioritizationFeeEstimate -- in microLamports
     */
    estimatePrioritizationFee(ixs: TransactionInstruction[]): Promise<number>;
}
//# sourceMappingURL=client.d.ts.map