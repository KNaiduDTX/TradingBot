import { BN } from '@coral-xyz/anchor';
import { PublicKey } from '@solana/web3.js';
import { MangoClient } from '../client';
import { I80F48, I80F48Dto } from '../numbers/I80F48';
import { Modify } from '../types';
import { As } from '../utils';
import { OracleConfig, OracleConfigDto, StablePriceModel, TokenIndex } from './bank';
import { Group } from './group';
import { MangoAccount } from './mangoAccount';
import { OracleProvider } from './oracle';
export type PerpMarketIndex = number & As<'perp-market-index'>;
export type ParsedFillEvent = Modify<FillEvent, {
    price: number;
    quantity: number;
}>;
export declare class PerpMarket {
    publicKey: PublicKey;
    group: PublicKey;
    settleTokenIndex: TokenIndex;
    perpMarketIndex: PerpMarketIndex;
    groupInsuranceFund: boolean;
    baseDecimals: number;
    bids: PublicKey;
    asks: PublicKey;
    eventQueue: PublicKey;
    oracle: PublicKey;
    stablePriceModel: StablePriceModel;
    quoteLotSize: BN;
    baseLotSize: BN;
    openInterest: BN;
    seqNum: BN;
    registrationTime: BN;
    impactQuantity: BN;
    fundingLastUpdated: BN;
    feePenalty: number;
    settleFeeFlat: number;
    settleFeeAmountThreshold: number;
    settleFeeFractionLowHealth: number;
    settlePnlLimitFactor: number;
    settlePnlLimitWindowSizeTs: BN;
    reduceOnly: boolean;
    forceClose: boolean;
    feesWithdrawn: BN;
    name: string;
    oracleConfig: OracleConfig;
    maintBaseAssetWeight: I80F48;
    initBaseAssetWeight: I80F48;
    maintBaseLiabWeight: I80F48;
    initBaseLiabWeight: I80F48;
    baseLiquidationFee: I80F48;
    makerFee: I80F48;
    takerFee: I80F48;
    minFunding: I80F48;
    maxFunding: I80F48;
    longFunding: I80F48;
    shortFunding: I80F48;
    feesAccrued: I80F48;
    feesSettled: I80F48;
    maintOverallAssetWeight: I80F48;
    initOverallAssetWeight: I80F48;
    positivePnlLiquidationFee: I80F48;
    platformLiquidationFee: I80F48;
    accruedLiquidationFees: I80F48;
    _price: I80F48;
    _uiPrice: number;
    _oracleLastUpdatedSlot: number;
    _oracleLastKnownDeviation: I80F48 | undefined;
    _oracleProvider: OracleProvider;
    _bids: BookSide;
    _asks: BookSide;
    private priceLotsToUiConverter;
    private baseLotsToUiConverter;
    private quoteLotsToUiConverter;
    static from(publicKey: PublicKey, obj: {
        group: PublicKey;
        settleTokenIndex: number;
        perpMarketIndex: number;
        groupInsuranceFund: number;
        baseDecimals: number;
        name: number[];
        bids: PublicKey;
        asks: PublicKey;
        eventQueue: PublicKey;
        oracle: PublicKey;
        oracleConfig: OracleConfigDto;
        stablePriceModel: StablePriceModel;
        quoteLotSize: BN;
        baseLotSize: BN;
        maintBaseAssetWeight: I80F48Dto;
        initBaseAssetWeight: I80F48Dto;
        maintBaseLiabWeight: I80F48Dto;
        initBaseLiabWeight: I80F48Dto;
        openInterest: BN;
        seqNum: BN;
        registrationTime: BN;
        minFunding: I80F48Dto;
        maxFunding: I80F48Dto;
        impactQuantity: BN;
        longFunding: I80F48Dto;
        shortFunding: I80F48Dto;
        fundingLastUpdated: BN;
        baseLiquidationFee: I80F48Dto;
        makerFee: I80F48Dto;
        takerFee: I80F48Dto;
        feesAccrued: I80F48Dto;
        feesSettled: I80F48Dto;
        feePenalty: number;
        settleFeeFlat: number;
        settleFeeAmountThreshold: number;
        settleFeeFractionLowHealth: number;
        settlePnlLimitFactor: number;
        settlePnlLimitWindowSizeTs: BN;
        reduceOnly: number;
        forceClose: number;
        maintOverallAssetWeight: I80F48Dto;
        initOverallAssetWeight: I80F48Dto;
        positivePnlLiquidationFee: I80F48Dto;
        feesWithdrawn: BN;
        platformLiquidationFee: I80F48Dto;
        accruedLiquidationFees: I80F48Dto;
    }): PerpMarket;
    constructor(publicKey: PublicKey, group: PublicKey, settleTokenIndex: TokenIndex, perpMarketIndex: PerpMarketIndex, // TODO rename to marketIndex?
    groupInsuranceFund: boolean, baseDecimals: number, name: number[], bids: PublicKey, asks: PublicKey, eventQueue: PublicKey, oracle: PublicKey, oracleConfig: OracleConfigDto, stablePriceModel: StablePriceModel, quoteLotSize: BN, baseLotSize: BN, maintBaseAssetWeight: I80F48Dto, initBaseAssetWeight: I80F48Dto, maintBaseLiabWeight: I80F48Dto, initBaseLiabWeight: I80F48Dto, openInterest: BN, seqNum: BN, registrationTime: BN, minFunding: I80F48Dto, maxFunding: I80F48Dto, impactQuantity: BN, longFunding: I80F48Dto, shortFunding: I80F48Dto, fundingLastUpdated: BN, baseLiquidationFee: I80F48Dto, makerFee: I80F48Dto, takerFee: I80F48Dto, feesAccrued: I80F48Dto, feesSettled: I80F48Dto, feePenalty: number, settleFeeFlat: number, settleFeeAmountThreshold: number, settleFeeFractionLowHealth: number, settlePnlLimitFactor: number, settlePnlLimitWindowSizeTs: BN, reduceOnly: boolean, forceClose: boolean, maintOverallAssetWeight: I80F48Dto, initOverallAssetWeight: I80F48Dto, positivePnlLiquidationFee: I80F48Dto, feesWithdrawn: BN, platformLiquidationFee: I80F48Dto, accruedLiquidationFees: I80F48Dto);
    isOracleStaleOrUnconfident(nowSlot: number): boolean;
    get price(): I80F48;
    get uiPrice(): number;
    get oracleLastUpdatedSlot(): number;
    get oracleProvider(): OracleProvider;
    get minOrderSize(): number;
    get tickSize(): number;
    insidePriceLimit(side: PerpOrderSide, orderPrice: number): boolean;
    loadAsks(client: MangoClient, forceReload?: boolean): Promise<BookSide>;
    loadBids(client: MangoClient, forceReload?: boolean): Promise<BookSide>;
    loadEventQueue(client: MangoClient): Promise<PerpEventQueue>;
    loadFills(client: MangoClient, lastSeqNum?: BN): Promise<FillEvent[]>;
    parseFillEvent(event: any): ParsedFillEvent;
    logOb(client: MangoClient): Promise<string>;
    /**
     *
     * @param bids
     * @param asks
     * @returns returns instantaneous funding rate
     */
    getInstantaneousFundingRate(bids: BookSide, asks: BookSide): number;
    getInstantaneousFundingRatePerSecond(bids: BookSide, asks: BookSide): number;
    /**
     *
     * Returns instantaneous funding rate for the day. How is it actually applied - funding is
     * continuously applied on every interaction to a perp position. The rate is further multiplied
     * by the time elapsed since it was last applied (capped to max. 1hr).
     *
     * @param bids
     * @param asks
     * @returns returns instantaneous funding rate in % form
     */
    getInstantaneousFundingRateUi(bids: BookSide, asks: BookSide): number;
    uiPriceToLots(price: number): BN;
    uiBaseToLots(quantity: number): BN;
    uiQuoteToLots(uiQuote: number): BN;
    priceLotsToNative(price: BN): I80F48;
    priceLotsToUi(price: BN): number;
    priceNativeToUi(price: number): number;
    baseLotsToUi(quantity: BN): number;
    quoteLotsToUi(quantity: BN): number;
    /**
     * Returns a list of (upto count) accounts, and the pnl that is settle'able on this perp market,
     * the list is sorted ascending for 'negative' direction and descending for 'positive' direction.
     *
     * NOTE: keep in sync with perp_pnl.rs:fetch_top
     *
     * TODO: replace with a more performant offchain service call
     * @param client
     * @param group
     * @param direction
     * @returns
     */
    getSettlePnlCandidates(client: MangoClient, group: Group, accounts?: MangoAccount[], direction?: 'negative' | 'positive', count?: number): Promise<{
        account: MangoAccount;
        settleablePnl: I80F48;
    }[]>;
    toString(): string;
}
interface OrderTreeNodes {
    bumpIndex: number;
    freeListLen: number;
    freeListHead: number;
    nodes: [any];
}
interface OrderTreeRoot {
    maybeNode: number;
    leafCount: number;
}
export declare class BookSide {
    client: MangoClient;
    perpMarket: PerpMarket;
    type: BookSideType;
    rootFixed: OrderTreeRoot;
    rootOraclePegged: OrderTreeRoot;
    orderTreeNodes: OrderTreeNodes;
    private static INNER_NODE_TAG;
    private static LEAF_NODE_TAG;
    now: BN;
    static from(client: MangoClient, perpMarket: PerpMarket, bookSideType: BookSideType, obj: {
        roots: OrderTreeRoot[];
        nodes: OrderTreeNodes;
    }): BookSide;
    constructor(client: MangoClient, perpMarket: PerpMarket, type: BookSideType, rootFixed: OrderTreeRoot, rootOraclePegged: OrderTreeRoot, orderTreeNodes: OrderTreeNodes, maxBookDelay?: number);
    static getPriceFromKey(key: BN): BN;
    /**
     * iterates over all orders
     */
    items(): Generator<PerpOrder>;
    /**
     * iterates over all orders,
     * skips oracle pegged orders which are invalid due to oracle price crossing the peg limit,
     * skips tif orders which are invalid due to tif having elapsed,
     */
    itemsValid(): Generator<PerpOrder>;
    fixedItems(): Generator<PerpOrder>;
    oraclePeggedItems(): Generator<PerpOrder>;
    best(): PerpOrder | undefined;
    getImpactPriceUi(baseLots: BN): number | undefined;
    getL2(depth: number): [number, number, BN, BN][];
    getL2Ui(depth: number): [number, number][];
    static toInnerNode(client: MangoClient, data: [number]): InnerNode;
    static toLeafNode(client: MangoClient, data: [number]): LeafNode;
}
export type BookSideType = {
    bids: Record<string, never>;
} | {
    asks: Record<string, never>;
};
export declare namespace BookSideType {
    const bids: {
        bids: {};
    };
    const asks: {
        asks: {};
    };
}
export declare class LeafNode {
    ownerSlot: number;
    orderType: PerpOrderType;
    timeInForce: number;
    key: BN;
    owner: PublicKey;
    quantity: BN;
    timestamp: BN;
    pegLimit: BN;
    static from(obj: {
        ownerSlot: number;
        orderType: PerpOrderType;
        timeInForce: number;
        key: BN;
        owner: PublicKey;
        quantity: BN;
        timestamp: BN;
        pegLimit: BN;
    }): LeafNode;
    constructor(ownerSlot: number, orderType: PerpOrderType, timeInForce: number, key: BN, owner: PublicKey, quantity: BN, timestamp: BN, pegLimit: BN);
}
export declare class InnerNode {
    children: [number];
    static from(obj: {
        children: [number];
    }): InnerNode;
    constructor(children: [number]);
}
export type PerpSelfTradeBehavior = {
    decrementTake: Record<string, never>;
} | {
    cancelProvide: Record<string, never>;
} | {
    abortTransaction: Record<string, never>;
};
export declare namespace PerpSelfTradeBehavior {
    const decrementTake: {
        decrementTake: {};
    };
    const cancelProvide: {
        cancelProvide: {};
    };
    const abortTransaction: {
        abortTransaction: {};
    };
}
export type PerpOrderSide = {
    bid: Record<string, never>;
} | {
    ask: Record<string, never>;
};
export declare namespace PerpOrderSide {
    const bid: {
        bid: {};
    };
    const ask: {
        ask: {};
    };
}
export type PerpOrderType = {
    limit: Record<string, never>;
} | {
    immediateOrCancel: Record<string, never>;
} | {
    postOnly: Record<string, never>;
} | {
    market: Record<string, never>;
} | {
    postOnlySlide: Record<string, never>;
};
export declare namespace PerpOrderType {
    const limit: {
        limit: {};
    };
    const immediateOrCancel: {
        immediateOrCancel: {};
    };
    const postOnly: {
        postOnly: {};
    };
    const market: {
        market: {};
    };
    const postOnlySlide: {
        postOnlySlide: {};
    };
}
export declare class PerpOrder {
    seqNum: BN;
    orderId: BN;
    owner: PublicKey;
    openOrdersSlot: number;
    feeTier: 0;
    uiPrice: number;
    priceLots: BN;
    uiSize: number;
    sizeLots: BN;
    side: PerpOrderSide;
    timestamp: BN;
    expiryTimestamp: BN;
    perpMarketIndex: number;
    isExpired: boolean;
    isOraclePegged: boolean;
    orderType: PerpOrderType;
    oraclePeggedProperties?: OraclePeggedProperties | undefined;
    static from(perpMarket: PerpMarket, leafNode: LeafNode, type: BookSideType, isExpired?: boolean, isOraclePegged?: boolean): PerpOrder;
    constructor(seqNum: BN, orderId: BN, owner: PublicKey, openOrdersSlot: number, feeTier: 0, uiPrice: number, priceLots: BN, uiSize: number, sizeLots: BN, side: PerpOrderSide, timestamp: BN, expiryTimestamp: BN, perpMarketIndex: number, isExpired: boolean, isOraclePegged: boolean, orderType: PerpOrderType, oraclePeggedProperties?: OraclePeggedProperties | undefined);
    get price(): number;
    get size(): number;
}
interface OraclePeggedProperties {
    isInvalid: boolean;
    priceOffset: BN;
    uiPriceOffset: number;
    pegLimit: BN;
    uiPegLimit: number;
}
export declare class PerpEventQueue {
    static FILL_EVENT_TYPE: number;
    static OUT_EVENT_TYPE: number;
    static LIQUIDATE_EVENT_TYPE: number;
    head: number;
    count: number;
    seqNum: BN;
    rawEvents: (OutEvent | FillEvent | LiquidateEvent)[];
    constructor(client: MangoClient, header: {
        head: number;
        count: number;
        seqNum: BN;
    }, buf: any);
    getUnconsumedEvents(): (OutEvent | FillEvent | LiquidateEvent)[];
    eventsSince(lastSeqNum?: BN): (OutEvent | FillEvent | LiquidateEvent)[];
}
export interface Event {
    eventType: number;
}
export interface OutEvent extends Event {
    side: PerpOrderType;
    ownerSlot: number;
    timestamp: BN;
    seqNum: BN;
    owner: PublicKey;
    quantity: BN;
}
export interface FillEvent extends Event {
    takerSide: 0 | 1;
    makerOut: boolean;
    makerSlot: number;
    timestamp: BN;
    seqNum: BN;
    maker: PublicKey;
    makerOrderId: BN;
    makerFee: number;
    makerTimestamp: BN;
    taker: PublicKey;
    takerOrderId: BN;
    takerClientOrderId: BN;
    takerFee: number;
    price: number;
    quantity: number;
}
export interface LiquidateEvent extends Event {
    seqNum: BN;
}
export {};
//# sourceMappingURL=perp.d.ts.map