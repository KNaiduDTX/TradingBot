"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parallelTransactionProcessor = exports._TransactionInstructionWithIndex = void 0;
const web3_js_1 = require("@solana/web3.js");
const tools_1 = require("./tools");
const globalTypes_1 = require("./globalTypes");
class _TransactionInstructionWithIndex extends globalTypes_1.TransactionInstructionWithSigners {
    constructor(transactionInstruction, signers = [], index) {
        super(transactionInstruction, signers);
        this.index = index;
    }
}
exports._TransactionInstructionWithIndex = _TransactionInstructionWithIndex;
const timeoutSecs = 90;
const sendTransactionChunk = async (transactionInstructions, wallet, connection) => {
    const block = await connection.getLatestBlockhash('confirmed');
    const toSignQueued = [...transactionInstructions].map((tiws) => {
        const transaction = new web3_js_1.Transaction({ feePayer: wallet.publicKey });
        transaction.add(tiws.transactionInstruction);
        transaction.recentBlockhash = block.blockhash;
        if (tiws.signers && tiws.signers.length > 0) {
            transaction.partialSign(...tiws.signers);
        }
        return transaction;
    });
    const signedTxns = await wallet.signAllTransactions(toSignQueued);
    const sendedTransactionsSignatures = await Promise.all(signedTxns.map((x) => {
        const rawTransaction = x.serialize();
        return connection.sendRawTransaction(rawTransaction, {
            skipPreflight: true,
        });
    }));
    return [
        //return transactions marked with index of instruction, block and timestamp
        ...sendedTransactionsSignatures.map((x, idx) => {
            const nowTimestamp = (0, tools_1.getUnixTs)();
            return {
                id: x,
                timestamp: nowTimestamp,
                index: transactionInstructions[idx].index,
                sendedAtBlock: block.lastValidBlockHeight,
            };
        }),
    ];
};
const sendInstructions = async (transactionsWithIndex, batchSize, wallet, connection) => {
    const toConfirm = [];
    const transactionsChunks = (0, tools_1.chunks)(transactionsWithIndex, batchSize);
    for (let i = 0; i < transactionsChunks.length; i++) {
        const sendedTransactions = await sendTransactionChunk(transactionsChunks[i], wallet, connection);
        toConfirm.push(...sendedTransactions);
    }
    return toConfirm;
};
/**
 * sign, send and wait for confirmation of parallel transactions, best for in code keypair wallet
 */
const parallelTransactionProcessor = async ({ transactionInstructionsWithSigners, connection, wallet, batchSize = 50, maxRetryNumber = 5, }) => {
    //interval checking if transactions are confirmed in ms
    const confirmationIntervalPeriod = 5000;
    //If interval run x times and array is empty x times then processor is resolving promise.
    const toConfirmIsEmptyCheckEndThreshold = 5;
    //current retry count
    let retryCount = 0;
    //how many times toConfirmArray was empty
    let toConfirmIsEmptyCount = 0;
    //after defaultTimeout it will start to check blockchain block
    let startBlockCheck = false;
    //mark transactions with instruction index
    const txWithIdx = transactionInstructionsWithSigners.map((x, idx) => {
        return {
            ...x,
            index: idx,
        };
    });
    const toConfirm = [];
    const notConfirmed = [];
    //send transactions in batches
    const sendedTransactions = await sendInstructions(txWithIdx, batchSize, wallet, connection);
    toConfirm.push(...sendedTransactions);
    const done = await new Promise((resolve) => {
        const maxConfirmBatchSize = 256;
        const confirmationInterval = setInterval(async () => {
            if (!toConfirm.length) {
                toConfirmIsEmptyCount += 1;
            }
            else {
                toConfirmIsEmptyCount = 0;
            }
            console.log({
                notConfirmed: notConfirmed.length,
                toConfirm: toConfirm.length,
            });
            if (toConfirmIsEmptyCount === toConfirmIsEmptyCheckEndThreshold) {
                if (!notConfirmed.length || retryCount >= maxRetryNumber) {
                    resolve('done');
                    clearInterval(confirmationInterval);
                }
                else {
                    const instructionsToRetry = notConfirmed.map((x) => {
                        return {
                            ...transactionInstructionsWithSigners[x.index],
                            index: x.index,
                        };
                    });
                    const sendedTransactions = await sendInstructions(instructionsToRetry, batchSize, wallet, connection);
                    retryCount += 1;
                    startBlockCheck = false;
                    //clear array of not confirmed
                    notConfirmed.splice(0, notConfirmed.length);
                    toConfirm.push(...sendedTransactions);
                }
            }
            const statusChecks = [connection.getSignatureStatuses([...toConfirm.slice(0, maxConfirmBatchSize).map((x) => x.id)])];
            if (startBlockCheck) {
                statusChecks.push(connection.getLatestBlockhash('confirmed'));
            }
            //checking signatures + after timeoutPeriod we start checking current block
            const [signatures, block] = await Promise.all(statusChecks);
            for (let i = 0; i < signatures?.value?.length; i++) {
                const signature = signatures.value[i];
                if (signature?.confirmationStatus === 'confirmed') {
                    //remove item from que
                    toConfirm.splice(i, 1);
                }
                else {
                    const nowTimestamp = (0, tools_1.getUnixTs)();
                    if (nowTimestamp - toConfirm[i].timestamp >= timeoutSecs) {
                        startBlockCheck = true;
                        console.log(block && block.lastValidBlockHeight, toConfirm[i].sendedAtBlock + tools_1.MAXIMUM_NUMBER_OF_BLOCKS_FOR_TRANSACTION);
                        if (block &&
                            block.lastValidBlockHeight >= toConfirm[i].sendedAtBlock + tools_1.MAXIMUM_NUMBER_OF_BLOCKS_FOR_TRANSACTION) {
                            notConfirmed.push({
                                id: toConfirm[i].id,
                                index: toConfirm[i].index,
                            });
                            //remove item from que
                            toConfirm.splice(i, 1);
                        }
                    }
                }
            }
        }, confirmationIntervalPeriod);
    });
    return done;
};
exports.parallelTransactionProcessor = parallelTransactionProcessor;
