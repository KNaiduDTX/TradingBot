import { Commitment, Connection, RpcResponseAndContext, SignatureStatus, SimulatedTransactionResponse, Transaction, TransactionConfirmationStatus, TransactionSignature, VersionedTransaction } from '@solana/web3.js';
import { BlockHeightStrategy, SequenceType, TimeStrategy, TransactionInstructionWithSigners, WalletSigner } from './globalTypes';
export interface TransactionInstructionWithType {
    instructionsSet: TransactionInstructionWithSigners[];
    sequenceType?: SequenceType;
}
export interface TransactionsPlayingIndexes {
    transactionsIdx: {
        [txIdx: number]: number;
    }[];
    sequenceType?: SequenceType;
}
export type awaitTransactionSignatureConfirmationProps = {
    txid: TransactionSignature;
    confirmLevel: TransactionConfirmationStatus;
    connection: Connection;
    timeoutStrategy: TimeStrategy | BlockHeightStrategy;
    config?: {
        logFlowInfo?: boolean;
    };
    abortSignal?: AbortSignal;
};
/**
 * waits for transaction confirmation
 * @param timeoutStrategy TimeStrategy | BlockHeightStrategy
 *
 * TimeStrategy: pure timeout strategy
 *
 *  timeout: optional, (secs) after how much secs not confirmed transaction will be considered timeout, default: 90
 *  getSignatureStatusesPoolIntervalMs: optional, (ms) pool interval of getSignatureStatues, default: 4000
 *
 *
 * BlockHeightStrategy: blockheight pool satrategy
 *
 *  startBlockCheckAfterSecs: optional, (secs) after that time we will start to pool current blockheight and check if transaction will reach blockchain, default: 90
 *  block: BlockhashWithExpiryBlockHeight
 *  getSignatureStatusesPoolIntervalMs: optional, (ms) pool interval of getSignatureStatues and blockheight, default: 4000
 * @param config.logFlowInfo when true it will console log process of processing transactions
 */
export declare const awaitTransactionSignatureConfirmation: ({ txid, confirmLevel, connection, timeoutStrategy, config, abortSignal, }: awaitTransactionSignatureConfirmationProps) => Promise<RpcResponseAndContext<SignatureStatus>>;
export type sendAndConfirmSignedTransactionProps = {
    signedTransaction: Transaction | VersionedTransaction;
    connection: Connection;
    confirmLevel?: TransactionConfirmationStatus;
    timeoutStrategy: TimeStrategy | BlockHeightStrategy;
    callbacks?: {
        postSendTxCallback?: ({ txid }: {
            txid: string;
        }) => void;
        afterTxConfirmation?: () => void;
    };
    config?: {
        resendTxUntilConfirmed?: boolean;
        resendPoolTimeMs?: number;
        logFlowInfo?: boolean;
        skipPreflight?: boolean;
        useVersionedTransactions?: boolean;
    };
    backupConnections?: Connection[];
};
/**
 * send and waits for transaction to confirm
 * @param callbacks sets of callbacks.
 * @param callbacks.postSendTxCallback post send transaction callback
 * @param callbacks.afterTxConfirmation runs after tx confirmation
 * @param timeoutStrategy TimeStrategy | BlockHeightStrategy
 *
 * TimeStrategy: pure timeout strategy
 *
 *  timeout: optional, (secs) after how much secs not confirmed transaction will be considered timeout, default: 90
 *  getSignatureStatusesPoolIntervalMs: optional, (ms) pool interval of getSignatureStatues, default: 4000
 *
 *
 * BlockHeightStrategy: blockheight pool satrategy
 *
 *  startBlockCheckAfterSecs: optional, (secs) after that time we will start to pool current blockheight and check if transaction will reach blockchain, default: 90
 *  block: BlockhashWithExpiryBlockHeight
 *  getSignatureStatusesPoolIntervalMs: optional, (ms) pool interval of getSignatureStatues and blockheight, default: 4000
 *
 * @param config.resendTxUntilConfirmed force resend transaction in the mean time of waiting for confirmation, default false
 * @param config.resendPoolTimeMs when resendTxUntilConfirmed is true it will resend transaction every value of ms until there is timeout, default: 2000
 * @param config.logFlowInfo when true it will console log process of processing transactions
 * @param config.skipPreflight
 */
export declare const sendAndConfirmSignedTransaction: ({ signedTransaction, confirmLevel, connection, callbacks, timeoutStrategy, config, backupConnections, }: sendAndConfirmSignedTransactionProps) => Promise<string>;
export type sendSignAndConfirmTransactionsProps = {
    connection: Connection;
    wallet: WalletSigner;
    transactionInstructions: TransactionInstructionWithType[];
    timeoutStrategy?: BlockHeightStrategy;
    confirmLevel?: TransactionConfirmationStatus;
    callbacks?: {
        afterFirstBatchSign?: (signedTxnsCount: number) => void;
        afterBatchSign?: (signedTxnsCount: number) => void;
        afterAllTxConfirmed?: () => void;
        afterEveryTxConfirmation?: () => void;
        onError?: (e: any, notProcessedTransactions: TransactionInstructionWithType[], originalProps: sendSignAndConfirmTransactionsProps) => void;
        afterEveryTxSend?: ({ txid }: {
            txid: string;
        }) => void;
    };
    config?: {
        maxTxesInBatch: number;
        autoRetry: boolean;
        maxRetries?: number;
        retried?: number;
        logFlowInfo?: boolean;
        useVersionedTransactions?: boolean;
    };
    backupConnections?: Connection[];
};
/**
 * sign and send array of transactions in desired batches with different styles of send for each array
 * @param timeoutStrategy
 *
 * BlockHeightStrategy: blockheight pool satrategy
 *
 *  startBlockCheckAfterSecs: optional, (secs) after that time we will start to pool current blockheight and check if transaction will reach blockchain, default: 90
 *  block: BlockhashWithExpiryBlockHeight
 *  getSignatureStatusesPoolIntervalMs: optional, (ms) pool interval of getSignatureStatues and blockheight, default: 4000
 *
 *
 * @param callbacks sets of callbacks
 * @param callbacks.afterFirstBatchSign callback will run only on first batch approval
 * @param callbacks.afterBatchSign callback will run on any batch approval
 * @param callbacks.afterAllTxConfirmed callback will run after all transaction batches are confirmed
 * @param callbacks.afterEveryTxConfirmation callback will run on every single transaction confirmation
 * @param callbacks.onError callback will run on error
 * @param callbacks.afterEveryTxSend callback will run after every sended tx has tx signature as param
 *
 * @param config.maxTxesInBatch max transactions in one batch of transactions, there is limitation on how much wallet can sign in one go depending on used wallet. default 40
 * @param config.autoRetry auto retry on any error approve and send of transaction after error
 * @param config.maxRetries if auto retry is true, it will try this amount of times before actual error, default 5
 * @param config.retired argument passed by recursive function best not to change it, default 0
 * @param config.logFlowInfo when true it will console log process of processing transactions
 * @param config.useVersionedTransactions will send all txes as versioned transactions
 */
export declare const sendSignAndConfirmTransactions: ({ connection, wallet, transactionInstructions, confirmLevel, timeoutStrategy, callbacks, config, backupConnections, }: sendSignAndConfirmTransactionsProps) => Promise<void>;
/** Copy of Connection.simulateTransaction that takes a commitment parameter. */
export declare function simulateTransaction(connection: Connection, transaction: Transaction | VersionedTransaction, commitment: Commitment, logInfo?: boolean): Promise<RpcResponseAndContext<SimulatedTransactionResponse>>;
